/***************************************************
Author: hqztrue
https://github.com/hqztrue/LeetCodeSolutions
Complexity: O(n^2)
If you find this solution helpful, plz give a star:)
***************************************************/
typedef long long ll;
typedef unsigned int uint;
template<class T>
struct Gethash{
    size_t operator ()(const T &x)const{return x;}
};
template<> size_t Gethash<int>::operator ()(const int &x)const{return x;}
template<> size_t Gethash<long long>::operator ()(const long long &x)const{return x^(x>>32);}
template<> size_t Gethash<float>::operator ()(const float &x)const{static Gethash<int> h; return h(*((int*)&x));}  //assert(sizeof(float)==sizeof(int));
template<> size_t Gethash<double>::operator ()(const double &x)const{static Gethash<long long> h; return h(*((long long*)&x));}
template<> size_t Gethash<char*>::operator ()(char *const &_str)const{
    const size_t seed=131;size_t hash=0;char *str=_str;
    while (*str)hash=hash*seed+*str++;
    return hash;
}
template<> size_t Gethash<string>::operator ()(const string &s)const{
    size_t hash=5381;
    for (string::const_iterator i=s.begin();i!=s.end();++i)hash+=(hash<<5)+*i;
    return hash;
}
template<> size_t Gethash<pair<int,int> >::operator ()(const pair<int,int> &x)const{return (x.first<<15)+(x.first>>8)+x.second;}
template<class Tkey,class Tvalue=bool,class _Hash=Gethash<Tkey> >
struct Hash{
    _Hash gethash;
    struct node{
        Tkey first;Tvalue second;node *next;
        node():next(0){}
        node(const Tkey &x,const Tvalue &y,node *_next=0):first(x),second(y),next(_next){}
    };
    node **v,*key;size_t len,P,max_size;
    struct iterator{
        size_t i;node *j;Hash<Tkey,Tvalue,_Hash> *H;
        iterator(){}
        iterator(size_t _i,node *_j,Hash<Tkey,Tvalue,_Hash> *_H):i(_i),j(_j),H(_H){go();}
        void go(){
            if (i<H->P&&!j){
                for (++i;i<H->P&&!H->v[i];++i);
                if (i==H->P)j=0;else j=H->v[i];
            }
        }
        node operator *(){return *j;}
        iterator& operator ++(){j=j->next;go();return *this;}
        iterator operator ++(int){iterator res=*this;++*this;return res;}
        iterator& operator --(){
            if (j==H->v[i]){for (--i;!H->v[i];--i);for (j=H->v[i];j->next;j=j->next);}
            else {node *k=j;for (j=H->v[i];j->next!=k;j=j->next);}
            return *this;
        }
        iterator operator --(int){iterator res=*this;--*this;return res;}
        node* operator ->()const{return j;}
        inline friend bool operator ==(const iterator &x,const iterator &y){return x.i==y.i&&x.j==y.j;}
        inline friend bool operator !=(const iterator &x,const iterator &y){return x.i!=y.i||x.j!=y.j;}
        bool operator !(){return i==H->P;}
        operator bool(){return i!=H->P;}
    };
    iterator begin(){return iterator(0,v[0],this);}
    iterator end(){return iterator(P,0,this);}
    //void operator =(const Hash &y){}
    void Grow(){
        static double rate=1.7;Hash<Tkey,Tvalue,_Hash> res(max_size*2,size_t(rate*max_size*2));
        for (size_t i=0;i<P;++i)
            for (node *j=v[i];j;j=j->next)res.insert(j->first,j->second);
        free();*this=res;
    }
    void build(size_t L,size_t p){
        P=p;len=0;max_size=L;++L;key=new node[L];
        v=new node*[p];memset(v,0,sizeof(node*)*p);
    }
    Hash(size_t len=3,size_t p=5){build(len,p);}
    void clear(){len=0;memset(v,0,sizeof(node*)*P);}
    //void clear(){free();build(3,5);}
    Tvalue& insert(const Tkey &x,const Tvalue &y=Tvalue()){
        //if (&find_(x)){Tvalue *null=NULL;return *null;}
        if (len==max_size)Grow();size_t x1=gethash(x)%P;
        key[++len]=node(x,y,v[x1]);v[x1]=key+len;
        return key[len].second;
    }
    void insert_(const Tkey &x,const Tvalue &y=Tvalue()){
        size_t x1=gethash(x)%P;
        for (node *i=v[x1];i;i=i->next)
            if (i->first==x){i->second=y; return;}
        if (len==max_size)Grow(),x1=gethash(x)%P;
        key[++len]=node(x,y,v[x1]);v[x1]=key+len;
    }
    Tvalue& insert(const pair<Tkey,Tvalue> &p){return insert(p.first,p.second);}
    void erase(const Tkey &x){
        size_t x1=gethash(x)%P;
        for (node *i=v[x1],*pre=0;i;pre=i,i=i->next)if (i->first==x)
            if (!pre)v[x1]=i->next;else pre->next=i->next;
    }
    void erase(iterator x){
        if (x.j==v[x.i])v[x.i]=x->next;
        else {node *y=x->next;--x;x->next=y;}
    }
    Tvalue* find_(const Tkey &x){
        size_t x1=gethash(x)%P;
        for (node *i=v[x1];i;i=i->next)
            if (i->first==x)return &i->second;
        return NULL;
    }
    iterator find(const Tkey &x){
        size_t x1=gethash(x)%P;
        for (node *i=v[x1];i;i=i->next)
            if (i->first==x)return iterator(x1,i,this);
        return end();
    }
    Tvalue& operator [](const Tkey &x){
        Tvalue *res=find_(x);if (res==0)return insert(x);return *res;
    }
    bool empty(){return len==0;}
    size_t size(){return len;}
    size_t count(const Tkey &x){return find_(x)?1:0;}
    void free(){delete[] key;delete[] v;}
    ~Hash(){}
    /*void print(){
        for (size_t i=0;i<P;++i)
            for (node *j=v[i];j;j=j->next)printf("H[%d]=%d\n",j->first,j->second);
    }*/
};
inline ll mp(uint x,uint y){return ((ll)x<<32)+y;}
class Solution {
public:
    bool splitArray(vector<int>& a) {
        int n=a.size(); if (n<7)return 0;
        Hash<ll,int> M;
        vector<int> s=a;
        for (int i=1;i<n;++i)s[i]+=s[i-1];
        for (int i=1;i<=n-2;++i)M[mp(s[n-1]-s[i],a[i])]=i;
        auto minmax=minmax_element(a.begin(),a.end());
        int minv=*minmax.first,maxv=*minmax.second;
        int mins=(s[n-1]-3*maxv)/4,maxs=(s[n-1]-3*minv)/4;
        for (int i=1;i<n-5;++i){
            int s1=s[i-1];
            if (s1<mins||s1>maxs)continue;
            for (int j=i+2;j<n-3;++j){
                int s2=s[j-1]-s[i];
                if (s1!=s2||s2<mins||s2>maxs)continue;
                int *it=M.find_(mp(s1,s[n-1]-s[j]-s1*2));
                if (it&&*it>=j+2)return 1;
            }
        }
        return 0;
    }
};


作者：hqztrue
链接：https://leetcode.cn/problems/split-array-with-equal-sum/solution/on2-meet-in-the-middle-c-0ms-100-by-hqzt-3kfp/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。