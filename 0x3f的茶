日期	题解请滑到右边 -->	样例	难度	题解	备注	
2023年10月10日	https://codeforces.com/problemset/problem/1690/E

输入 T(≤1e4) 表示 T 组数据。所有数据的 n 之和 ≤2e5。
每组数据输入 n(2≤n≤2e5) k(1≤k≤1000) 和长为 n 的数组 a(0≤a[i]≤1e9)。
保证 n 是偶数。
你需要把这 n 个数两两一对。把 a[i] 和 a[j] 组成一对的得分为 floor((a[i]+a[j])/k)。
最大化这 n/2 个数对的得分之和。输出这个最大值。	输入
6
6 3
3 2 7 1 4 8
4 3
2 1 5 6
4 12
0 0 0 0
2 1
1 1
6 10
2 0 0 5 9 4
6 5
5 3 8 6 3 2
输出
8
4
0
2
1
5	1500	首先每个数的 floor(a[i]/k) 是必得的，加到答案中，然后更新 a[i] %= k。

为了继续得分，我们必须选尽量多的数对，满足 a[i]+a[j] >= k，这样可以多得一分。

怎么做？把 a 排序后，相向双指针：

- 如果 a[i] + a[j] < k，说明 a[i] 加上任何小于 a[j] 的数，都是小于 k 的，所以 a[i] 不能和其余数加在一起得分了，i++。
- 否则，可以得一分，i++ j--。如果 a[j] 不和 a[i] 匹配，那么后面 a[i] 可能无法和另一个数匹配了

https://codeforces.com/contest/1690/submission/227301239

相似题目：
881. 救生艇		
2023年10月9日	https://atcoder.jp/contests/abc321/tasks/abc321_d

输入 n m(1≤n,m≤2e5) p(1≤p≤2e8)，和长度分别为 n 和 m 的数组 a 和 b，元素范围 [1,1e8]。
输出如下程序打印的值：
sum = 0
for x in a:
    for y in b:
        sum += min(x + y, p)
print(sum)	输入
2 2 7
3 5
6 1
输出 24

输入
1 3 2
1
1 1 1
输出 6	806	把 a 和 b 从小到大排序。
倒着遍历 a，同时维护指针 j，它是满足 a[i]+b[j] >= p 的最小值。
那么对于 a[i] 来说：
b[0] 到 b[j-1] 中的任何数和 a[i] 相加都是 < p 的，把 a[i] * j + (b[0] + ... + b[j-1]) 加入答案。
b[j] 到 b[m-1] 中的任何数和 a[i] 相加都是 >= p 的，把 p * (m-j) 加入答案。

https://atcoder.jp/contests/abc321/submissions/46275700		
2023年10月6日	https://atcoder.jp/contests/tenka1-2019/tasks/tenka1_2019_d

输入 n(3≤n≤300) 和长为 n 的数组 a(1≤a[i]≤300)。
把每个 a[i] 都涂成红/绿/蓝三种颜色中的一种。（相当于把 a 分成 3 个子序列）
记红色元素和为 R，绿色元素和为 G，蓝色元素和为 B。
问：有多少种涂色方案，使得 R,G,B 组成了一个非退化三角形的三条边。模 998244353。

注：非退化三角形即面积为正的三角形，或者说三顶点不共线的三角形。	输入
4
1
1
1
2
输出 18

输入
6
1
3
2
3
5
2
输出 150	2237	请看题解：
https://www.luogu.com.cn/blog/endlesscheng/solution-at-tenka1-2019-d		
2023年10月5日	https://atcoder.jp/contests/abc279/tasks/abc279_f

输入 n(2≤n≤3e5) 表示有 n 个盒子，编号从 1 到 n。
每个盒子都放了一个小球，其中编号为 i 的盒子放了编号为 i 的小球。

然后输入 q(1≤q≤3e5) 和 q 个操作，格式如下：
"1 x y"：把编号为 y 的盒子中的小球全部放入编号为 x 的盒子中。保证 x≠y。
"2 x"：设所有盒子中一共有 k 个小球，现在把一个新的编号为 k+1 的小球放入编号为 x 的盒子中。
"3 x"：输出编号为 x 的小球所在盒子的编号。保证 x 一定在某个盒子中。	输入
5 10
3 5
1 1 4
2 1
2 4
3 7
1 3 1
3 4
1 1 4
3 7
3 6
输出
5
4
3
1
3	1777	看上去是个并查集模板，但是把盒子 y 中的小球倒入盒子 x 后，盒子 y 是可以继续放入小球的。

这要怎么办？y 已经合并到 x 中了。

我们可以为 y 创建一个（大于 n 的）新的编号 z，表示一个新的空盒子。后续放入 y 的小球，就改为放在盒子 z 中。
但是这样做，要怎么输出小球所在的盒子编号呢？
记录编号为 z 的盒子的【原始盒子编号】为 y 即可。

具体细节见代码。

https://atcoder.jp/contests/abc279/submissions/46217952		
2023年10月4日	https://atcoder.jp/contests/dwacon5th-prelims/tasks/dwacon5th_prelims_b

输入 n(2≤n≤1000) k(1≤k≤n*(n+1)/2) 和长为 n 的数组 a(1≤a[i]≤1e9)。
a 一共有 n*(n+1)/2 个非空连续子数组，也有对应的 n*(n+1)/2 个子数组元素和。
从这 n*(n+1)/2 个元素和中，选择 k 个，计算这 k 个数的按位与（AND）。
按位与的最大值是多少？

不考虑输入的空间，你能做到 O(1) 额外空间吗？	输入
4 2
2 5 2 5
输出 12

输入
8 4
9 1 8 2 7 5 6 4
输出 32	1381	从高位到低位考虑。
如果所有子数组和的第 x 位有超过 k 个 1，那么答案的第 x 位可以是 1，且后续只需要考虑第 x 位是 1 的子数组和。
如果不足 k 个 1，那么答案的第 x 位只能是 0。

https://atcoder.jp/contests/dwacon5th-prelims/submissions/46029217		
2023年10月3日	https://atcoder.jp/contests/abc222/tasks/abc222_d

输入 n(1≤n≤3000) 和两个长为 n 的数组 a b，元素范围在 [0,3000]，且均为递增数组（允许有相同元素）。
构造递增数组 c（允许有相同元素），满足 a[i]<=c[i]<=b[i]。
输出你能构造多少个不同的 c，模 998244353。	输入
2
1 1
2 3
输出 5

输入
3
2 2 2
2 2 2
输出 1

输入
10
1 2 3 4 5 6 7 8 9 10
1 4 9 16 25 36 49 64 81 100
输出 978222082	865	有两种定义 DP 的方式。

定义 f[i][j] 表示考虑前 i 个数，其中第 i 个数填 j 的方案数
那么有 f[i][j] = f[i-1][0] + f[i-1][1] + ... + f[i-1][min(j, b[i-1])]
这可以用前缀和优化。

这启发我们，也可以直接定义 f[i][j] 表示考虑前 i 个数，其中第 i 个数填的数 <=j 的方案数。
考虑第 i 个数是否要填 j：
- 不填，那就是第 i 个数填的数 <=j-1 的方案数，即 f[i][j] = f[i][j-1]。
- 填，那么第 i-1 个数至多为 j，即 f[i][j] = f[i-1][min(j, b[i-1])]。
则有 f[i][j] = f[i][j-1] + f[i-1][min(j, b[i-1])]。
初始值 f[0][j] = j-a[0]+1，其中 a[0]<=j<=b[0]。
答案为 f[n-1][b[n-1]]。

https://atcoder.jp/contests/abc222/submissions/46028545		
2023年10月2日	https://atcoder.jp/contests/abc125/tasks/abc125_d

输入 n(2≤n≤1e5) 和长为 n 的数组 a(-1e9≤a[i]≤1e9)。
你可以执行如下操作任意多次：
选择 a 中两个相邻数字，把它们俩都乘上 -1。
输出 sum(a) 的最大值。

思考：如果只能选择 a[i] 和 a[i+2] 呢？（间隔一个数）
思考：如果至多操作 k 次呢？	输入
3
-10 5 -4
输出 19

输入
5
10 -4 -8 -11 3
输出 30

输入
11
-1000000000 1000000000 -1000000000 1000000000 -1000000000 0 1000000000 -1000000000 1000000000 -1000000000 1000000000
输出 10000000000	833	操作不会改变负数个数的奇偶性。
如果有偶数个负数（或者存在 0），那么所有数都可以变成非负数。
如果有奇数个负数，并且没有 0，那么最后会剩下一个负数，我们可以让绝对值最小的那个数是负数。

https://atcoder.jp/contests/abc125/submissions/46144732

如果至多操作 k 次，可以用 DP 思考。		
2023年9月29日	https://atcoder.jp/contests/agc015/tasks/agc015_d

输入 A B (1≤A≤B<2^60)。
问：有多少个数，可以由 [A,B] 内的一个或多个整数，通过按位或 (OR) 运算得到？

思考：改成 AND 要怎么做？改成 XOR 呢？	输入
7
9
输出 4
解释 除了 7,8,9 以外，还可以通过 7 OR 8 得到 15，所以一共有 4 个数。

输入
65
98
输出 63

输入
271828182845904523
314159265358979323
输出 68833183630578410	2655	请看题解：
https://www.luogu.com.cn/blog/endlesscheng/solution-at-agc015-d		
2023年9月28日	https://atcoder.jp/contests/abc208/tasks/abc208_e

输入 n(1≤n≤1e18) 和 k(1≤k≤1e9)。
问：有多少个不超过 n 的正整数，其数位乘积不超过 k？	输入 13 2
输出 5
解释 1,2,10,11,12 共 5 个

输入 100 80
输出 99

输入 1000000000000000000 1000000000
输出 841103275147365677	2024	注意到乘积要么是 0，要么可以写成 2^a * 3^b * 5^c * 7^d 的形式。
所以只有 O(log^4 k) 个不同的数位乘积。

数位 DP 模板秒杀。记忆化用哈希表。

https://atcoder.jp/contests/abc208/submissions/45250040		
2023年9月27日	https://atcoder.jp/contests/abc098/tasks/arc098_b

输入 n(1≤n≤2e5) 和长为 n 的数组 a(0≤a[i]<2^20)。
a 有多少个非空连续子数组，满足元素和等于元素异或和？

思考：改成子序列要怎么做？	输入
4
2 5 4 6
输出 5

输入
9
0 0 0 0 0 0 0 0 0
输出 45

输入
19
885 8 1 128 83 32 256 206 639 16 4 128 689 32 8 64 885 969 1
输出 37	1404	这个等式意味着什么？
意味着二进制加法不能有任何进位，否则等式右边一定大于左边。

没有任何进位相当于什么？
相当于子数组中的任意两个数，同一个比特位上不能都是 1，也就是说，任意两个数的按位与（AND）为 0。

这题就是：
2401. 最长优雅子数组  

可以用滑动窗口做到 O(n)，请看题解：
暴力枚举 / 双指针 

https://atcoder.jp/contests/abc098/submissions/45104677		
2023年9月26日	https://atcoder.jp/contests/abc202/tasks/abc202_d

输入 A B(1≤A,B≤30) K。
在所有由恰好 A 个 'a' 和恰好 B 个 'b' 组成的字符串中，输出字典序第 K 小的字符串。
例如 K=1 表示字典序最小的字符串。
K 的范围保证有解。	输入 2 2 4
输出 baab

输入 30 30 118264581564861424
输出 bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbaaaaaaaaaaaaaaaaaaaaaa	966	如果第一个字母是 'b'，那么 K 至少要是多少？

=> 第一个字母填 'a' 一共有多少种方案？

=> C(a+b-1, b)

=> 如果 K > C(a+b-1, b)，那么第一个字母一定是 'b'

依此类推。

https://atcoder.jp/contests/abc202/submissions/45501705		
2023年9月25日	https://atcoder.jp/contests/abc138/tasks/abc138_d

输入 n(2≤n≤2e5) q(1≤q≤2e5) 表示一个 n 个点的树（节点编号从 1 开始，根节点为 1）。
然后输入 n-1 条边（每行两个数）。
然后输入 q 个操作，每个操作输入 p(1≤p≤n) x(1≤x≤1e4)，表示把子树 p 内的所有节点值都加 x。（一开始所有节点值均为 0）
输出最终每个节点的节点值。（按节点编号从小到大输出）	输入
4 3
1 2
2 3
2 4
2 10
1 100
3 1
输出 100 110 111 110

输入
6 2
1 2
1 3
2 4
3 6
2 5
1 10
1 10
输出 20 20 20 20 20 20	920	只需要记录节点 p 的节点值增加了多少。
然后从 1 开始 DFS 这棵树，DFS 的同时累加从 1 到当前节点 x 的这条路径上的节点值之和，即为节点 x 的最终节点值。
（类似 lazy 线段树的懒标记下传 push down）

https://atcoder.jp/contests/abc138/submissions/45500929		
2023年9月22日	https://atcoder.jp/contests/diverta2019/tasks/diverta2019_e

输入 n(1≤n≤5e5) 和长为 n 的数组 a(0≤a[i]<2^20)。
把数组 a 划分成若干段连续子数组，一共有 2^(n-1) 种划分方案。
问：其中有多少种划分方案，可以让每段子数组的异或和都一样？
答案模 1e9+7。	输入
3
1 2 3
输出 3
解释 一共有四种划分方案：
[1,2,3]
[1],[2,3]
[1,2],[3]
[1],[2],[3]
除了最后一种不符合要求，其余三种都是符合要求的。

输入
3
1 2 2
输出 1
解释 只有一种合法划分方案，就是什么也不划分。	2423	请看题解：
https://www.luogu.com.cn/blog/endlesscheng/solution-at-diverta2019-e		
2023年9月21日	https://atcoder.jp/contests/abc058/tasks/arc071_b

输入 n m(2≤n,m≤2e5)，长为 n 的严格递增数组 x(-1e9≤x[i]≤1e9)，长为 m 的严格递增数组 y(-1e9≤y[i]≤1e9)。
从 x 中选两个数，组成直线 X=x[i1], X=x[i2]，其中 i1<i2。
从 y 中选两个数，组成直线 Y=y[j1], Y=y[j2]，其中 j1<j2。
这四条直线包围的区域是一个矩形。
计算所有矩形的面积之和。模 1e9+7。	输入
3 3
1 3 4
1 3 6
输出 60

输入
6 5
-790013317 -192321079 95834122 418379342 586260100 802780784
-253230108 193944314 363756450 712662868 735867677
输出 835067060	1641	提示 1：手玩下 n=3, m=3 的情况（图形是一个田字）。把公式列出来。

矩形面积 = 长*宽，在 n=3, m=3 的情况下，可以有 3 种长，3 种宽。
所有矩形面积 = 长1*宽1 + 长1*宽2 + 长1*宽3 + 长2*宽1 + 长2*宽2 + 长2*宽3 + 长3*宽1 + 长3*宽2 + 长3*宽3
= (长1 + 长2 + 长3) * (宽1 + 宽2 + 宽3)

所以，长和宽可以分别计算。
对于 x，问题变成：所有 x[j]-x[i] 的和 (i<j)。

提示 2：贡献法，考虑 x[i] 在和式中的贡献是多少？
即：有多少个 +x[i]？有多少个 -x[i]？

解答：（i 从 0 开始）有 i 个 +x[i]，有 n-1-i 个 -x[i]。
所以 x[i] 在和式中的贡献为 2*i-n+1。

这样，我们就得到了一个 O(n+m) 的算法。

https://atcoder.jp/contests/abc058/submissions/45464458		
2023年9月20日	https://atcoder.jp/contests/arc158/tasks/arc158_b

输入 n(3≤n≤2e5) 和长为 n 的数组 a(-1e6≤a[i]≤1e6 且 a[i]≠0)。
从 a 中选 3 个下标不同的数 x y z。
输出 (x+y+z)/(x*y*z) 的最小值和最大值。
和答案的绝对/相对误差需要在 1e-12 内。	输入
4
-2 -4 4 5
输出
-0.175000000000000
-0.025000000000000

输入
4
1 1 1 1
输出
3.000000000000000
3.000000000000000

输入
5
1 2 3 4 5
输出
0.200000000000000
1.000000000000000	1446	如果知道 x 和 y，那么式子可以变形为
(x+y)/(xy) * (1/z) + 1/(xy)
由反比例函数的性质可知，当 z 取绝对值最小或最大的数时，可以让式子取到最值。
对于 x 和 y 也同理。
所以至多考虑 12 个数即可（负数中最小 3 个，最大 3 个，正数中最小 3 个，最大 3 个），在这里面枚举 x y z。

https://atcoder.jp/contests/arc158/submissions/45499928		
2023年9月19日	https://atcoder.jp/contests/abc301/tasks/abc301_d

输入长度 ≤60 的字符串 s，只包含 '0'，'1' 和 '?'。
输入 n(1≤n≤1e18)。
你需要把 s 中的 ? 替换成 0 或 1，从而得到一个二进制数 x。
问：不超过 n 的最大 x 是多少？
以十进制形式输出这个最大值。
如果不存在这样的 x，输出 -1。	输入
?0?
2
输出 1

输入
101
4
输出 -1

输入
?0?
1000000000000000000
输出 5	885	把 ? 都替换成 0，如果此时 x > n，则输出 -1。
然后从左到右遍历每个 ?，如果把这个 ? 替换成 1，右侧 ? 替换成 0 后，满足 x <= n，那么这个 ? 一定要替换成 1，否则这个 ? 一定要替换成 0。

https://atcoder.jp/contests/abc301/submissions/45500660		
2023年9月18日	https://atcoder.jp/contests/abc248/tasks/abc248_d

输入 n(1≤n≤2e5) 和长为 n 的数组 a(1≤a[i]≤n)，下标从 1 开始。
然后输入 q 个询问，每个询问输入 L R (1≤L≤R≤n) 和 x(1≤x≤n)。
对每个询问，输出有多少个下标 i 在 [L,R] 内的 a[i]，满足 a[i]=x。	输入
5
3 1 4 1 5
4
1 5 1
2 4 3
1 5 2
1 3 3
输出
2
0
0
1	793	遍历 a，把相同元素 x 的所有下标统计到列表 pos[x] 中。
每个询问的答案就是 <= R 的下标个数，减去 < L 的下标个数。
在 pos[x] 中二分查找即可算出。

https://atcoder.jp/contests/abc248/submissions/45034624

离线做法可以做到线性时间复杂度，见右图。@田永杰🍩		
2023年9月15日	https://atcoder.jp/contests/arc136/tasks/arc136_d

输入 n(2≤n≤1e6) 和长为 n 的数组 a(0≤a[i]<1e6)。
输出满足【十进制加法 a[i]+a[j] 的每个数位都没有产生进位】的下标对 (i,j) 个数，其中 i<j。	输入
4
4 8 12 90
输出 3

输入
20
313923 246114 271842 371982 284858 10674 532090 593483 185123 364245 665161 241644 604914 645577 410849 387586 732231 952593 249651 36908
输出 6

输入
5
1 1 1 1 1
输出 10	1908	举例，如果一个数和 666 相加不进位，那么与 665 相加也不会进位。

定义 y 是 x 的「十进制子集」，当且仅当 y 的所有数位都小于等于 x 对应的数位。例如 666,566,656,665,123,66 都是 666 的十进制子集。

定义 f[i] 表示 i 的十进制子集的个数。
为什么要这样定义？对于 a[i] 来说，999999-a[i] 的任意十进制子集与 a[i] 相加都不会进位，所以 f[999999-a[i]] 就是与 a[i] 相加不进位的数字个数。

枚举 i 的第 j 个数位，如果这个数位大于 0，那么
f[i] += f[i-pow(10,j)]
初始值：f[x] = x 在数组 a 中的出现次数。

然后遍历 a[i]，把 f[999999-a[i]] 加到答案中。
如果 a[i]+a[i] 没有进位，那么我们多统计了一个答案，ans--。
最后把答案除以 2，因为 (a[i],a[j]) 和 (a[j],a[i]) 我们都统计了一次。

https://atcoder.jp/contests/arc136/submissions/45039336

注：如果你之前学过二进制的 SOS DP，对于想出本题做法有帮助。
本题相当于是十进制的 SOS DP。		
2023年9月14日	https://atcoder.jp/contests/abc155/tasks/abc155_d

输入 n(2≤n≤2e5) k(1≤k≤n*(n-1)/2) 和长为 n 的数组 a(-1e9≤a[i]≤1e9)。
从 a 中选两个数，相乘，一共可以得到 n*(n-1)/2 个结果。
输出这 n*(n-1)/2 个数中，第 k 小的数。
注：k=1 表示最小的数。

相似题目：
2040. 两个有序数组的第 K 小乘积	输入
4 3
3 3 -4 -2
输出 -6

输入
10 40
5 4 3 2 -1 0 0 0 0 0
输出 6	1845	说一个 O(nlogU) 的做法。U=1e18。
需要用到二分答案+同向双指针+相向双指针。

1. 对 a 从小到大排序。
2. 找到第一个 >= 0 的数的下标 p 和第一个 > 0 的数的下标 q。（下标从 0 开始）
3. 有 neg = p * (n-q) 个乘积是负数。
4. 设 c = q-p，那么有 zero = c*(n-c) + c*(c-1)/2 个乘积是 0。
5. 第一种情况：如果 k <= neg，那么答案是负数。可以二分答案的绝对值 kth，统计有多少数对相乘是负数且绝对值 <= kth，这可以用同向双指针完成。一个指针从 0 开始向右移动，另一个指针从 q 开始向右移动。
6. 第二种情况：如果 k <= neg + zero，那么答案为 0。
7. 第三种情况：如果 k > neg + zero，那么答案是正数。二分答案 kth，统计有多少个对数相乘是正数且 <= kth，这可以用相向双指针完成。对所有负数 a[i] 跑一遍相向双指针，对所有正数 a[i] 跑一遍相向双指针。

https://atcoder.jp/contests/abc155/submissions/45503273

注：二分和双指针是基础中的基础，如果你写这题卡壳了或者 WA 了，说明基本功还不够扎实，请在一个月后重新做这道题。		
2023年9月13日	https://atcoder.jp/contests/code-festival-2016-qualc/tasks/codefestival_2016_qualC_c

输入 n(1≤n≤1e5) 和两个长为 n 的数组 b 和 c (1≤b[i],c[i]≤1e9)。
构造数组 a，满足 a[i] 都是正整数，且：
b[i] = max(a[0], a[1], ..., a[i])，即数组 a 的前缀最大值。
c[i] = max(a[i], a[i+1], ..., a[n-1])，即数组 a 的后缀最大值。
问：有多少个符合要求的数组 a？模 1e9+7。
如果不存在这样的数组 a，输出 0。	输入
5
1 3 3 3 3
3 3 2 2 2
输出 4

输入
5
1 1 1 2 2
3 2 1 1 1
输出 0	1404	如果 b[i]>b[i-1]，那么 a[i] 一定是 b[i]。如果此时 c[i] < b[i]，矛盾，输出 0。
同理，如果 c[i]>c[i+1]，那么 a[i] 一定是 c[i]。如果此时 b[i] < c[i]，矛盾，输出 0。
如果 b[i]=b[i-1] 且 c[i]=c[i+1]，那么 a[i] 可以填不超过 min(b[i],c[i]) 的正整数，这有 min(b[i],c[i]) 种方案。
所有 a[i] 的方案数相乘即为答案。

https://atcoder.jp/contests/code-festival-2016-qualc/submissions/45329380		
2023年9月12日	https://atcoder.jp/contests/arc137/tasks/arc137_b

输入 n(1≤n≤2e5) 和长为 n 的数组 a(0≤a[i]≤1)。
你需要执行如下操作恰好一次：
选择 a 的一个连续子数组（可以为空），把子数组内的 0 变成 1，1 变成 0。
设新数组为 a'。
问：你可以得到多少个不同的 sum(a')？	输入
4
0 1 1 0
输出 4

输入
5
0 0 0 0 0
输出 6

输入
6
0 1 0 1 0 1
输出 3	883	提示 1：sum(a') 最大是多少？最小是多少？

提示 2-1：sum(a') 在原来的 sum(a) 的基础上，最多可以增加多少？

提示 2-2：把子数组内的 0 视作 1，1 视作 -1。
最大子数组和就是最大增量 maxInc。

提示 2-3：把子数组内的 0 视作 -1，1 视作 1。
最大子数组和就是最大减少量 maxDec。
注：也可以在提示 2-2 的基础上计算最小子数组和。

提示 3：答案就是 maxInc+maxDec+1。
证明：我们可以在任意子数组的基础上「微调」，也就将子数组的长度加一或者减一。例如把 0 包含入子数组，那么变化量仅会 +1。同理，把 0 移出子数组，那么变化量仅会 -1。对于把 1 包含入/移出子数组的情况同理。
因此可以把变化量从 -maxDec 不断微调到 maxInc，所以变化量可以取到 [-maxDec, maxInc] 中的任意整数，这一共有 maxInc+maxDec+1 个数。

https://atcoder.jp/contests/arc137/submissions/45319475 

相似题目：
https://codeforces.com/contest/1695/problem/C		
2023年9月11日	https://atcoder.jp/contests/abc248/tasks/abc248_c

输入 n m(1≤n,m≤50) k(n≤k≤n*m)。
输出有多少个长为 n 的数组 a 满足 1≤a[i]≤m 且 sum(a)≤k。
模 998244353。

数据加强版	输入 2 3 4
输出 6

输入 31 41 592
输出 798416518	787	方法一：朴素 DP

f[i][j] 表示前 i 个数的元素和为 j 的方案数。i 从 1 开始。
f[i][j] = f[i-1][j-1] + f[i-1][j-2] + ... + f[i-1][max(j-m,0)]
初始值 f[0][0] = 1。
答案为 sum(f[n])。

https://atcoder.jp/contests/abc248/submissions/45034906 

方法二：后缀和优化 DP

把转移方程中的和式用后缀和优化。
用后缀和的原因是可以一边计算状态一边计算后缀和，这样就不需要 f 数组了，只需要后缀和数组。

https://atcoder.jp/contests/abc248/submissions/45035045		
2023年9月8日	https://atcoder.jp/contests/abc243/tasks/abc243_g

输入 T(≤20) 表示 T 组数据。
每组数据输入 X(1≤X≤9e18)。
请构造一个长为 10^100 的数组 a，满足：
1. a[i] 均为正整数。
2. a[0] = X。
3. a[i] * a[i] <= a[i-1]。
输出你可以构造出多少个不同的数组。	输入
4
16
1
123456789012
1000000000000000000
输出
5
1
4555793983
23561347048791096	2032	下标从 0 开始。

提示 1：
枚举 a[2]，那么 a[1] 的范围就确定了。
设 m = floor(sqrt(a[0]))。
那么 a[1] 的范围就是 [a[2]*a[2], m]，这一共有 m-a[2]*a[2]+1 个数，这些数都可以是 a[1]。

提示 2：
定义 f[i] 表示序列的首项为 i 时，可以构造出多少个不同的数组。
根据提示 1，有
f[i] = sum(f[j] * (m-j*j+1))，这里 1 <= j <= sqrt(m)。

提示 3：
预处理出 f[1] 到 f[54772]，就可以直接用上式算出 f[X]。这里 54772 = floor(pow(9e18, 0.25))。
预处理可以不用像上式那样复杂，枚举 a[1]，可以得到
f[i] = sum(f[j])，这里 1 <= j <= sqrt(i)。
这个式子又可以化简成
f[i] = f[i-1] + (i 是完全平方数 ? f[floor(sqrt(i))] : 0)

https://atcoder.jp/contests/abc243/submissions/45083883		
2023年9月7日	https://atcoder.jp/contests/abc309/tasks/abc309_f

输入 n(2≤n≤2e5) 和 n 个盒子的长宽高，每行输入三个数，范围 [1,1e9]。
你可以随意旋转盒子，也可以保持不变。
问：是否存在一个盒子可以被另一个盒子装下，也就是一个盒子的长宽高都分别严格小于另一个盒子的长宽高。
输出 "Yes" 或 "No"。

相似题目：
1691. 堆叠长方体的最大高度	输入
3
19 8 22
10 24 12
15 25 11
输出 Yes

输入
3
19 8 22
10 25 12
15 24 11
输出 No

输入
2
1 1 2
1 2 2
输出 No	1619	请先阅读：
【图解】算法优化+详细证明 

接着上面的题解说。对于每个盒子，把长宽高从小到大排序（排序后分别记作 a[i][0], a[i][1], a[i][2]），然后按照 a[i][0] 从小到大排序所有盒子。

接下来只需要考虑是否有 a[i][1] < a[j][1] 且 a[i][2] < a[j][2]，这可以用树状数组解决（数据范围太大可以用离散化或者哈希表实现）。
把 (a[i][1], a[i][2]) 看成是二维平面的坐标点，我们可以维护 x=a[i][1] 这条线左侧的所有坐标点的纵坐标的最小值，即前缀最小值 preMin(a[i][1]-1)。
只要满足 preMin(a[i][1]-1) < a[i][2] 就可以输出 Yes。
具体细节见代码，注意为了满足严格小于，对于相同的 a[i][0] 需要先查询完再一并更新。

https://atcoder.jp/contests/abc309/submissions/45242148
		
2023年9月6日	https://atcoder.jp/contests/abc194/tasks/abc194_e

输入 n m(1≤m≤n≤1.5e6) 和长为 n 的数组 a(0≤a[i]<n)。
定义 mex(b) 为不在数组 b 中的最小非负整数。
遍历 a 的所有长为 m 的连续子数组 b，输出 mex(b) 的最小值。	输入
3 2
0 0 1
输出 1

输入
3 2
1 1 1
输出 0

输入
3 2
0 1 0
输出 2

输入
7 3
0 0 1 2 0 1 0
输出 2	1088	方法一：通用的做法是值域树状数组二分。（留给大家思考）

方法二：更巧妙的做法。

提示 1：先把前 m 个数的 mex 算出来，答案至多是它。

提示 2：我们只需要知道最小的 mex 是多少，因此当一个数滑出窗口时，只要窗口内没有这个数，那么就用这个数更新答案的最小值。

https://atcoder.jp/contests/abc194/submissions/45036824		
2023年9月5日	https://atcoder.jp/contests/abc308/tasks/abc308_e

输入 n(3≤n≤2e5) 和长为 n 的数组 a(0≤a[i]≤2)，以及长为 n 的字符串，仅包含 'M' 'E' 'X'。
遍历所有满足 i<j<k 且 s[i]=M 且 s[j]=E 且 s[k]=X 的下标三元组 (i,j,k)，累加 mex(a[i],a[j],a[k]) 的值，输出这个累加值。
注：mex(a[i],a[j],a[k]) 表示不在 a[i],a[j],a[k] 中的最小非负整数。	输入
4
1 1 0 2
MEEX
输出 3

输入
3
0 0 0
XXX
输出 0

输入
15
1 1 2 0 0 2 0 2 0 0 0 0 0 2 2
EXMMXXXEMEXEXMM
输出 13	1042	方法一：前后缀分解

枚举中间的 j。我们需要知道左边满足 s[i]=M 的 0/1/2 的个数；右边满足 s[k]=X 的 0/1/2 的个数。
这可以预处理出来。
当 s[j]=E 时，枚举 j 左边的 0/1/2 和 j 右边的 0/1/2 的 9 种组合，再算上 a[j]，得到 mex。
例如 a[j]=1，左边有 5 个 1，右边有 3 个 0，那么 mex(1,1,0)=2，对答案的贡献是 5*3=15 个 mex，也就是 30。

https://atcoder.jp/contests/abc308/submissions/45101686 

方法二：状态机 DP

定义 f0[0/1/2] 表示当前统计的满足 s[i]=M 的 0/1/2 的个数。
定义 f1[1/2/3/4/5/6] 表示当前统计的满足 a[i]=M 且 a[j]=E 的 a[i] 和 a[j] 组成的集合（二进制表示）的个数，例如 f1[5] 表示集合 {0,2} 的个数。
遍历到 s[k]=X 时，枚举 mask=1/2/3/4/5/6，把答案加上 mex(mask 和 a[k] 组成的集合) * f1[mask]

https://atcoder.jp/contests/abc308/submissions/45102151		
2023年9月4日	https://atcoder.jp/contests/diverta2019/tasks/diverta2019_c

输入 n(1≤n≤1e4) 和 n 个字符串，每个字符串只包含大写字母，长度在 [2,10] 中。
将这些字符串按照某种顺序相连，得到字符串 s。
问：s 中最多可以有多少个连续子串是 "AB"？

进阶：子串长度为 3
https://codeforces.com/gym/102431/problem/H	输入
3
ABCA
XBAZ
BAD
输出
2	922	首先把每个字符串中的 AB 个数加到答案中。

接着，如果只考虑以 A 结尾的字符串（个数记作 a），或者以 B 开头的字符串（个数记作 b），每一对拼起来可以得到一个 AB，那么答案额外加上 min(a,b)。
然后，考虑以 B 开头且以 A 结尾的字符串（个数记作 ba），这些字符串可以「插入」到上面拼起来的 AB 之间，那么答案额外加上 ba+min(a,b)。
除了一种特殊情况：ba > 0 且 a = 0 且 b = 0，此时答案只能加上 ba-1。

https://atcoder.jp/contests/diverta2019/submissions/45086403		
2023年9月1日	https://atcoder.jp/contests/arc092/tasks/arc092_b

输入 n(1≤n≤2e5) 和两个长为 n 的数组 a b，元素范围在 [0,2^28)。
从 a 中选一个数 a[i]，从 b 中选一个数 b[j]，相加得到 a[i]+b[j]。这一共有 n^2 个数字。
输出这 n^2 个数的异或和。	输入
2
1 2
3 4
输出 2

输入
6
4 6 0 0 3 3
0 5 6 5 0 3
输出 8

输入
5
1 2 3 4 5
1 2 3 4 5
输出 2

输入
1
0
0
输出 0	2207	二进制题目，常用技巧之一是拆位，但这只能用于各个比特位互相独立的情况。
本题加法有进位，破坏了这种独立性，这要如何处理呢？

其实也可以拆位（我叫它加法拆位）。
按照 mod (2^k) 拆位，例如要计算从低到高第三个比特位，可以 mod 8（即 AND 7）。

记 s = a[i]%8 + b[j]%8。
要想知道这 n^2 个 s 中，从低到高第三个比特位有多少个 1，相当于求满足下式的 s 的个数：
100 <= s <= 111 或 1100 <= s <= 1111（数字为二进制）。
这可以在按照 mod 8 排序后，用五个指针做。一个指针遍历 a[i]，另外 4 个指针在 b 上，对应着上式的 4 个区间端点。

注意：相加可能会进位到第 29 个比特位，在枚举的时候请注意上界。

https://atcoder.jp/contests/arc092/submissions/44922461 


优化：
注意到 s <= 1<<(k+2)-1 是恒成立的，上面代码中的 q 恒等于 n-1。
而 n 个 n-1 的异或和一定是偶数（最低位一定是 0），所以可以完全去掉 q。

优化后		
2023年8月31日	https://atcoder.jp/contests/abc300/tasks/abc300_f

输入 n(1≤n≤3e5) m(1≤m≤1e9) k 和长为 n 的字符串 s，只包含小写字母 'o' 和 'x'。
保证至少有一个 'x'，保证 1≤k≤s.count('x')*m。

将 s 重复 m 次，得到字符串 t。例如 "abc" 重复 3 次得到 "abcabcabc"。
请你修改 t 中的恰好 k 个 'x'。修改后，输出 t 中最长连续 'o' 的长度。	输入
10 1 2
ooxxooooox
输出 9

输入
5 3 4
oxxox
输出 8

输入
30 1000000000 9982443530
oxoxooxoxoxooxoxooxxxoxxxooxox
输出 19964887064	1846	写了很多 if-else？
实际上有一种写法，完全不需要分类讨论！

设 pos 为所有 x 的下标列表（下标从 0 开始）。
设 pos 的长度为 cntX。

提示 1：把前 k 个 x 修改成 o，答案是多少？
min(k/cntX*n + pos[k%cntX], n*m)

提示 2：把前 2~k+1 个 x 修改成 o，答案是多少？
可以先算出「修改前 k+1 个 x」的答案，再减去「第一个 x 的下标 +1」。
把上面公式中的 k 替换成 k+1 就是「修改前 k+1 个 x」的答案。

依此类推，一直枚举到最后一个 x。

https://atcoder.jp/contests/abc300/submissions/44909568		
2023年8月30日	https://atcoder.jp/contests/abc295/tasks/abc295_d

输入长度 ≤5e5 的字符串 s，只包含数字字符。
定义 f(t)：如果字符串 t 中的每个字符都出现偶数次，则 f(t)=1，否则 f(t)=0。
枚举 s 的所有非空连续子串 t，输出 f(t) 之和。	输入 20230322
输出 4

输入 0112223333444445555556666666777777778888888889999999999
输出 185

输入 3141592653589793238462643383279502884197169399375105820974944
输出 9	939	用「前缀异或和」实现，具体请看我在力扣上的这篇题解：

题解

https://atcoder.jp/contests/abc295/submissions/44903277		
2023年8月29日	https://atcoder.jp/contests/abc294/tasks/abc294_e

给你两个长度均 L 的数组 a 和 b，输出有多少个下标 i 满足 a[i]=b[i]。

由于 L 很大，输入用一种压缩格式表示，即 (元素值，连续出现次数)。
例如 [(10,2),(20,1),(10,3)] 表示数组 [10,10,20,10,10,10]。

具体输入格式和数据范围见题目链接。

进阶：
https://ac.nowcoder.com/acm/contest/62033/D	输入
8 4 3
1 2
3 2
2 3
3 1
1 4
2 1
3 3
输出
4	792	有思路但不一定好写的题目。
用双指针做。
通过引入「剩余连续长度」这一概念，可以简化代码逻辑，请看代码。

https://atcoder.jp/contests/abc294/submissions/44905290		
2023年8月28日	https://atcoder.jp/contests/abc233/tasks/abc233_d

输入 n(1≤n≤2e5) k(-1e15≤k≤1e15) 和长为 n 的数组 a(-1e9≤a[i]≤1e9)。
输出元素和等于 k 的连续子数组个数。

如果你觉得本题太简单，请思考这个问题：
所有元素和等于 k 的连续子数组的长度之和。	输入
6 5
8 -3 5 7 0 -4
输出 3	726	用前缀和思考：
sum[R] - sum[L] = k
枚举 R，问题变成有多少个 sum[L]，也就是 sum[R]-k 的个数。
这可以用哈希表统计，代码如下。

https://atcoder.jp/contests/abc233/submissions/44903090

关于思考题的提示：
举例：
(R-L1) + (R-L2) + (R-L3)
= 3*R - (L1+L2+L3)
所以除了维护前缀和的出现次数，还需要维护下标之和。		
2023年8月25日	https://atcoder.jp/contests/arc137/tasks/arc137_c

输入 n(2≤n≤3e5) 和长为 n 的严格递增数组 a(0≤a[i]≤1e9)。

Alice 和 Bob 在玩一个回合制游戏，Alice 先手。
游戏规则如下：
1. 一开始，数轴上有 n 颗石子，第 i 颗石子的位置是 a[i]。
2. 每个回合，玩家只能移动最右边的那颗石子。且必须将它移动到在它左边的没有石子的非负整数空位上。例如 a=[2,4]，你只能移动位置 4 上的石子到位置 0 或 1 或 3。
3. 移动石子后，轮到另一个玩家继续移动这 n 颗石子中的最右边的石子。如此交替。
4. 无法移动的玩家输掉游戏，另一位玩家获胜。

如果 Alice 必胜，输出 Alice，否则输出 Bob。	输入 
2
2 4
输出 Alice
解释 Alice 把 4 移动到 3，就可以保证必胜。（手玩一下）

输入 
3
0 1 2
输出 Bob	2043	题解已写好，欢迎点赞！		
2023年8月24日	https://atcoder.jp/contests/abc298/tasks/abc298_f

输入 n(1≤n≤2e5) 和 n 行，每行三个数 x y v，表示一个二维坐标点 (x,y) 和这个坐标点上的数字 v (1≤x,y,v≤1e9)。
不在输入中的坐标点上的数字均为 0。

请你选择一个坐标点 (X,Y)，累加所有横坐标为 X 的坐标点上的数字，以及所有纵坐标为 Y 的坐标点上的数字。
(X,Y) 上的数字只累加一次。
(X,Y) 不一定要在输入中。

输出累加值的最大值。	输入 
4
1 1 2
1 2 9
2 1 8
3 2 3
输出 20

输入 
1
1 1000000000 1
输出 1	1568	先预处理所有行和列的元素和（用两个哈希表）。

暴力做法：把所有横纵坐标都记录下来，写一个二重循环枚举所有横坐标和纵坐标的组合。
显然这个做法会超时。

但如果把纵坐标按照列的元素和从大到小排序，对于内层循环，只要当前枚举的 (x,y) 不在输入中，就可以退出内层循环了，因为后面算出的元素和只会更小。

这种做法可以保证至多遍历 n 个值为 0 的坐标。

https://atcoder.jp/contests/abc298/submissions/44850426		
2023年8月23日	https://atcoder.jp/contests/abc300/tasks/abc300_e

输入 n(1≤n≤1e18)。
你有一个整数 x，初始值为 1。
你有一个六面的骰子，可以等概率地掷出 1~6。

不断重复如下操作，直到 x>=n 为止：
掷骰子。把 x 乘上骰子显示的数字。

问：当你停止操作时，x 恰好等于 n 的概率是多少？
设概率为 a/b，输出 a * pow(b,mod-2) % mod，其中 mod=998244353。	输入 6
输出 239578645

输入 7
输出 0

输入 300
输出 183676961

输入 979552051200000000
输出 812376310	1354	定义 P(n) 表示得到 n 的概率。
则有 P(n) = (1/6) * (P(n) + P(n/2) + P(n/3) + P(n/4) + P(n/5) + P(n/6))。
整理得到 P(n) = (1/5) * (P(n/2) + P(n/3) + P(n/4) + P(n/5) + P(n/6))。
如果 n%i>0，则 P(n/i)=0。

由于 n 很大，需要用 map+记忆化搜索。从 n 出发递归到 1。
递归边界：P(1)=1。

注：除以 5 等价于乘以 pow(5,998244353-2)%998244353 = 598946612。

https://atcoder.jp/contests/abc300/submissions/44675024		
2023年8月22日	https://atcoder.jp/contests/abc296/tasks/abc296_d

输入 n m(1≤n,m≤1e12)。
选两个不超过 n 的正整数 a 和 b，使得 a*b 至少为 m。
输出 a*b 的最小值。如果不存在这样的 a 和 b，输出 -1。	输入 5 7
输出 8

输入 2 5
输出 -1

输入 100000 10000000000
输出 10000000000	999	从 1 开始枚举 a。
那么 b 最小可以是 ceil(m/a)。
如果 b<=n，用 a*b 更新答案的最小值。

注意到当 b<a 时，这种情况必然在之前枚举过，无需重复枚举。（回想一下枚举因子的算法）
所以 b<a 就可以 break 了。

时间复杂度 O(min(n, sqrt(m)))。 

https://atcoder.jp/contests/abc296/submissions/44674708		
2023年8月21日	https://atcoder.jp/contests/abc298/tasks/abc298_d

最初 S="1"。
输入 q(≤6e5) 和 q 个操作，操作的输入格式如下：
如果输入的是 1 x，把 x 加到 S 末尾。其中 1≤x≤9。
如果输入的是 2，删除 S 的第一个数字。
如果输入的是 3，把 S 视作一个整数，输出它模 998244353 的结果。	输入
3
3
1 2
3
输出
1
12

输入
3
1 5
2
3
输出
5	943	取模小练习。

设当前数字为 cur，用队列维护 s。
操作 1 是 cur = cur * 10 + x，把 x 加到 s 末尾。
操作 2 是 cur = cur - s[0] * pow(10, len(s)-1)，弹出 s 队首。
注意取模。由于减法会产生负数，在输出答案的时候要调整为非负数。

代码实现时，预处理 pow(10, ...) 或者用逆元，可以做到线性时间。

https://atcoder.jp/contests/abc298/submissions/44656651		
2023年8月18日	https://atcoder.jp/contests/abc159/tasks/abc159_f

输入 n(1≤n≤3000) s(1≤s≤3000) 和长为 n 的数组 a(1≤a[i]≤3000)。
定义 f(L,R) 等于：在子数组 a[L],a[L+1],...,a[R] 中，元素和恰好等于 s 的子序列的个数。
输出所有 f(L,R) 的和，其中 0≤L≤R<n。
模 998244353。	输入 
3 4
2 2 4
输出 5

输入 
5 8
9 9 9 9 9
输出 0

输入
10 10
3 1 4 1 5 9 2 6 5 3
输出 152	1876	下标从 0 开始。

定义 f[i][j] 表示子数组右端点为 i（左端点任意），子序列和为 j 的方案数。
本题要求的答案就是 f[0][s]+f[1][s]+...+f[n-1][s]。

考虑 a[i] 选或不选，有
f[i][j] = f[i-1][j] + f[i-1][j-a[i]]

初始值：f[i][0] = i+1。例如 f[1][0] 表示子数组 {a[1]} 中有 1 个子序列和为 0，子数组 {a[0],a[1]} 中有 1 个子序列和为 0，所以 f[1][0]=2。

https://atcoder.jp/contests/abc159/submissions/44666661		
2023年8月17日	https://atcoder.jp/contests/abc301/tasks/abc301_e

输入 n m(1≤n,m≤300) t(1≤t≤2e6) 和一个 n 行 m 列的网格图。
S 为起点（恰好一个）。
G 为终点（恰好一个）。
. 为空地。
# 为墙壁。
o 为糖果（至多 18 个）。

你需要从起点走到终点。每一步可以上下左右四个方向走到相邻的非墙壁格子上，不能出界。
你可以重复访问同一个格子。
注：如果走到终点，可以继续走，只要最后在终点就行。
至多走 t 步。
输出你至多能收集多少个糖果（走到 o 即可收集，同一个格子只能收集一次）。
如果无法在 t 步内到达终点，输出 -1。

相似题目：
LCP 13. 寻宝	输入
3 3 5
S.G
o#o
.#.
输出 1

输入
3 3 1
S.G
.#o
o#.
输出 -1

输入
5 10 2000000
S.o..ooo..
..o..o.o..
..o..ooo..
..o..o.o..
..o..ooo.G
输出 18	1673	计算每对 o 之间的最短距离，用 dis 数组记录。这一步可以用 BFS 解决。

由于 o 至多有 18 个，可以转换成一个旅行商问题（请自行搜索），用状压 DP 解决。

定义 f[s][i] 表示已收集的 o 的下标集合为 s，且当前在第 i 个 o 时的最小移动步数。
枚举 s 的补集中的下标 j，用 f[s][i] + dis[i][j] 去更新 f[s|1<<j][j] 的最小值。

为了简化代码，可以把起点和终点也视作 o。
不过这样会慢一些，代码把起点终点单独处理了。

时间复杂度 O(knm+k^2*2^k)。

https://atcoder.jp/contests/abc301/submissions/44602551	从集合论到位运算，常见位运算技巧分类总结！	
2023年8月16日	https://atcoder.jp/contests/abc290/tasks/abc290_e

输入 n(1≤n≤2e5) 和长为 n 的数组 a(1≤a[i]≤n)。
定义 f(b) 表示把数组 b 修改成回文数组，至少要修改多少个数。
例如 f([1,2])=1，f([1,2,1])=0，f([1,2,3,4])=2。
对 a 的每个连续子数组 b，分别独立计算 f(b)。
输出所有 f(b) 的和。	输入
5
5 2 1 2 2
输出 9	1485	错误的思路：区间 DP。复杂度太高，没有优化空间。

提示 1：一对数只需修改其中一个。

提示 2：正难则反，考虑有多少对数字无需修改。用所有数对个数，减去无需修改的数对个数，就是需要修改的数对个数。
所有数对个数 = sum(长为 i 的子数组个数 * floor(i/2))，其中【长为 i 的子数组个数】就是 n+1-i。
可以写个 for 循环计算，也可以用公式 O(1) 算。

提示 3：贡献法。对于 a[i]=a[j] 的这对数，考虑这对数能出现在多少个子数组中。
什么时候子数组的个数取决于 i，什么时候取决于 j？

答：设下标从 0 开始。如果 i+j<n，那么取决于 i，否则取决于 j。
（想象成从 [i,j] 不断向外扩展，i 向左，j 向右）

提示 4：保存相同元素的下标列表 pos。

方法一：相向双指针。

设 p 为 pos 中的一个下标列表（下标从 0 开始）。
初始化 l=0，r=len(p)-1，循环直到 l>=r。
如果 p[l]+p[r]<n，那么有 p[l]+1 个子数组是包含 p[l] 和 p[r] 的。（这里的包含指 p[l] 和 p[r] 作为回文数组的对称位置）
此外，这意味着 p[l]+p[r-1] 也是 < n 的，那么也有 p[l]+1 个子数组是包含 p[l] 和 p[r-1] 的。
此外，这意味着 p[l]+p[r-2] 也是 < n 的，那么也有 p[l]+1 个子数组是包含 p[l] 和 p[r-2] 的。
依此类推，从 r'=r 到 r'=l+1，这样的 r' 一共有 r-l 个。
那么 p[l] 对答案的贡献为 (p[l]+1) * (r-l)。
如果 p[l]+p[r]>=n，那么同理可得 p[r] 对答案的贡献为 (n-p[r]) * (r-l)。

时间复杂度 O(n)。
代码：
https://atcoder.jp/contests/abc290/submissions/44626822

方法二：二分查找。

如果你没有想到相向双指针，那么二分可能更适合你。

遍历 r。我们可以在 p 中二分找哪些 p[l] 满足 p[l]+p[r]<n，哪些 p[l] 满足 p[l]+p[r]>=n，分别统计。

时间复杂度 O(nlogn)。
代码：
https://atcoder.jp/contests/abc290/submissions/44626962		
2023年8月15日	https://atcoder.jp/contests/abc253/tasks/abc253_e

输入 n(2≤n≤1000) m k(0≤k<m≤5000)。
输出有多少个长为 n 的数组，满足元素范围为 [1,m] 且 abs(a[i]-a[i+1]) >= k。
模 998244353。	输入 2 3 1
输出 6

输入 3 3 2
输出 2

输入 100 1000 500
输出 657064711	1073	前缀和优化 DP。

定义 f[i][j] 表示考虑前 i 个数，其中 a[i]=j 的方案数。
根据要求，从所有 abs(j-j') >= k 的 f[i-1][j'] 转移过来，这个和式可以用前缀和优化成 O(1)。
初始值 f[0][j] = 1。
答案为 sum(f[n-1])。

https://atcoder.jp/contests/abc253/submissions/44438512		
2023年8月14日	https://codeforces.com/problemset/problem/1728/C

输入 T(≤1e4) 表示 T 组数据。所有数据的 n 之和 ≤2e5。
每组数据输入 n(1≤n≤2e5) 和两个长为 n 的数组 a b (1≤a[i],b[i]<1e9)。

每次操作，把其中一个数组的一个元素替换成这个数的十进制长度。比如 123 替换成 3。
若干次操作后，将 a 和 b 排序，要求所有 a[i]=b[i]。
输出最小操作次数。	输入
4
1
1
1000
4
1 2 3 4
3 1 4 2
3
2 9 3
1 100 9
10
75019 709259 5 611271314 9024533 81871864 9 3 6 4865
9503 2 371245467 6 7 37376159 8 364036498 52295554 169
输出
2
0
2
18	1400	注意到所有元素都 < 1e9，这意味着把一个数字替换一次，一定会得到一个 < 10 的数，替换两次，一定会得到 1。
那么先把 a 和 b 中 >= 10 的数求交集，这些交集中的数无需替换，直接忽略，其余数字都需要替换。
替换后，所有数都 < 10 了，把 >= 2 的数求交集，这些交集中的数无需替换，直接忽略，其余数字都需要替换。
再次替换后，a 中 1 的个数一定等于 b 中 1 的个数。程序结束。
所以只需要考虑两个问题：>= 10 的不在交集的数的个数，以及（替换后）>= 2 的不在交集的数的个数。

https://codeforces.com/problemset/submission/1728/217090588		
2023年8月11日	https://atcoder.jp/contests/abc299/tasks/abc299_g

输入 n m(1≤m≤n≤2e5) 和长为 n 的数组 a(1≤a[i]≤m)，保证 [1,m] 内的所有整数都在 a 中。
输出 a 的一个长为 m 的子序列，要求它是一个 1~m 的排列，且字典序最小。	输入
4 3
2 3 1 3
输出
2 1 3

输入
4 4
2 3 1 4
输出
2 3 1 4

输入
20 10
6 3 8 5 8 10 9 3 6 1 8 3 3 7 4 7 2 7 8 5
输出
3 5 8 10 9 6 1 4 2 7	2088	这题和 316. 去除重复字母 是一样的

题解已写好，欢迎点赞！	https://atcoder.jp/contests/abc299/submissions/44426858	
2023年8月10日	https://atcoder.jp/contests/abc281/tasks/abc281_f

输入 n(1≤n≤1.5e5) 和长为 n 的数组 a(0≤a[i]<2^30)。
选一个非负整数 x，然后把每个 a[i] 更新成 a[i] XOR x。
输出 max(a) 的最小值。	输入
3
12 18 11
输出 16
解释：取 x=2

输入
10
0 0 0 0 0 0 0 0 0 0
输出 0

输入
5
324097321 555675086 304655177 991244276 9980291
输出 805306368	1714	处理二进制问题的基本技巧之一是【拆位】。

从高到低枚举比特位。如果在第 k 位上，有些 a[i] 是 0，有些 a[i] 是 1，那么无论 x 的第 k 位是 0 还是 1，max(a) 的第 k 位必定是 1。
分类讨论：
如果 x 第 k 位取 0，那么 a[i] 第 k 位也是 0 的就不用考虑了，只需要考虑 a[i] 第 k 位是 1 的。
如果 x 第 k 位取 1，那么 a[i] 第 k 位也是 1 的就不用考虑了，只需要考虑 a[i] 第 k 位是 0 的。

这启发我们得到如下分治算法：
定义 f(a, k) 表示只考虑 <= k 位的前提下，max(a) 的最小值。
如果 a[i] 的第 k 位都一样，那么 f(a, k) = f(a, k-1)。
如果 a[i] 的第 k 位不都一样，那么 f(a, k) = min(f(b, k-1), f(c, k-1)) | (1 << k)，其中 b 表示第 k 位是 0 的元素组成的数组，c 表示第 k 位是 1 的元素组成的数组。
递归边界：k<0 时，返回 0。
递归入口：f(a, 29)。

代码实现时：
1. 为了快速判断【a[i] 的第 k 位是否都一样】，可以先把 a 排序，再去分治。
2. 为了快速分出数组 b 和数组 c，可以用二分查找 0 和 1 的分界线，为此需要多一个参数 pre 表示 a[i] 二进制的公共前缀，具体见代码。
注：可以不用二分查找，因为写个 for 循环来找分界线也 ok。

https://atcoder.jp/contests/abc281/submissions/44402795		
2023年8月9日	https://atcoder.jp/contests/abc214/tasks/abc214_d

输入 n(2≤n≤1e5) 和一棵树的 n-1 条边（节点编号从 1 开始），每条边包含 3 个数 a b c，表示有一条边权为 c(1≤c≤1e7) 的边连接 a 和 b。
定义 f(x,y) 表示从 x 到 y 的简单路径上的最大边权。
输出所有 f(i,j) 的和，其中 i<j。

相似题目：
2421. 好路径的数目
https://codeforces.com/problemset/problem/915/F	输入
3
1 2 10
2 3 20
输出 50
解释 f(1,2)+f(2,3)+f(1,3)=10+20+20=50

输入
5
1 2 1
2 3 2
4 2 5
3 5 14
输出 76	1341	贡献法。

假设边 x-y 的边权为 z，如果 x 通过 <= z 的边可以到达 a 个点，y 通过 <= z 的边可以到达 b 个点，根据乘法原理，总共有 a*b 条简单路径通过 x-y，所以这条边对答案的贡献为 a*b*z。

这启发我们得到下面的做法：
按照边权从小到大遍历这些边，一边遍历一边用并查集 merge 这些边，同时维护每个点所在的点集大小。
（merge 前）上面说的 a 就是 x 所在点集的大小，b 就是 y 所在点集的大小。

https://atcoder.jp/contests/abc214/submissions/44395458		
2023年8月8日	https://atcoder.jp/contests/abc262/tasks/abc262_d

输入 n(1≤n≤100) 和长为 n 的数组 a(1≤a[i]≤1e9)。
如果一个非空子序列的平均值是整数，那么称其为漂亮的。
输出 a 的漂亮子序列的个数，模 998244353。
注：子序列不一定连续。	输入
3
2 6 2
输出 6

输入 
5
5 5 5 5 5
输出 31	1213	枚举子序列的长度。

考虑子序列长度固定为 m 时，有多少个平均值为整数的子序列。
相当于子序列的元素和模 m 为 0。

用选或不选来思考。
定义 f[i][j][k] 表示从前 i 个数中选 j 个数，元素和模 m 为 k 的方案数。

为方便计算取模，用刷表法（用查表法的话，需要算 (k-a[i])%m，可能会算出负数）：
f[i][j][(k+a[i])%m] = f[i-1][j][(k+a[i])%m] + f[i-1][j-1][k]

答案为 f[n][m][0]。

代码实现时，第一个维度可以去掉，然后像 0-1 背包那样倒序循环 j。初始值 f[0][0] = 1。

https://atcoder.jp/contests/abc262/submissions/44370034		
2023年8月7日	https://atcoder.jp/contests/abc280/tasks/abc280_e

输入 n(1≤n≤2e5) p(0≤p≤100)
怪物的血量为 n。
每次攻击，有 p/100 的概率会对怪物造成 2 点伤害，有 1-p/100 的概率会造成 1 点伤害。
让怪物血量 <= 0，攻击次数的期望是多少？
假设期望等于分数 a/b，你需要输出 a * pow(b, mod-2) % mod，其中 mod=998244353。	输入 3 10
输出 229596204

输入 5 100
输出 3

输入 280 59
输出 567484387	1251	期望 DP 入门题。

用 f[i] 表示血量为 i 时的攻击次数的期望。
那么 f[i] = p/100 * (f[i-2]+1) + (1-p/100) * (f[i-1]+1)
初始值 f[0]=0, f[1]=1。
答案为 f[n]。

https://atcoder.jp/contests/abc280/submissions/44230154		
2023年8月4日	https://atcoder.jp/contests/abc288/tasks/abc288_f

输入 n(2≤n≤2e5) 和长为 n 的数字 s，保证 s 不含 0。
把 s 分割成若干段，得分为每一段的乘积。特别地，如果不分割，则得分为 s。
输出所有分割方案的得分之和，模 998244353。
注：一共有 2^(n-1) 种分割方案。	输入
3
234
输出 418
解释 234 + 2*34 + 23*4 + 2*3*4 = 418

输入
4
5915
输出 17800

输入
9
998244353
输出 258280134	
2024	提示 1：从划分型 DP 入手，你能否找到一个规模更小的子问题？

例如 s=1234，如果最后一段为 34，那么得分为 12*34+1*2*34 = (12+1*2)*34。
注意 12+1*2 是 12 的所有划分的得分之和。
由此可见，枚举出最后一段后，我们可以把问题变成一个规模更小的子问题。

提示 2：定义 f[i] 表示分割前 i 个数字的得分之和（i 从 1 开始）
f[0] = 0
f[i] = val(1,i) + f[1]*val(2,i) + f[2]*val(3,i) + ... + f[i-1]*val(i,i)
其中 val(j,i) 表示 s[j] 到 s[i] 这一段对应的数字。
但这样写是 O(n^2) 的。

提示 3：观察 f[i-1] 的转移方程与 f[i] 的转移方程的差异。

提示 4：val(j,i) = val(j,i-1) * 10 + (s[i] - '0') 
根据这一式子可以得到
f[i] = f[i-1] * 10 + (1+f[1]+f[2]+...+f[i-1]) * (s[i] - '0')
所以再用一个变量 sumF 表示 1+f[1]+f[2]+...+f[i-1]，就可以 O(1) 地从 f[i-1] 算出 f[i] 了。

https://atcoder.jp/contests/abc288/submissions/44204756	感觉有点像英雄的力量 
https://leetcode.cn/problems/power-of-heroes/	
2023年8月3日	https://atcoder.jp/contests/arc158/tasks/arc158_c

输入 n(1≤n≤2e5) 和长为 n 的数组 a(1≤a[i]≤1e15)。
定义 f(x) 为 x 的数位和。例如 f(123)=1+2+3=6。
输出所有 f(a[i]+a[j]) 的和，其中 i 取遍 0 到 n-1，j 取遍 0 到 n-1。	输入
2
53 28
输出 36

输入 
1
999999999999999
输出 135

输入
5
123 456 789 101 112
输出 321	1875	提示 1：f(x+y)=f(x)+f(y)-9*k(x,y)，其中 k(x,y) 是计算 x+y 时产生的进位次数。

提示 2：拆位计算，即：
1. 有多少 a[i]+a[j] 时，个位数发生了进位？也就是看 a[i]%10+a[j]%10 >= 10 是否成立。
把数组按照 a[i]%10 排序，然后用相向双指针统计。
2. 有多少 a[i]+a[j] 时，十位数发生了进位？也就是看 a[i]%100+a[j]%100 >= 100 是否成立。
把数组按照 a[i]%100 排序，然后用相向双指针统计。
3. 依此类推，直到 1000..0 > 2*max(a) 时停止。

提示 3：其实到这就说完了，这里补充下怎么化简 ∑_i ∑_j f(a[i])+f(a[j])
 ∑_i ∑_j f(a[i])+f(a[j])
=∑_i (n*f(a[i])+∑_j f(a[j]))
=(n*∑f(a[i])) + (n*∑f(a[j]))
=2n*∑f(a[i])

https://atcoder.jp/contests/arc158/submissions/44190713		
2023年8月2日	https://codeforces.com/problemset/problem/1677/B

输入 T(≤1e4) 表示 T 组数据。所有数据的 n*m 之和 ≤1e6。
每组数据输入 n m(1≤n*m≤1e6) 和长为 n*m 的 01 字符串 s。

有 n*m 个人参加会议，会议厅的座位有 n 行 m 列。
从第一个人开始，依次入场。规则如下：
有人入场时，已入场的人同时向右移动一位，最右的人移动到下一行的最左边。（见样例一）
第 i 个人标记为 s[i]。
输出 n*m 个数，其中第 i 个数表示：第 i 个人入场后，有多少行和列包含至少一个 1？	输入
3
2 2
1100
4 2
11001101
2 4
11001101
输出
2 3 4 3
2 3 4 3 5 4 6 5
2 3 3 3 4 4 4 5

样例一见右图	1700	好题！迷你，精巧，还同时考察了多个知识点。

先说列怎么统计：

提示 1：从「不变量」入手思考：第 i 个人总是和第 i-m,i-2m,i-3m,... 个人在同一列。

提示 2：如果 i-m,i-2m,i-3m,... 中没有 1，那么当 s[i]=1 入场，从这一刻开始，包含至少一个 1 的列的数量永久增加 1。

然后说行怎么统计：

提示 1：考虑第 i 个人入场时，包含至少一个 1 的行的数量。这等于「第 i-m 个人入场时，包含至少一个 1 的行的数量」加上「最新入场的这 m 个人中是否有 1」。

提示 2：滑动窗口维护「最新入场的这 m 个人中的 1 的个数」，记作 window1。
DP 维护「第 i 个人入场时，包含至少一个 1 的行的数量」，即
f[i] = f[i-m] + (window1 > 0)
这个转移方程可以滚动优化成 f[i%m] += window1 > 0，从而避免讨论 i<m 的情况（此时 i-m 是负数）。

https://codeforces.com/contest/1677/submission/216653925		
2023年8月1日	https://codeforces.com/contest/1811/problem/E

输入 T(≤1e4) 表示 T 组数据。
每组数据输入 k(1≤k≤1e12)。
输出第 k 个不含 4 的正整数，例如 k=4 时答案为 5。	输入
7
3
5
22
10
100
12345
827264634912
输出
3
6
25
11
121
18937
2932285320890	1500	想用二分+数位DP？先别急，有更简单的做法。
既然不能包含 4，那我们相当于在用 9 进制计数，所以把 k 转换成 9 进制就行了（>=4 的数位 +1）。

https://codeforces.com/contest/1811/submission/216062310		
2023年7月31日	https://codeforces.com/problemset/problem/1276/A

输入 T(≤1e4) 表示 T 组数据。所有数据字符串长度之和 ≤1.5e6。
每组数据输入一个长度 ≤1.5e5 的字符串 s，只包含小写字母。
删除尽量少的字符，使得字符串中不存在任何连续子串为 one 或 two。
输出：第一行为删除的字符个数。第二行为删除的字符下标（下标从 1 开始）。	输入
4
onetwone
testme
oneoneone
twotwo
输出
2
6 3
0

3
4 1 7
2
1 4	1400	注意到对于 oooneee 这样的字符串，删除 o 或 e 仍然会产生 one，但是删除 n 就不会有 one 了。
同理对于 two 应该删除 w。但是，如果子串是 twone，删除 o 更好。

https://codeforces.com/problemset/submission/1276/216058616		
2023年7月28日	https://codeforces.com/problemset/problem/1336/C

输入长度不超过 3000 的字符串 S，只包含小写字母。设 S 的长度为 n。
输入长度不超过 n 的字符串 T，只包含小写字母。

从一个空字符串 A 开始，执行如下操作不超过 n 次：
删除 S 的第一个字母，然后加到 A 的开头或者末尾。

问：要使 T 是 A 的前缀，有多少种不同的操作方式？模 998244353。
注：即使两个不同的操作方式得到了相同的字符串 A，也算不同的操作方式。	输入
abab
ba
输出 12
解释：见右图，注意第一个 a 有两种操作方式

输入
defineintlonglong
signedmain
输出 0

输入
rotator
rotator
输出 4

输入
cacdcdbbbb
bdcaccdbbb
输出 24	2200	先假设 s 和 t 一样长。
我们不知道 s 的第一个字母和谁匹配，但我们知道 s 的最后一个字母只能与 t[0] 或者 t[m-1] 匹配（加到开头或者末尾）。
假如与 t[0] 匹配，那么问题变成 s[:n-1] 与 t[1:] 匹配的方案数。这是一个规模更小的子问题。
这启发我们得到下面的区间 DP。

把 t 扩充成和 s 一样长，扩充的字母视作任意字符（一定可以与 s[i] 匹配）。
定义 f[i][j] 表示操作前缀 s[0]~s[j-i] 得到子串 t[i]~t[j] 的方案数。
那么答案就是 f[0][m-1]+f[0][m]+...+f[0][n-1]。
考虑 s[j-i] 与 t[i] 还是 t[j] 匹配，可以得到
f[i][j] = (i>=m || s[j-i]==t[i] ? f[i+1][j] : 0) + (j>=m || s[j-i]==t[j] ? f[i][j-1] : 0)
初始值 f[i][i] = (i>=m || s[0]==t[i] ? 2 : 0)
（也可以初始化 f[i+1][i] = 1）

https://codeforces.com/problemset/submission/1336/216028319		
2023年7月27日	https://codeforces.com/problemset/problem/796/C

输入 n(1≤n≤3e5) 和长为 n 的数组 a(-1e9≤a[i]≤1e9) 表示树上每个点的点权，然后输入这棵树的 n-1 条边（节点编号从 1 开始）。
执行如下操作恰好一次：
选一个点作为根节点，根节点的点权不变，它的儿子的点权增加 1，其余点的点权增加 2。
最小化这棵树的最大点权，并输出。	输入
5
1 2 3 4 5
1 2
2 3
3 4
4 5
输出 5

输入
7
38 -29 87 93 39 28 -55
1 2
2 5
3 2
2 4
1 7
7 6
输出 93

输入
5
1 2 7 6 7
1 5
5 3
3 4
2 4
输出 8	1900	做法不止一种，这里说说最简单的用平衡树/最大堆的模拟做法。
先把所有 a[i] 加入集合（平衡树/最大堆），然后从 1 开始枚举 i，以及 i 的邻居（点权要加 1），从集合中去掉这些点的点权后，集合中的最大值就是「其余点」的点权最大值了（点权要加 2），统计完最大值后，再把 i 和 i 的邻居的点权重新加回来。
每次枚举计算出的最大值，再取最小值，就是答案。
用最大堆实现的话可以用 lazy 删除，具体见下面代码。

https://codeforces.com/problemset/submission/796/215802020		
2023年7月26日	https://codeforces.com/problemset/problem/193/A

输入 n m(1≤n,m≤50) 和一个 n 行 m 列的网格图，仅包含 '#' 和 '.'。
输入保证图中任意两个 '#' 都可以通过四方向移动互相到达（连通图）。
输入保证至少有一个 '#'。
你需要把尽量少的 '#' 修改成 '.'，使得网格图不连通。
如果无法做到，输出 -1，否则输出最少修改次数。
注：规定空集（没有 '#'）视作连通图，只有一个 '#' 也视作连通图。

相似题目：2556. 二进制矩阵中翻转最多一次使路径不连通	输入
5 4
####
#..#
#..#
#..#
####
输出 2

输入
5 5
#####
#...#
#####
#...#
#####
输出 2	1700	脑筋急转弯。
如果 # 个数小于 3，那么无法分成多个连通块，输出 -1。
否则有解（注意原图是连通的）。
对于角落的 #，可以把相邻的两个 # 改成 . 使得图不连通，所以至多操作 2 次。
如果角落没有 #，一定存在一个边上的 # 至多有两个 . 邻居，所以也至多操作 2 次。
那么只需要判断能否操作 1 次使图不连通。
代码写的是 O(n^2m^2) 的暴力，可以用 Tarjan 割点做到 O(nm)。

https://codeforces.com/contest/193/submission/215507875

相似题目：2556. 二进制矩阵中翻转最多一次使路径不连通		
2023年7月25日	https://codeforces.com/problemset/problem/746/D

输入 n k(1≤k≤n≤1e5) a b(0≤a,b≤n 且 a+b=n)。
构造一个长为 n 的字符串，包含 a 个 'G' 和 b 个 'B'，且不能有长度超过 k 的连续相同字母。
如果无法构造，输出 NO，否则输出任意一个符合要求的字符串。	输入 5 1 3 2
输出 GBGBG

输入 7 2 2 5
输出 BBGBGBB

输入 4 3 4 0
输出 NO	1500	假设 a>=b，那么可以用 b 个 'B' 当作分割线，尽量均分 a 个 'G'。（把 a 个 'G' 均分成 b+1 段。）
如果发现任意一段连续 'G' 长度超过 k，就输出 NO。
其余实现技巧见代码。

https://codeforces.com/contest/746/submission/215370490	构造	
2023年7月24日	https://codeforces.com/problemset/problem/1772/D

输入 T(≤2e4) 表示 T 组数据。所有数据的 n 之和 ≤2e5。
每组数据输入 n(2≤n≤2e5) 和长为 n 的数组 a(1≤a[i]≤1e8)。
选择一个整数 x(0≤x≤1e9)，生成一个序列 b，满足 b[i]=abs(a[i]-x) 且 b[i]≤b[i+1]。
如果不存在这样的 x，输出 -1，否则输出任意一个符合要求的 x。	输入
8
5
5 3 3 3 5
4
5 3 4 5
8
1 2 3 4 5 6 7 8
6
10 5 4 3 2 1
3
3 3 1
3
42 43 42
2
100000000 99999999
6
29613295 52036613 75100585 78027446 81409090 73215
输出
4
-1
0
42
2
-1
100000000
40741153	1400	只需保证相邻两项满足 abs(a[i]-x)≤abs(a[i+1]-x)，那么整个 b[i] 就是递增的（充分必要条件）。

分类讨论：
如果 a[i]=a[i+1]，x 取什么数都满足上面的不等式，所以无视这种情况。
如果 a[i]<a[i+1]，解得 x≤(a[i]+a[i+1])/2。（画出 abs(a[i]-x) 和 abs(a[i+1]-x) 的图像即可得到）
如果 a[i]>a[i+1]，解得 x≥(a[i]+a[i+1])/2。注意这里的除法没有下取整，代码中要写成 (a[i]+a[i+1]+1)/2。

用 l 维护 x 的最小值，r 维护 x 的最大值。
如果最后 l>r 就输出 -1，否则输出 [l,r] 内的任意整数，例如 l。注意 a[i] 的范围可以保证 x 在 [0,1e9] 内。

https://codeforces.com/problemset/submission/1772/214608589		
2023年7月21日	https://codeforces.com/problemset/problem/543/D

输入 n(2≤n≤2e5) 和 n-1 个数 p2,p3,...,pn，表示一棵 n 个节点的无根树，节点编号从 1 开始，i 与 pi(1≤pi≤i-1) 相连。
定义 a(x) 表示以 x 为根时的合法标记方案数，模 1e9+7。其中【合法标记】定义为：对树的某些边做标记，使得 x 到任意点的简单路径上，至多有一条边是被标记的。
输出 a(1),a(2),...,a(n)。	输入
3
1 1
输出
4 3 3

输入
5
1 2 3 4
输出
5 8 9 8 5	2300	换根 DP。不了解的同学请看右边的链接。

先来计算 a(1)，此时 1 为树根。
定义 f(i) 表示子树 i 的合法标记方案数。
对于 i 的儿子 j，考虑 i-j 这条边是否标记：
- 标记：那么子树 j 的所有边都不能标记，方案数为 1。
- 不标记：那么方案数就是 f(j)。
i 的每个儿子互相独立，所以根据乘法原理有 
f(i) = (f(j1)+1) * (f(j2)+1) * ... * (f(jm)+1)
其中 j1,j2,...,jm 是 i 的儿子。

然后来计算其余 a(i)。
考虑把根从 i 换到 j：
对于 j 来说，方案数需要在 f(j) 的基础上，再乘上【父亲 i】这棵子树的方案数，即 a(i) / (f(j)+1)。 
所以 a(j) = f(j) * (a(i)/(f(j)+1) + 1)

本题的一个易错点是，f(j)+1 可能等于 M=1e9+7，取模会变成 0，但是 0 没有逆元。
处理方式有很多，我的做法是定义二元组 (k,x) 表示 M^k * x % M，在这基础上定义：
- 乘法运算：(k1, x1) * (k2, x2) = (k1+k2, x1*x2%M)
- 除法运算：(k1, x1) / (k2, x2) = (k1-k2, x1*inv(x2)%M)  这里 k1>=k2
- 加一运算：请读者思考（需要分类讨论，具体见代码）

当 k>0 时，(k,x) 的实际值为 0；当 k=0 时，(k,x) 的实际值为 x。

https://codeforces.com/contest/543/submission/214621886	【图解】一张图秒懂换根 DP！（Python/Java/C++/Go/JS）	
2023年7月20日	https://codeforces.com/problemset/problem/1613/D

输入 T(≤1e5) 表示 T 组数据。所有数据的 n 之和 ≤5e5。
每组数据输入 n(1≤n≤5e5) 和长为 n 的数组 a(0≤a[i]≤n)。

称序列 b 为 MEX 序列，如果对所有 i 都有 abs(b[i] - mex(b[0],...,b[i])) ≤ 1 成立，其中 mex(S) 表示不在 S 中的最小非负整数。
输出 a 的非空 MEX 子序列的个数，模 998244353。
两个子序列只要有元素下标不同，就算不同的子序列。例如 a=[0,0,0] 有 7 个不同的非空子序列。
注：子序列不要求连续。	输入
4
3
0 2 1
2
1 0
5
0 0 0 0 0
4
0 1 2 3
输出
4
2
31
7	1900	提示 1：MEX 序列的第一个数可以是哪些？第二个数呢？第三个数呢？

提示 2：把状态机画出来，照着写一个状态机 DP。

提示 3：
定义 f[i] 表示形如 00...011...122...2 ... ii...i 的非空子序列个数。
例如 f[3] 包含 0111233。
那么有 f[0] = f[0] * 2 + 1，表示要么不选这个 0，要么和前面的 0 拼起来，要么单独成一个 0。
同理有 f[i] = f[i] * 2 + f[i-1]。

定义 g2[i]，表示形如 00...011...122...2 ... (i-2)... i... (i-2)... i... (i-2)... i... 的非空子序列个数。
例如 g2[3] 包含 000113313113。
定义 l2[i]，表示形如 00...011...122...2 ... (i+2)... i... (i+2)... i... (i+2)... i... 的非空子序列个数。
例如 l2[1] 包含 000113313331。

那么有 
g2[i] = g2[i] * 2 + l2[i-2] + f[i-2]，
l2[i] = l2[i] * 2 + g2[i+2]。

最后还有一种情况，就是 11..1 这样的也算 MEX 序列。
定义 f1 表示它的个数，那么有
f1 = f1 * 2 + 1。

最后答案为 f1 + sum(f) + sum(g2) + sum(l2)。

https://codeforces.com/problemset/submission/1613/214488015	状态机 DP	
2023年7月19日	https://codeforces.com/problemset/problem/1765/D

输入 n(1≤n≤2e5) m(1≤m≤1e9) 和长为 n 的数组 a(1≤a[i]≤m)。
硬盘可用空间为 m。
有 n 个视频，下载第 i 个需要 a[i] 分钟，占用 a[i] 的硬盘空间。
同一时间只能下载一个视频，一旦视频开始下载，就会立刻占用 a[i] 的硬盘空间。
视频下完才能看。每个视频都恰好花 1 分钟看完，看完后可以立刻删除视频，释放空间。
你可以在看视频的同时下载另一个视频（如果硬盘空间足够的话）。
你需要下载并看完这 n 个视频。
问：到看完最后一个视频，最少要用多少分钟？	输入
5 6
1 2 3 4 5
输出 16

输入
5 5
1 2 3 4 5
输出 17

输入
4 3
1 3 2 3
输出 12	1700	请先做这题：
881. 救生艇

最多要花 n + sum(a) 分钟。在这基础上，考虑如何安排可以在看视频的同时下载。
受到救生艇这题的启发，排序+双指针，如果 a[l]+a[r]<=m，那么先下载 a[r]，看 a[r] 的同时下载 a[l]，那么看 a[l] 的同时，又可以下载另外一个视频（因为 a[l] 加上一个<=a[r] 的必然 <= m）。
所以只要 a[l]+a[r]<=m，那么就可以节省 2 分钟，除非 a[l] 是最后一个视频，那么最后一分钟只能看，此时只能节省 1 分钟。

https://codeforces.com/contest/1765/submission/214219665	贪心	
2023年7月18日	https://codeforces.com/problemset/problem/191/A

输入 n(1≤n≤5e5) 和长为 n 的字符串数组 a，只包含小写字母，每个 a[i] 的长度至多为 10。

你需要选择 a 的一个子序列 b，满足 b[i] 的最后一个字母等于 b[i+1] 的第一个字母，且 b[0] 的第一个字母等于 b[-1] 的最后一个字母。这里 b[-1] 表示最后一项。
输出 b 中字符串长度之和的最大值。

注：子序列不要求连续。	输入
3
abc
ca
cba
输出 6

输入
4
vvp
vvp
dam
vvp
输出 0

输入
3
ab
c
def
输出 1	1500	定义 f[i][j][k] 表示考虑 a 的前 i 个字符串，选出的子序列的第一个字母为 j，最后一个字母为 k。

转移方程的 i 从 1 开始。
设 v=a[i][0], w=a[i][-1]
f[i][j][w] = max(f[i][j][w], f[i-1][j][v] + len(a[i]))，表示 max(不选 a[i]，选 a[i])。
f[i][v][w] = max(f[i][v][w], len(a[i]))，表示把 a[i] 当作子序列的第一个字符串。

初始值 f[0][j][k] = -inf。
答案为 f[n][0][0],f[n][1][1],...,f[n][25][25] 的最大值。
代码实现时，第一个维度可以优化掉。

https://codeforces.com/problemset/submission/191/214043184	线性 DP	
2023年7月17日	https://codeforces.com/problemset/problem/1195/C

输入 n(1≤n≤1e5) 和一个 2 行 n 列的矩阵 a(1≤a[i][j]≤1e9)。
你需要从矩阵中选择一些数，要求任意两数不能左右相邻，也不能上下相邻。
输出所选数字之和的最大值。

思考：如果改成 m 列要怎么做？ https://ac.nowcoder.com/acm/contest/59157/O	输入
5
9 3 5 7 3
5 8 1 4 5
输出 29

输入
3
1 2 9
10 1 1
输出 19

输入
1
7
4
输出 7	1400	本题和打家劫舍是类似的。
198. 打家劫舍

定义 f[i][0/1/2] 表示考虑前 i 列，其中第 i 列不选/只选第一行/只选第二行的情况下的最大元素和。

转移方程的下标从 1 开始：
f[i][0] = max(f[i-1])
f[i][1] = max(f[i-1][0], f[i-1][2]) + a[0][i]
f[i][2] = max(f[i-1][0], f[i-1][1]) + a[1][i]

初始值 f[0][0/1/2] = 0。
答案为 max(f[n])。
代码实现时，第一个维度可以优化掉。

https://codeforces.com/problemset/submission/1195/214035921	状态机 DP	
2023年7月14日	https://codeforces.com/problemset/problem/1238/E

输入 n(1≤n≤1e5) m(1≤m≤20) 和长为 n 的字符串 s，由前 m 个小写字母组成。
你需要构造一个长为 m 的小写字母排列，例如 m=3 时的 bac，把这个排列当成一个只有一排的键盘。
在只用一根手指的情况下，用这个键盘打出 s。
问：构造一个怎样的键盘，可以使手指的移动距离之和最小？输出这个最小值。	输入
6 3
aacabc
输出 5
解释：使用键盘 bac。

输入
6 4
aaaaaa
输出 0

输入
15 4
abacabadabacaba
输出 16	2200	1879. 两个数组最小的异或值之和
不了解排列型状压的，推荐先做这题。

统计字符串中相邻字母对的个数，记作 cnt。

用状态 s 表示前面填了 |s| 个字母的键盘，这里 |s| 表示 s 中二进制 1 的个数
假设当前填字母 c，那么 c 的位置 pos[c]=|s|。
对于前面已经填的字母 x，贡献为 cnt[c][x] * (pos[c] - pos[x])，
对于后面没有填的字母 y，贡献为 cnt[c][y] * (pos[y] - pos[c])。

把 cnt[c][x] * pos[c] 单独分离出来，这样每个字母怎么填，就不需要知道前后字母的【具体位置】了。
总贡献 cost(c) = sum(cnt[c][x] * pos[c] for x in s) - sum(cnt[c][y] * pos[c] for y not in s)

定义 f[s] 表示状态 s 的 cost 之和的最小值，有
f[s|c] = min(f[s] + cost(c) for c not in s)
初始值 f[0] = 0，答案为 f[-1]。

https://codeforces.com/problemset/submission/1238/213707044

优化：比上面快 3~4 倍（只需要计算 sum(cnt[c][x])，sum(cnt[c][y]) 可以由 sum(cnt[c]) - sum(cnt[c][x]) 得到，而 sum(cnt[c]) 可以提前预处理出来。）
https://codeforces.com/contest/1238/submission/213707877

也可以进一步预处理 sum(cnt[c][x])，但是还没上面跑的快。
https://codeforces.com/contest/1238/submission/213708185	状压 DP	
2023年7月13日	https://codeforces.com/problemset/problem/981/D

输入 n k(1≤k≤n≤50) 和长为 n 的数组 a(0<a[i]<2^50)。
把 a 划分成恰好 k 个非空连续子数组。
把第 i 个子数组记作 b[i]。
最大化 sum(b[0]) AND sum(b[1]) AND ... AND sum(b[k-1])。
这里 AND 表示按位与。	输入
10 4
9 14 28 1 7 13 15 29 2 31
输出 24

输入
7 3
3 14 15 92 65 35 89
输出 64	1900	涉及到二进制的题目，其中一种思路是拆位。

设最高位为 m。
第 m 位能不能是 1？如果能，那么答案至少是 1<<m。
怎么判断？标准的划分型 DP，定义 f[i][r] 表示 a[0] 到 a[r-1] 能否分成 i 段，且每一段的第 m 位都是 1。

设 target = 1<<m，有
f[i][r] |= f[i-1][l] && ((sum[r] - sum[l]) & target) == target
其中 sum[0] = 0, sum[i] = a[0] + ... + a[i-1]

初始值 f[0][0] = true，如果最后 f[k][n] = true 则说明第 m 位可以是 1。

然后继续判断，第 m-1 位能不能是 1？第 m-2 位能不能是 1？……
注意如果第 m 位是 1，那么在判断其余位的时候，要带着第 m 位是 1 一块判断。

https://codeforces.com/contest/981/submission/213277313	DP 位运算	
2023年7月12日	https://codeforces.com/contest/1516/problem/C

输入 n(2≤n≤100) 和长为 n 的数组 a(1≤a[i]≤2000)。
你需要删除 a 中的一些数，使 a 无法分成两个元素和相等的子序列。
输出最少要删除多少个数，以及这些数的下标（从 1 开始）。
注：子序列不要求连续。	输入
4
6 3 9 12
输出
1
2
解释 6+9=3+12，删除 3。

输入
2
1 2
输出
0	1700	分类讨论：

1. 如果 sum(a) 是奇数，显然没法分，无需删除任何数字，输出 0。
2. 如果无法从 a 中选出元素和等于 sum(a)/2 的子序列，那么也没法分，输出 0。这可以用 0-1 背包判断。
3. 否则就可以分，那么要如何删除呢？此时 sum(a) 是偶数，由于偶数 - 奇数 = 奇数，所以减去一个奇数即可。
4. 要是没有奇数呢？此时每个 a[i] 都是偶数，那么把每个 a[i] 都除以 2，是不会影响答案的。反复除以 2 直到 a 中有奇数为止。

代码实现时，无需反复除以 2，而是除以最小的 lowbit(a[i])。如果要删除数字，也是删除 lowbit 最小的数。

https://codeforces.com/contest/1516/submission/213269180	DP 0-1 背包 分类讨论	
2023年7月11日	https://codeforces.com/contest/991/problem/D

输入一个 2 行 n(≤100) 列的棋盘。
用数字 0 表示空格子，大写字母 X 表示一开始就被占据的格子。

你有无数个 L 形状的积木，可以旋转，也就是如下 4 种形状：
XX   XX   0X   X0
X0   0X   XX   XX

积木只能放在空格子上（占据 3 个空格子），不能放在被占据的格子上。积木之间不能重叠。
问：最多可以往棋盘上放多少个积木？	输入
00
00
输出 1

输入
00X00X0XXX0
0XXX0X00X00
输出 4

输入
0X0X0
0X0X0
输出 0

输入 
0XXX0
00000
输出 2	1500	定义 f[i][0/1/2/3] 表示考虑前 i 列格子最多能放多少积木，其中第 i 列【未被占据/第一行被占据/第二行被占据/两行都被占据】。
如果不放积木，那么 f[i][x] = max(f[i-1])，这里 x 是题目输入的第 i 列的格子状态。
如果放积木，那么枚举积木的 4 种旋转状态，具体见代码（有详细注释哦）
代码实现时，可以用滚动数组优化空间。

https://codeforces.com/contest/991/submission/213197678	DP	
2023年7月10日	https://codeforces.com/problemset/problem/698/A

输入 n(1≤n≤100) 和长为 n 的数组 a(0≤a[i]≤3)。
有 n 天，第 i 天的情况用 a[i]=0/1/2/3 表示，具体如下：

0：健身房关闭，比赛不进行； 
1：健身房关闭，比赛进行；
2：健身房开放，比赛不进行；
3：健身房开放，比赛进行。

在每一天，你可以休息、比赛 (如果比赛在这一天进行)，或者做运动 (如果健身房在这一天是开放的)。
但你不想连续两天做同样的活动，这意味着，你不会连续两天做运动，也不会连续两天参加比赛。
输出你休息的最少天数。	输入
4
1 3 2 0
输出 2

输入
7
1 3 3 2 1 2 3
输出 0

输入
2
2 2
输出 1	1400	状态机 DP。
定义 f[i+1][0/1/2] 表示前 i 天最少休息天数，其中第 i 天 休息/比赛/健身。
初始值 f[0][j] = 0。
转移：
f[i+1][0] = min(f[i]) + 1
如果 a[i]=1或3，f[i+1][1] = min(f[i][0], f[i][2]) 否则 f[i+1][1] = inf
如果 a[i]=2或3，f[i+1][2] = min(f[i][0], f[i][1]) 否则 f[i+1][2] = inf
答案为 min(f[n])。
代码实现时可以滚动。

https://codeforces.com/problemset/submission/698/213038992	DP	
2023年7月7日	https://codeforces.com/problemset/problem/282/E

输入 n(1≤n≤1e5) 和长为 n 的数组 a(0≤a[i]≤1e12)。
选择 a 的一个前缀（可以为空）和一个后缀（可以为空），要求前缀后缀不相交。
输出所选数字的异或和的最大值。	输入 
2
1 2
输出 3

输入
3
1 2 3
输出 3

输入 
2
1000 1000
输出 1000	2200	前后缀分解。

先从前到后扫一遍，把每个前缀异或和的值存到 0-1 trie 中。
然后从后往前扫一遍，对每个后缀异或和，计算它与前面的所有前缀异或和的异或的最大值。
由于题目要求前后缀不能相交，所以遍历后缀的时候，还需要删除到下标 i 的前缀异或和。
考虑到重叠的部分的异或和 = 0，对答案没有影响，所以不删除也是可以的。

不了解  0-1 trie 的话可以看看 421. 数组中两个数的最大异或值

https://codeforces.com/problemset/submission/282/212487514		
2023年7月6日	https://codeforces.com/problemset/problem/730/J

输入 n(1≤n≤100) 和两个长为 n 的数组 a b (1≤a[i]≤b[i]≤100)。

有 n 个水桶，第 i 个水桶装了 a[i] 单位的水，水桶容量为 b[i]。
花费 1 秒，可以从某个水桶中，转移 1 个单位的水，到另一个水桶。

输出两个数：
把水汇集起来，最少需要多少个桶（换句话说需要倒空尽量多的桶），该情况下至少要多少秒完成？	输入
4
3 3 4 3
4 7 6 5
输出 2 6

输入
2
1 1
100 100
输出 1 1

输入
5
10 30 5 6 24
10 41 7 8 24
输出 3 11	1900	最少需要多少个桶？这可以贪心地按照 b[i] 从大到小选择，直到选择的 b[i] 之和 >= sum(a) 为止。
假设最少需要 m 个桶。

在 m 个桶的前提下，至少要多少秒完成？
正难则反，考虑最多有多少单位的水是不需要转移的。

把 b[i] 看成物品体积，a[i] 看成物品价值，变成 0-1 背包问题：
定义 f[i][j][k] 表示从前 i 个桶中恰好选 j 个桶，这 j 个桶的容量之和恰好为 k 的情况下，最多有 f[i][j][k] 单位的水是不需要转移的。
状态转移方程为：f[i][j][k] = max(f[i-1][j][k], f[i-1][j-1][k-b[i]]+a[i])。
初始值：f[0][0][0] = 0，其余为负无穷大。
答案为：sum(a)-max(f[n][m][sum(a):])。
（注意这里我是用【恰好】定义的，k 需要从 sum(a) 枚举到 sum(b)。用【至少】定义 k 也是可以的。）

代码实现时，f 的第一个维度可以省略。

https://codeforces.com/contest/730/submission/212163529

优化版本：https://codeforces.com/contest/730/submission/212164117	@hqztrue🐸: O~(n^1.5*u)的做法，其中n是桶数，u是桶大小
https://codeforces.com/contest/730/submission/212319261	
2023年7月5日	https://codeforces.com/problemset/problem/1157/C2

输入 n(1≤n≤2e5) 和长为 n 的双端队列 a(1≤a[i]≤2e5)。
每次操作，弹出 a 的队首或队尾。
从第二次操作开始，弹出的数字必须严格大于上一次弹出的数字。
输出最多可以弹出多少个数字，以及操作序列（队首为 L，队尾为 R）。	输入
5
1 2 4 3 2
输出 
4
LRRR

输入
7
1 3 5 6 5 4 2
输出
6
LRLRRR

输入
3
2 2 2
输出
1
R

输入
4
1 2 4 3
输出
4
LLRR	1700	https://codeforces.com/problemset/submission/1157/212155329

贪心模拟即可。

哪边小选哪边（但必须大于上一个数）。
如果两边一样，那么后续操作要么都选左，要么都选右，暴力比较选哪边更优（有更长的严格递增）。
注意【一样】的情况，在整个模拟过程中，至多发生一次（因为必须严格递增）。		
2023年7月4日	https://codeforces.com/problemset/problem/1051/C

输入 n(2≤n≤100) 和长为 n 的数组 s(1≤s[i]≤100)。
把 s 分成两个子序列 A 和 B（子序列可以为空），使得 A 里面只出现一次的数的个数，等于 B 里面只出现一次的数的个数。
如果无法做到，输出 NO。
否则输出 YES 以及方案（见样例）。
注意 s 中可能有重复元素。

思考题：如果子序列不能为空呢？
思考题：如果分成 k 个子序列要怎么做？	输入
4
3 5 7 1
输出
YES
BABA

输入
3
3 5 1
输出
NO	1500	https://codeforces.com/contest/1051/submission/211938643

设 s 中有 c1 个数出现一次。
如果 c1 是偶数，那么选 c1/2 个数分到 B，其余分到 A。
如果 c1 是奇数，由于出现两次的数分开对答案没有影响，所以要考虑选一个出现次数 >= 3 次的数分到 B，然后再选 floor(c1/2) 个数分到 B，其余分到 A。
如果没有出现次数 >= 3 次的数，则无解。		
2023年7月3日	https://codeforces.com/problemset/problem/1215/B

输入 n(1≤n≤2e5) 和长为 n 的数组 a(-1e9≤a[i]≤1e9,a[i]≠0)。
输出两个数：
1. 有多少个非空连续子数组，乘积是负数？
2. 有多少个非空连续子数组，乘积是正数？

思考题：如果数组中有 0 要怎么做？如果要数乘积为 0 的子数组个数呢？
思考题：如果改成子序列呢？	输入
5
5 -3 3 -1 1
输出 8 7

输入
10
4 2 -4 3 1 2 -4 3 2 3
输出 28 27

输入
5
-1 -2 -3 -4 -5
输出 9 6	1400	https://codeforces.com/problemset/submission/1215/211779994

用前缀和统计前 i 个数中有多少个负数。
由于偶数个负数的乘积是正数，所以只需要看前缀和的奇偶性。

一边计算前缀和 s[i]，一边计算答案：
负数个数 = 与 s[i] 奇偶性不同的前缀和的个数。
正数个数 = 与 s[i] 奇偶性相同的前缀和的个数。		
2023年6月30日	https://codeforces.com/contest/626/problem/F

输入 n(1≤n≤200) k(0≤k≤1000) 和长为 n 的数组 a(1≤a[i]≤500)。

有 n 个人，第 i 个人的能力值为 a[i]。
把这 n 个人分成若干组，一个组的不平衡度定义为组内最大值减最小值。
特别地，如果组内只有一个人，那么不平衡度为 0。
要求所有组的不平衡度之和不超过 k。
有多少种分组方案？模 1e9+7。

注：一个组是 a 的子序列，不要求连续。	输入
3 2
2 4 5
输出 3

输入
4 3
7 8 9 10
输出 13

输入
4 0
5 10 20 21
输出 1	2400	先排序。

提示 1：把作为最小值的数看成左括号，作为最大值的数看成右括号。由于作为最小值的个数不能低于作为最大值的个数，所以这和括号问题是相似的，可以用解决括号问题的技巧来思考。

提示 2：如何优雅地计算不平衡度呢？假设从小到大有 a b c d 四个数，选了 a c d，那么 d-a = (d-c) + (c-b) + (b-a)。注意这里算上了没有选的 b。
这意味着我们只需要考虑相邻两个数对不平衡度的影响。

提示 3：记忆化搜索，我的实现是从 n-1 开始，递归到 -1。先选最大值，再选最小值。
定义 dfs(i, groups, leftK) 表示前 i 个数中，有最大值但是尚未确定最小值的组有 groups 个，剩余不平衡度为 leftK。
需要考虑四种情况：
1. a[i] 作为一个新的组的最大值（创建一个新的组）。
2. a[i] 作为某个组的最小值（有 groups 种选择方案）。
3. a[i] 单独形成一个组（这个组只有一个数）。
4. a[i] 添加到某个组中（有 groups 种选择方案）。
具体见代码 https://codeforces.com/contest/626/submission/211471819

注：这题用到的思路和我在【1681. 最小不兼容性】这题评论区发的代码是类似的
https://leetcode.cn/problems/minimum-incompatibility/discussion/comments/2051770		
2023年6月29日	https://codeforces.com/problemset/problem/1647/D

输入 T(≤100) 表示 T 组数据。
每组数据输入 x d (2≤x,d≤1e9)，保证 x 是 d 的倍数。

定义好数为 d 的倍数。
定义美丽数为好数且不能表示为两个好数的乘积。

x 能否表示为一个或多个美丽数的乘积，且表示方式不唯一？
输出 YES / NO。

注：2*4 和 4*2 是同一种表示方式。	输入
8
6 2
12 2
36 2
8 2
1000 10
2376 6
128 4
16384 4
输出
NO
NO
YES
NO
YES
YES
NO
YES	1900	https://codeforces.com/problemset/submission/1647/211381733

详细见代码注释

【补充】
比如 x = 2*6*6*6，d=6，那么把 x 视作 (2 * 1 * 1) * 6 * 6 * 6，即三个美丽数 2*6, 6, 6 的乘积。
拿一个 6 出来分解，变成 (2*2 * 1*3) * 6 * 6，这样得到了两个美丽数 2*2*6 以及 3*6 的乘积。		
2023年6月28日	https://codeforces.com/problemset/problem/1626/C

输入 T(≤1e4) 表示 T 组数据。所有数据的 n 之和 ≤1e4。
每组数据输入 n(1≤n≤100) 和长为 n 的严格递增数组 k，长为 n 的数组 h (1≤h[i]≤k[i]≤1e9)。

你在玩一个打怪游戏。有 n 只怪物，第 i 只会在第 k[i] 秒出现，血量为 h[i]。
你有一个引导类法术，你引导的时间越长，伤害越高，消耗的魔法值也越高。
具体来说，开始引导的第 1 秒，伤害为 1，消耗 1；第 2 秒，伤害为 2，消耗 2；第 i 秒，伤害为 i，消耗 i。
例如，伤害达到 3，要消耗 1+2+3=6 的魔法值。
你可以随时停止引导（停止后伤害为 0），或者重新引导（从 1 开始）。

游戏从第 1 秒开始。在第 k[i] 秒，法术伤害至少要是 h[i]。
要击败所有怪物，消耗的魔法值之和至少是多少？	输入
3
1
6
4
2
4 5
2 2
3
5 7 9
2 1 2
输出
10
6
7	1700	把每个怪物需要的法术时间范围算出来，即 [k[i]-h[i]+1, k[i]]
那么问题和 56. 合并区间 是一样的，对于互相重叠的区间，法术必须一直持续。不重叠的区间就没必要持续了。
倒序合并区间可以做到 O(n)。

正序 O(nlogn)
倒序 O(n)		
2023年6月27日	https://codeforces.com/problemset/problem/1081/C

输入 n m(1≤n,m≤2000) k(0≤k≤n-1)。
n 块砖排成一排，把每块砖涂成 m 种颜色中的一种，要求恰好有 k 块砖的颜色与其左边相邻砖的颜色不同（第一块砖不能在这 k 块砖内）。
输出涂色方案数，模 998244353。	输入 3 3 0
输出 3

输入 3 2 1
输出 4	1500	https://codeforces.com/problemset/submission/1081/211192029

定义 f[i][j] 表示前 i 块砖，有 j 块砖的颜色与其左边相邻砖的颜色不同，此时的涂色方案数。
第一块砖随便涂色，f[0][0] = m。
考虑第 i 块砖「选或不选」，也就是：
颜色相同：f[i][j] = f[i-1][j]
颜色不同：f[i][j] = f[i-1][j-1] * (m-1)
相加得 f[i][j] = f[i-1][j] + f[i-1][j-1] * (m-1)
答案为 f[n-1][k]。
代码实现时可以用滚动数组优化。

另一种思路是从 n-1 块砖中选 k 块砖，颜色和左边不一样，
所以方案数是 C(n-1,k) * m * (m-1)^k，预处理阶乘可以做到 O(n)。		
2023年6月26日	https://codeforces.com/problemset/problem/987/C

输入 n(3≤n≤3000) 和长度均为 n 的数组 a(1≤a[i]≤1e9) 和数组 b(1≤b[i]≤1e8)。
输出在满足 i<j<k 且 a[i]<a[j]<a[k] 的前提下，b[i]+b[j]+b[k] 的最小值。
如果不存在这样的 (i,j,k)，输出 -1。

进阶：O(nlogn)。
进阶：改成 a 的长为 4 的递增子序列（本题长为 3）。改成 5？改成 m？	输入
5
2 4 5 4 10
40 30 20 10 40
输出 90

输入
3
100 101 100
2 4 5
输出 -1

输入
10
1 2 3 4 5 6 7 8 9 10
10 13 11 14 15 12 13 13 18 13
输出 33	1400	https://codeforces.com/contest/987/submission/211026113

最简单的做法：枚举 j，然后枚举左边的满足 a[i]<a[j] 的最小的 b[i]，枚举右边的满足 a[k]>a[j] 的最小的 b[k]，用 b[i]+b[j]+b[k] 更新答案的最小值。

其它做法：定义 dp[i][j=0/1/2] 表示 a 的前 i 个数中，长为 j+1 的递增子序列的 b 之和的最小值。
在左边找比 a[i] 小的 a[p]，从 dp[p][j-1] 转移过来。
对 a 离散化，可以用线段树优化至 O(nlogn)。

相关题目： 2407. 最长递增子序列 II		
2023年6月23日	https://codeforces.com/contest/1729/problem/G

输入 T(≤50) 表示 T 组数据。所有数据的 s 长度之和 ≤500，t 长度之和 ≤500。
每组数据输入两个长度均不超过 500 的字符串 s 和 t，只包含小写字母。
每次操作，从 s 中找到一个等于 t 的子串，然后用点号替换这个子串。
要使 s 中不包含 t，至少要操作多少次？
输出最小操作次数 x。输出操作 x 次使得 s 不包含 t 的方案数，模 1e9+7。
注：子串是连续的。	输入
8
abababacababa
aba
ddddddd
dddd
xyzxyz
xyz
abc
abcd
abacaba
abaca
abc
def
aaaaaaaa
a
aaaaaaaa
aa
输出
2 2
1 4
2 1
0 1
1 1
0 1
8 1
3 6	2100	https://codeforces.com/contest/1729/submission/209145544 记忆化搜索（推荐先看这个）

https://codeforces.com/contest/1729/submission/209145793 递推

先计算最小操作次数，这可以贪心。
找出所有 t 在 s 中的位置，然后贪心替换：如果第一个 t 与第二个 t 没有重叠，那么必须替换第一个 t；否则替换第二个 t ，也能让第一个 t 不在 s 中。具体来说，需要在第一个 t 的【范围】内替换一个最右的 t（这个最右的 t，只要第一个字母的下标在【范围】内即可）。替换后，按同样的方式替换后续的 t。

然后就可以写一个二维 DP 了，dfs(i,j) 表示当前要处理后缀 s[i:]，且已经替换了 j 次。枚举下一个要替换的 t。
你也可以把 t 在 s 中的所有位置都处理出来，设为数组 a，然后在 a 上 DP。具体见代码。		
2023年6月22日	https://codeforces.com/problemset/problem/452/D

输入 k (1≤k≤1e4) n1 n2 n3 t1 t2 t3 (1≤n1,n2,n3,t1,t2,t3≤1000)。
有 k 件衣服，每件都需要按照洗净 -> 烘干 -> 熨烫的顺序处理。
现在有 n1 个洗衣机，n2 个烘干机和 n3 个熨斗。
每个机器同时只能处理一件衣服，分别花费 t1, t2, t3 时间。
你必须将一件洗好的衣服立即烘干，烘干完毕后立即熨烫。
输出处理完所有衣服的最短时间。	输入 1 1 1 1 5 5 5
输出 15

输入 8 4 3 2 10 5 2
输出 32	1900	https://codeforces.com/problemset/submission/452/210604954

题解（欢迎点赞）		
2023年6月21日	https://codeforces.com/problemset/problem/176/B

输入两个长度相等的字符串 s 和 t，长度在 [2,1000] 内，只包含小写字母。
然后输入 k(0≤k≤1e5) 表示操作次数。

你需要恰好执行 k 次操作。
每次操作你可以把 s 分割成两个非空字符串 s1 和 s2，然后替换 s = s2 + s1。
把 s 变成 t 有多少种方案？模 1e9+7。	输入
ab
ab
2
输出 1

输入
ababab
ababab
1
输出 2

输入
ab
ba
2
输出 0	1700	https://codeforces.com/contest/176/submission/210387377

手玩一下发现操作与「把 s 循环右移（左移）」是一样的。
假设有 c 种不同的循环右移可以让 s=t。那么有 n-c 种不同的循环右移让 s≠t。
定义 f[i] 表示操作 i 次后 s=t，g[i] 表示表示操作 i 次后 s≠t。
那么
f[i] = f[i-1] * (c-1) + g[i-1] * c
g[i] = f[i-1] * (n-c) + g[i-1] * (n-c-1)
初始值 f[0]=(s==t), g[0]=f[0]^1		
2023年6月20日	https://codeforces.com/problemset/problem/354/A

输入 n(1≤n≤1e5) l r(1≤l,r≤100) ql qr(1≤l,r≤1e4) 和长为 n 的双端队列 q(1≤q[i]≤100)。
每次操作弹出 q 的队首或者队尾，代价分别为 l*a[i] 和 r*a[i]。
如果上一次和当前都是弹出队首，则代价额外加上 ql。
如果上一次和当前都是弹出队尾，则代价额外加上 qr。
输出清空 q 的最小代价。	输入
3 4 4 19 1
42 3 99
输出 576

输入
4 7 2 3 9
1 2 3 4
输出 34	1500	https://codeforces.com/contest/354/submission/210296537

前后缀分解。

枚举弹出队首 i 次，那么弹出队尾 n-i 次。
如果 i 比较小，那么操作应该是首尾首尾 ... 尾尾尾尾。
如果 i 比较大，那么操作应该是尾首尾首 ... 首首首首。		
2023年6月19日	https://codeforces.com/problemset/problem/602/B

输入 n(2≤n≤1e5) 和长为 n 的数组 a(1≤a[i]≤1e5 且 abs(a[i]-a[i-1])≤1)。
输出 a 的最长连续子数组的长度，满足数组中的最大值减最小值不超过 1。

相似题目：
1438. 绝对差不超过限制的最长连续子数组	输入
5
1 2 3 3 2
输出 4

输入
11
5 4 5 5 6 7 8 8 8 7 6
输出 5	1400	https://codeforces.com/problemset/submission/602/209863696

双指针滑窗，视频讲解：https://www.bilibili.com/video/BV1hd4y1r7Gq/

由于 abs(a[i]-a[i-1])≤1，问题等价于子数组内不同元素个数不超过 2，用 map 维护即可。		
2023年6月16日	从集合论到位运算，常见位运算技巧分类总结！

阅读这篇文章，尝试做做文末的练习题（有题解）					
2023年6月15日	https://codeforces.com/problemset/problem/292/D

输入 n(2≤n≤500) m(1≤m≤1e4) 和一个无向图的 m 条边，节点编号从 1 到 n，无自环，可能有重边。
然后输入 k(1≤k≤2e4) 个询问，每个询问输入 left 和 right，表示删除第 left 到第 right 条边（边按照输入编号，从 1 到 m）。
对每个询问，输出删除边后，此时有多少个连通块。
请注意：每个询问都是独立的，在下个询问前会恢复成原图。	输入
6 5
1 2
5 4
2 3
3 1
3 6
6
1 3
2 5
1 5
5 5
2 4
3 3
输出
4
5
6
3
4
2	1900	https://codeforces.com/contest/292/submission/173783235

前后缀分解。

预处理，对 m 条边的每个前缀和每个后缀建立大小为 n 的并查集，递推计算。每次递推在上一个并查集的基础上计算，预处理总时间 O(nm)。（每次递推都要 copy 一次并查集）
对每个询问，把对应的前缀与后缀的并查集合并（对每个 i，把前缀的 fa[i] 与后缀的 fa[i] 合并），这样每个询问只需要 O(n) 的时间。（暴力是 O(m)）		
2023年6月14日	https://codeforces.com/problemset/problem/1700/C

输入 T(≤2e4) 表示 T 组数据。所有数据的 n 之和 ≤2e5。
每组数据输入 n(1≤n≤2e5) 和长为 n 的数组 a(-1e9≤a[i]≤1e9)。

每次操作，你可以执行如下三种中的一种：
1. 把一个前缀的 a[i]-=1
2. 把一个后缀的 a[i]-=1
3. 把所有 a[i]+=1

把所有 a[i] 都变成 0，至少要操作多少次？	输入
4
3
-2 -2 -2
3
10 4 7
4
4 -4 4 -4
5
1 -2 3 -4 5
输出
2
13
36
33	1700	https://codeforces.com/problemset/submission/1700/209616776

用差分思考，计算 a 的差分数组 d。注意 d 和 a 是一一映射，a 全为 0 当且仅当 d 全为 0。

操作 1 变成给 d[0]-=1，d[i+1]+=1。特别地，如果 i=n-1 则仅给 d[0]-=1。
操作 2 变成给 d[i]-=1。
操作 3 变成给 d[0]+=1。

根据这些操作，把所有 d[i] 变成 0。

相似题目：见 2023.2.8 的茶		
2023年6月13日	https://codeforces.com/problemset/problem/460/B

输入 a(1≤a≤5) b(1≤b≤10000) c(-10000≤c≤10000)。
解方程：
x = b * pow(s(x),a) + c 且 0 < x < 1e9
其中 s(x) 是 x 的数位和。
第一行输出 x 的个数。
第二行按升序输出所有 x。	输入
3 2 8
输出
3
10 2008 13726

输入
1 2 -18
输出
0

输入
2 2 -1
输出
4
1 31 337 967	1500	https://codeforces.com/contest/460/submission/208147283

枚举 s(x)。

由于 0<x<1e9，所以 1<=s(x)<=81。
代入等式右边，算出 x，再验证 s(x) 是否等于所枚举的 s(x)。		
2023年6月12日	https://codeforces.com/problemset/problem/435/B

输入 a(1≤a≤1e18) 和 k(0≤k≤100)。
你需要操作至多 k 次。
每次操作，交换 a 的两个相邻数位。
输出 a 的最大值。	输入 1990 1
输出 9190

输入 300 0
输出 300

输入 1034 2
输出 3104

输入 9090000078001234 6
输出 9907000008001234	1400	https://codeforces.com/contest/435/submission/209289302

由于 k 较小，直接模拟。
每次循环尽量把大的换到前面。
具体来说，第 i 次循环，贪心找从第 i 个位置往后 min(k+1,n) 个数位的最大值，然后不断交换到第 i 个位置上。
直接模拟邻项交换，每次交换把 k 减一。这样写是最稳的。		
2023年6月9日	https://codeforces.com/problemset/problem/570/E

输入 n m (1≤n,m≤500) 和 n 行 m 列的字符矩阵，只包含小写字母。
你需要从左上角的 (1,1) 出发，到达右下角的 (n,m)。
每次只能向下或向右走。
问：有多少条路径对应的字符串是回文串？（见右图）
模 1e9+7。	输入
3 4
aaab
baaa
abba
输出 3
解释 见右图	2300	https://codeforces.com/problemset/submission/570/209046565
https://codeforces.com/problemset/submission/570/209046793  循环优化

做法类似 741. 摘樱桃

转换成两个人同时从左上和右下出发，定义 f[i][r1][r2] 表示走了 i 步，两人分别在第 r1 行和第 r2 行的方案数。这样只需要三个数就能表示坐标 (r1,c1) 和 (r2,c2)。
f[0][1][n] = 1（如果 a[1][1] != a[n][m] 直接输出 0）
如果 a[r1][c1] = a[r2][c2]，那么 f[i][r1][r2] = f[i-1][r1][r2] + f[i-1][r1][r2+1] + f[i-1][r1-1][r2] + f[i-1][r1-1][r2+1]，否则就是 0
代码实现时，第一个维度可以去掉。

最后答案按照字符串长度的奇偶性讨论。
如果是奇回文串，那么答案为 sum(f[i][i])，否则答案为 sum(f[i][i]+f[i][i+1])。		
2023年6月8日	https://codeforces.com/contest/480/problem/C

输入整数 n a b k (2≤n≤5000, 1≤k≤5000, 1≤a,b≤n, a≠b)。
你需要从数轴上的 a 出发，移动恰好 k 次。
从整数 x 移动到整数 y，必须满足以下所有要求：
1. 1≤y≤n
2. y≠x
3. y≠b
4. |x-y|<|x-b|
输出不同移动方案的个数，模 1e9+7。	输入 5 2 4 1
输出 2

输入 5 2 4 2
输出 2

输入 5 3 4 1
输出 0	1900	https://codeforces.com/contest/479/submission/208670481

前缀和优化 DP。

为方便计算，如果 a>b，根据对称性调整为 a=n+1-a，b=n+1-b。这样可以保证 a<b。

定义 f[i][j] 表示 i 次移动后，移动到 j 的方案数。f[0][a] = 1。1≤j<b。
考虑从位置 x 转移过来：
如果 x<j，可以移动到 j。
如果 x>j，根据要求 4，解不等式得 x≤j+floor((b-y-1)/2)。
所以 f[i][j] = f[i-1][1] + ... + f[i-1][j+floor((b-y-1)/2)] - f[i-1][j]。
最后的减法是因为要求 2。
答案为 sum(f[k][j])。

用前缀和优化即可做到 O(kb) 的时间复杂度。

代码实现时，f 的第一个维度可以优化掉。

相似题目见右。	1977. 划分数字的方案数
2327. 知道秘密的人数
2463. 最小移动总距离
2478. 完美分割的方案数	
2023年6月7日	https://codeforces.com/problemset/problem/460/C

输入 n m w (1≤w≤n≤1e5) (1≤m≤1e5) 和长为 n 的数组 a(1≤a[i]≤1e9)。
你需要操作 m 次，每次操作可以选一个长为 w 的连续子数组，把数组内的元素都加一。
输出 min(a) 的最大值。	输入
6 2 3
2 2 2 2 1 1
输出 2

输入
2 5 1
5 8
输出 9	1700	https://codeforces.com/contest/460/submission/208655653

类似 2528. 最大化城市的最小供电站数目

二分答案 low。
用差分数组维护区间加。		
2023年6月6日	https://codeforces.com/contest/91/problem/A

输入长度不超过 1e4 的字符串 s1 和长度不超过 1e6 的字符串 s2，都只包含小写字母。
设字符串 t = s1 * x 表示由 s1 重复 x 次的字符串，比如 "abc" * 3 = "abcabcabc"。
输出使 s2 是 t 的子序列的 x 的最小值。如果无法做到输出 -1。
注：子序列不一定是连续的。	输入
abc
xyz
输出 -1

输入
abcd
dabc
输出 2	1500	https://codeforces.com/contest/91/submission/208158075

子序列自动机。
用 nxt[i][c] 表示 s1[i] 右侧最近字母 c 的下标，如果没有就从头再找。
nxt[i][c] 可以倒着遍历 s1 预处理出来（遍历两遍）。
然后就可以贪心匹配 s2 了，一旦发现下一个字母的位置 <= 当前位置，说明要多绕一圈，答案加一。

相似题目见右。	727. 最小窗口子序列 
792. 匹配子序列的单词数 
2014. 重复 K 次的最长子序列	
2023年6月5日	https://codeforces.com/contest/414/problem/B

输入 u n(1≤u,n≤2000)。
输出有多少个长为 n 的数组 a，满足：
1. 1≤a[1]≤a[2]≤...≤a[n]≤u。
2. a[i] 整除 a[i+1]（或者说 a[i] 是 a[i+1] 的因子）。
答案模 1e9+7。	输入 3 2
输出 5

输入 6 4
输出 39

输入 2 1
输出 2	1400	https://codeforces.com/contest/414/submission/208165638

枚举 a[1]，那么 a[2] 只能是 a[1] 的倍数，依此类推。
比如 1,3,6 或者 2,2,6。有多种方式可以到达同一个数字 6，说明可以用动态规划优化。

定义 f[i][j] 表示前 i 个数，末尾为 j 的方案数。
枚举因子效率有点差，不妨改为枚举倍数。
那么 f[i][k] += f[i-1][j]，这里 k 为 j 的倍数。
f[1][i] = 1。
答案为 sum(f[n][i])。

时间复杂度 O(nulogu)。		
2023年6月2日	https://codeforces.com/problemset/problem/1272/F

输入两个长度不超过 200 的字符串 s 和 t，只包含左右括号。
输出 s 和 t 的最短公共超序列，要求这个超序列是一个合法括号字符串。（多解输出任意解。）
关于最短公共超序列，见 1092. 最短公共超序列	输入
(())(()
()))()
输出 (())()()

输入
)
((
输出 (())

输入
)
)))
输出 ((()))

输入
())
(()(()(()(
输出 (()()()(()()))	2200	https://codeforces.com/problemset/submission/1272/208121980

请先看下面这篇题解

https://leetcode.cn/problems/shortest-common-supersequence/solutions/2194615/cong-di-gui-dao-di-tui-jiao-ni-yi-bu-bu-auy8z/

在计算最长公共超序列的基础上，增加一个参数 k 表示左括号比右括号多多少。		
2023年6月1日	https://codeforces.com/problemset/problem/190/D

输入 n k(1≤k≤n≤4e5) 和长为 n 的数组 a(1≤a[i]≤1e9)。
统计有多少个连续子数组 b，满足 b 中有至少 k 个数都相同。	输入
4 2
1 2 1 2
输出 3

输入
5 3
1 2 1 1 3
输出 2

输入
3 1
1 1 1
输出 6	1900	https://codeforces.com/problemset/submission/190/208012570

同向双指针。

固定右端点 right，移动左端点 left，让子数组 [left-1, right] 中至多有一个数出现 k 次。
如果已经出现了 k 个相同的数，那么 [left', right] 都是符合要求的，其中 left' < left。		
2023年5月31日	https://codeforces.com/contest/846/problem/C

输入 n(1≤n≤5000) 和长为 n 的数组 a(-1e9≤a[i]≤1e9)。
定义 s(i,i)=0, s(i,j)=a[i]+a[i+1]+...+a[j-1]。
计算 s(0,i)-s(i,j)+s(j,k)-s(k,n) 的最大值，其中 0≤i≤j≤k≤n。
你需要输出最大值对应的 i,j,k。
如果有多个满足要求的答案，输出任意一个。

进阶：你能想出一个 O(n) 的算法吗？	输入
3
-1 2 3
输出 0 1 3

输入
4
0 0 -1 0
输出 0 0 0

输入 
1
10000
输出 1 1 1	1800	https://codeforces.com/contest/846/submission/207819522

用前缀和将 s(0,i)-s(i,j)+s(j,k)-s(k,n) 变成
2*(s[i]-s[j]+s[k])-s[n]。
转换成求 s[i]-s[j]+s[k] 的最大值。
前后缀分解，计算 s 的前缀最大值和后缀最大值，然后枚举 s[j]。		
2023年5月30日	https://codeforces.com/contest/237/problem/C

输入 a b k，范围 [1,1e6]，a≤b。
请找到最短的 L，使得对于任意 a≤x≤b-L+1 都满足：在 x,x+1,...,x+L-1 中至少有 k 个质数。
输出 L。如果 L 不存在，输出 -1。	输入 2 4 2
输出 3

输入 6 13 1
输出 4

输入 1 4 3
输出 -1	1600	https://codeforces.com/contest/237/submission/207778331

预处理质数（埃氏筛/欧拉筛）。如果不足 k 个，输出 -1。

方法一：二分答案+滑窗验证（可以只在质数列表中滑窗）  O(b/logb * logb) = O(b)

方法二：既然可以只在质数列表中滑窗，那么干脆直接计算。
考虑 k+1 个连续质数对应的区间（减一），例如 5,7,11,13 & k=2，那么 [7,13-1] 就是一个包含 k 个质数的区间。向右滑动一格，变成 [7+1,13]，也仍然包含了 k 个质数。再短一点就不行了。最后再算上 a 和 b 的边界，你可以把 a-1 和 b+1 也视作质数。
答案就是 primes[i] - primes[i-k] 的最大值。		
2023年5月29日	https://codeforces.com/problemset/problem/1102/D

输入 n(3≤n≤3e5 且 n=3k) 和长为 n 的字符串 s，只包含 012。
你需要修改 s 中的字符，使得 012 的数量都等于 n/3。
修改次数应当尽量少。
输出修改后的字典序最小的字符串。	输入
3
121
输出 021

输入
6
000000
输出 001122

输入
6
211200
输出 211200

输入
6
120110
输出 120120	1500	https://codeforces.com/contest/1102/submission/207636737

为了最小化修改次数，只需要修改出现次数 > n/3 的。
从左往右，大的改成小的，例如 2->0
从右往左，小的改成大的，例如 1->2		
2023年5月26日	https://codeforces.com/problemset/problem/1693/C

输入 n(2≤n≤1e5) m(1≤m≤2e5) 表示一个 n 点 m 边的有向图（节点编号从 1 开始）。
然后输入 m 条边。没有自环，可能有重边。

你初始在 1，要到达 n。（输入保证可以从 1 到 n。）
每次操作，要么永久删除一条边，要么从当前点随机移动到一个邻居上。

最小化最大操作次数。	输入
2 1
1 2
输出 1

输入
4 4
1 2
1 4
2 4
1 4
输出 2

输入
5 7
1 2
2 3
3 5
1 4
4 3
4 5
3 1
输出 4	2300	https://codeforces.com/contest/1693/submission/207136188

根据题意，从某个点移动时，我们实际上是走的一条「最差」的边，使得花费最多的操作次数到达终点。
注意在描述这个性质时，是用「到终点的操作次数」来描述的，因此以终点为主体来思考。
设从 i 到 n 的最短路长度为 dis[i]。

性质 1：对于一个点 v，假设它有邻居 w1,w2,w3，且 dis[w1] <= dis[w2] <= dis[w3]，那么删边时，肯定是优先删除最大的 v-w3 这条边。
性质 2：如果删除的多，那么总的操作次数也多。如果删除的少，那么走最差的边，总的操作次数也多。
那么干脆枚举删除了多少条边。
难道每次枚举都要重新计算吗？

设原图为 g，反图为 rg。
设原图上的点 i 的出度为 deg[i]。
借鉴 Dijkstra，在 rg 上，从 n 出发去计算最短路。
在 rg 上从 w1 到达 v 时（首次访问 v），那就相当于在 g 上的 v 删除了 deg[i]-1 条边，然后走剩下的那条边到达 w1。
在 rg 上从 w2 到达 v 时（第二次访问 v），那就相当于在 g 上的 v 删除了 deg[i]-2 条边，然后走剩下的花费时间最多的那条边到达 w2。
为什么这里只需要删除 deg[i]-2 条边呢？因为按照 Dijkstra 算法，在 rg 上从 w2 到达 v，那么走的这条边在 g 上一定是从 v 出发的所有边中第二短的（最短的之前枚举过了），所以只需要删除 deg[i]-2 条边。		
2023年5月25日	https://codeforces.com/problemset/problem/711/D

输入 n(2≤n≤2e5) 和长为 n 的数组 a(1≤a[i]≤n,a[i]≠i)，表示一个 n 点 n 边的无向图（节点编号从 1 开始），点 i 和 a[i] 相连。

你需要给每条边定向（无向变有向），这一共有 2^n 种方案。
其中有多少种方案，可以使图中没有环？
模 1e9+7。	输入
3
2 3 1
输出 6

输入
4
2 1 1 1
输出 8

输入
5
2 4 2 5 3
输出 28	1900	https://codeforces.com/contest/711/submission/207047798

前置题目：
2550. 猴子碰撞的方法数
2360. 图中的最长环

遍历每个环，这个环的贡献为 2^环长 - 2。
不在环上的边可以随意取，贡献为 2^边数。
这些贡献相乘即为答案。		
2023年5月24日	https://codeforces.com/contest/229/problem/B

输入 n(2≤n≤1e5) m(0≤m≤1e5) 表示一个 n 点 m 边的无向图（节点编号从 1 开始）。
然后输入 m 条边，每条边包含 3 个数 a b c(1≤c≤1e4)，表示有一条边权为 c 的无向边连接 a 和 b，表示从 a 到 b 需要 c 秒。
保证无自环、无重边。
然后输入 n 行，每行第一个数 k 表示数组 t[i] 的长度，然后输入数组 t[i]。
数组 t[i] 是一个严格递增序列，0≤t[i][j]<1e9。
所有 k 之和 ≤1e5。

初始时间为 0。你从 1 出发，要去 n。
如果你在点 i，但是当前时间在数组 t[i] 中，那么你必须等待 1 秒。如果下一秒仍然在 t[i] 中，那么继续等待 1 秒。依此类推。
输出到达 n 的最早时间。
如果无法到达 n，输出 -1。

【易错题】	输入
4 6
1 2 2
1 3 3
1 4 8
2 3 4
2 4 5
3 4 3
0
1 3
2 3 4
0
输出 7

输入
3 1
1 2 3
0
1 3
0
输出 -1	1700	https://codeforces.com/contest/229/submission/206931343

Dijkstra 的变形。
把 dis[i] 定义成可以从 i 出发的最早时间。特别地，dis[n] 定义成到 n 的最早时间。
假设在时刻 j 到达点 i，那么需要快速求出 >= j 的第一个不在 t[i] 中的数 next。可以把相邻的时间合并成区间，这样二分就能求出 next。

易错点：
1. t[1][0] = 0 的情况处理了吗？
2. t[n] 中的数据不应当考虑。		
2023年5月23日	https://codeforces.com/problemset/problem/1139/C

输入 n(2≤n≤1e5) k(2≤k≤100) 和一棵无向树的 n-1 条边（节点编号从 1 开始），每条边包含 3 个数 x y c，表示有一条颜色为 c 的边连接 x 和 y，其中 c 等于 0 或 1。

对于长为 k 节点序列 a，走最短路，按顺序经过节点 a1 -> a2 -> ... -> ak。
对于所有长为 k 的节点序列 a（这有 n^k 个），统计至少经过一条 c=1 的边的序列 a 的个数。	输入
4 4
1 2 1
2 3 1
3 4 1
输出 252

输入
4 6
1 2 0
1 3 0
1 4 0
输出 0

输入
3 5
1 2 1
2 3 0
输出 210	1500	https://codeforces.com/contest/1139/submission/206859984

正难则反，统计只经过 c=0 的序列数。

相当于计算每个 c=0 组成的连通块的大小 sz，对应的只经过 c=0 序列数为 sz^k。
答案为 n^k - ∑sz^k，用快速幂计算。		
2023年5月22日	https://codeforces.com/problemset/problem/505/B

输入 n(2≤n≤100) m(1≤m≤100) 表示一个 n 点 m 边的无向图，节点编号从 1 到 n。
然后输入 m 条边，每条边输入 v w c(1≤c≤m)，表示有条颜色为 c 的边连接 v 和 w。
然后输入 q(1≤q≤100) 和 q 个询问，每个询问输入 v w，你需要输出有多少种颜色 c 满足：从 v 到 w 存在一条路径，这条路径上的边均为颜色 c。

进阶：你能想出一个低于 O(平方) 的算法吗？
见 https://codeforces.com/contest/506/problem/D	输入
4 5
1 2 1
1 2 2
2 3 1
2 3 3
2 4 3
3
1 2
3 4
1 4
输出
2
1
0	1400

进阶 2400	https://codeforces.com/problemset/submission/505/206755341

由于数据范围比较小，用 m 个并查集统计，对每个询问遍历这 m 种颜色去统计 v 和 w 是否相连。
由于 m 比较小，并查集可以用哈希表实现。

@hqztrue 的题解见右。		
2023年5月19日	https://codeforces.com/contest/786/problem/C

输入 n(1≤n≤1e5) 和长为 n 的数组 a(1≤a[i]≤n)。

定义 f(k) 为最小的 m，使得存在一种将 a 划分成 m 段的方式，其中每段的不同数字个数都不超过 k。
输出 f(1), f(2), ... ,f(n)。	输入
5
1 3 4 3 3
输出
4 2 1 1 1

输入
8
1 5 7 8 1 7 6 1
输出
8 4 3 2 1 1 1 1	2400	https://codeforces.com/contest/786/submission/203881564

如果所有 a[i] 都不同，那么 f(k) 的图像与 ceil(n/k) 一样，k 越大，f(k) 越小，且存在若干段连续的 k，每一段的 f(k) 都相同。进而想到，如果有相同的 a[i]，那么图像也应当是类似的。

根据这一性质，可以不去计算所有的 f(k)，而是暴力计算两个 f(i) 和 f(j)，如果 f(i) = f(j)，那么从 i+1,i+2,...,j-1 的 f 值都等于 f(i)。
如何选取 i 和 j 呢？
分治 [1,n]，让程序自动帮你选。
如果 f(i) != f(j) 就取 mid = (i+j)/2 继续分治。

计算 f(k) 直接暴力遍历+贪心，如果当前不同元素个数超过 k，就开一个新的段，重新统计。
代码实现时可以用时间戳标记，避免反复创建 vis 数组/哈希表。

时间复杂度 O(n√n)。		
2023年5月18日	https://codeforces.com/problemset/problem/1759/G

输入 T(≤1e4) 表示 T 组数据。所有数据的 n 之和 ≤2e5。
每组数据输入偶数 n(2≤n≤2e5) 和长为 n/2 的数组 b(1≤b[i]≤n)，下标从 1 开始。

构造一个长为 n 的 1~n 的排列 p（下标从 1 开始），满足 max(p[2*i-1],p[2*i]) = b[i]。
如果无法构造，输出 -1，否则输出字典序最小的 p。	输入
6
6
4 3 6
4
2 4
8
8 7 2 3
6
6 4 2
4
4 4
8
8 7 4 5
输出
1 4 2 3 5 6
1 2 3 4
-1
5 6 3 4 1 2
-1
1 8 6 7 2 4 3 5	1900	https://codeforces.com/problemset/submission/1759/206226901

正难则反。

从大往小填数字。

例如最后一个样例，先填 6，必须和 8 或者 7 在一起，越靠后越好。
这意味着我们需要用一个最大堆去维护 b[i] 的下标，每次取堆顶下标减一的位置填数。

@七水：并查集的思路见右（按下标从右到左填）。		
2023年5月17日	https://codeforces.com/problemset/problem/1693/B

输入 T(≤1e3) 表示 T 组数据。所有数据的 n 之和 ≤2e5。
每组数据输入 n(2≤n≤2e5) 表示一棵 n 个节点的树，编号从 1 开始，1 为根节点。
然后输入 p[2],p[3],...,p[n]，其中 p[i] 表示 i 的父节点。
然后输入 n 行，其中第 i 行输入两个数 l 和 r，表示第 i 个节点值的目标范围 [l,r]。

初始时，所有节点值均为 0。
每次操作你可以选择一条从 1 开始的路径，把路径上的每个节点值都加上一个数。要求这些数按照路径的顺序，形成一个递增序列。（可以相等，可以等于 0，例如 [0,0,1,3,3]）
要使所有节点值都在对应的范围内，至少要操作多少次？	输入
4
2
1
1 5
2 9
3
1 1
4 5
2 4
6 10
4
1 2 1
6 9
5 6
4 5
2 4
5
1 2 3 4
5 5
4 4
3 3
2 2
1 1
输出
1
2
2
5	1700	https://codeforces.com/contest/1693/submission/206072426

自底向上思考。

每个叶子由于下界 >=1，所以一定要操作，由于序列是递增的，那么尽量取范围的上界，祖先节点的增量可以没叶子这么多。

对于一个非叶节点，累加所有子节点的增量。如果小于下界，那么必须操作一次，变成上界。如果大于上界则免费调整为上界。		
2023年5月16日	https://codeforces.com/problemset/problem/1738/C

输入 T(≤100) 表示 T 组数据。
每组数据输入 n(1≤n≤100) 和长为 n 的数组 a(-1e9≤a[i]≤1e9)。

Alice 和 Bob 轮流从 a 中取数，Alice 先。
游戏直到 a 为空时停止。
如果 Alice 所取数字之和为偶数，输出 Alice，否则输出 Bob。	输入
4
3
1 3 5
4
1 3 5 7
4
1 2 3 4
4
10 20 30 40
输出
Alice
Alice
Bob
Alice	1500	https://codeforces.com/contest/1738/submission/205538013

提示：用记忆化搜索模拟。

f(leftEven, leftOdd, sum, who) 表示剩余偶数个数，剩余奇数个数，Alice 所选数字之和的奇偶性，当前玩家是 Alice 还是 Bob。

@Mike 		
2023年5月15日	https://codeforces.com/problemset/problem/1714/E

输入 T(≤1e4) 表示 T 组数据。所有数据的 n 之和 ≤2e5。
每组数据输入 n(1≤n≤2e5) 和长为 n 的数组 a(0≤a[i]≤1e9)。

每次操作你可以把 a[i] += a[i] % 10。
你可以操作任意次，相同 a[i] 也可以操作多次。

能否使所有 a[i] 都相等？输出 Yes/No。	输入
10
2
6 11
3
2 18 22
5
5 10 5 10 5
4
1 2 4 8
2
4 5
3
93 96 102
2
40 6
2
50 30
2
22 44
2
1 5
输出
Yes
No
Yes
Yes
No
Yes
No
No
Yes
No	1400	https://codeforces.com/contest/1714/submission/205531470

个位数为 0，操作后不变。
个位数为 5 的，操作后个位数变成 0，无法继续增大。
所以如果个位数为 0 或 5 的，操作一次后不能都相等，直接输出 No。

其余的可以无限增大。
手玩一下发现这些数按照模 20 的余数分成两组，每组内的数可以互相转换。
（注意从 1 出发，是无法到达 12 的，但是可以到达 22）

算上模 10 的余数为 0 或 5 的（或者模 5 余数为 0），一共可以分成三组。
所以统计这些数能不能只分成一组。

代码实现时，可以用位运算做到完美的 O(n) 一次遍历 + O(1) 空间。		
2023年5月12日	https://codeforces.com/contest/1720/problem/D2

输入 T(≤1e5) 表示 T 组数据。所有数据的 n 之和 ≤3e5。
每组数据输入 n(2≤n≤3e5) 和长为 n 的数组 a(0≤a[i]≤1e9)，下标从 0 开始。

构造一个严格单调递增的，元素范围在 [0,n-1] 的下标数组 id。
要求 id 中的所有相邻元素 i 和 j，都满足 a[i] XOR j < a[j] XOR i。
例如 a=[5,2,4,3,1]，构造 id=[1,2,4]，满足 a[1] XOR 2 < a[2] XOR 1 以及 a[2] XOR 4 < a[4] XOR 2。

输出 id 的最大长度。	输入
3
2
1 2
5
5 2 4 3 1
10
3 8 8 2 9 1 6 2 8 3
输出
2
3
6	2400	https://codeforces.com/contest/1720/submission/204199800

看到 a[i] XOR j < a[j] XOR i 这个式子，就很想把 i 移到左边，j 移到右边，这样就好处理了。
但这是小于，不是等于，没法移项！
要是能想办法改成等于就好了。

既然是位运算，那么从比特位入手，想一想这个 < 是怎么产生的。
假设 a[i] XOR j 和 a[j] XOR i 的高 k 个比特位都相等，从高到低第 k+1 个比特位不同，那么一定是 a[i] XOR j 这一位是 0，a[j] XOR i 这一位是 1，这样才能是小于的关系。

a[i] XOR j 和 a[j] XOR i 的高 k 个比特位都相等，意味着只看这些比特位，a[i] XOR j = a[j] XOR i。
是等号！太棒了，这样就可以把 i 移到左边，j 移到右边了，用哈希表统计 a[i] XOR i，统计什么呢？
但还要比较第 k+1 个比特位，必须满足：
1. a[i] XOR j = 0，那要么 a[i] = j = 0，要么 a[i] = j = 1。
2. a[j] XOR i = 1，那要么 a[j] = 0，i = 1，要么 a[j] = 1，i = 0。
假设当前遍历到 a[j]，由于 j 和 a[j] 是已知的，我们需要找的 a[i] 和 j 在这个比特位是相等的，i 和 a[j] 在这个比特位是相反的。

一通分析后，定义 f[k][x][0/1][0/1] 记录 a[i] XOR i 的高 k 个比特位的值为 x，i 的从高到低第 k+1 的比特值 0/1，a[i] 的从高到低第 k+1 的比特值 0/1，此时的下标数组 id 长度的最大值。
枚举 k，按上述规则求 id 长度的最大值，加一后更新到对应的位置上。		
2023年5月11日	https://codeforces.com/problemset/problem/883/I

输入 n k(1≤k≤n≤3e5) 和长为 n 的数组 a(1≤a[i]≤1e9)。

把这 n 个数重新排列，然后分成若干个组，要求每组至少有 k 个数。
定义 diff(b) 表示序列 b 中最大值与最小值的差。
计算所有组的 diff 值的最大值 mx。
输出 mx 的最小值。	输入
5 2
50 110 130 40 120
输出 20

输入
4 1
2 3 4 1
输出 0	1900	https://codeforces.com/problemset/submission/883/205379777

排序后，二分答案。

贪心分组？看上去漏洞百出，不妨考虑 DP。

定义 f[i+1] 表示 a[0] 到 a[i] 能否满足要求。
初始值 f[0]=true，表示空数组满足要求。
先写一个 O(n^2) 的转移，也就是 f[i+1] = any(f[j])，这里 i-j+1 >= k 且 a[i]-a[j]<=mx，any(f[j]) 表示只要有一个 f[j] 是 true，f[i+1] 就是 true。
相当于，如果 a[0] 到 a[j-1] 满足要求，且 a[j] 到 a[i] 满足要求，那么 f[i+1] 就是 true。

如何优化？
设 f[i+1] 是从 f[j0] 转移过来的，这里 j0 满足 f[j0]=true。
那么 f[i+2] 可以从 >= j0 的下标转移过来，因为有 j0 的存在，且随着 i 的增大，j 能取到的最小值不会减少（因为 a[i]-a[j]<=mx），所以 j<j0 的 f[j] 就无需考虑了。
既然 j0 是单调递增的，利用这个性质就可以用双指针把 check 优化到 O(n)。	https://www.bilibili.com/video/BV1hd4y1r7Gq/	
2023年5月10日	https://codeforces.com/problemset/problem/1118/D2

输入 n(1≤n≤2e5) (1≤m≤1e9) 和长为 n 的数组 a(1≤a[i]≤1e9)。

把这 n 个数重新排列，然后分成 x 个组。
每个组的第一个数不变，第二个数减一，第三个数减二，依此类推。
如果有数字减成负数，则从组中去掉。

要使所有数字之和至少为 m，x 最小是多少？
如果无法做到，输出 -1。	输入
5 8
2 3 1 1 2
输出
4

输入
7 10
1 3 4 2 1 4 2
输出
2

输入
5 15
5 5 5 5 5
输出
1

输入
5 16
5 5 5 5 5
输出
2

输入
5 26
5 5 5 5 5
输出
-1	1700	https://codeforces.com/contest/1118/submission/205215714

二分答案 x。

优先用大的数字更优，放置方案为：a 倒序排，先把最大的 x 个数每个组放一个，然后剩下的 x 个最大的数每个组放一个，依此类推。
另一个启发思路是，很小的数字被减去的量也更小，比如 2 至多减去 2，所以把小的数字排在后面，整体减少的量更小。		
2023年5月9日	https://codeforces.com/problemset/problem/997/A

输入 n(1≤n≤3e5) x(0≤x≤1e9) y(0≤y≤1e9) 和长为 n 的 01 字符串 s。

你可以执行任意次操作，每次选择其中一种操作执行。
1. 花费 x，reverse s 的一个子串，例如 1110 -> 0111。
2. 花费 y，flip s 的一个子串，例如 1110 -> 0001。

目标：使 s 中只有 1。
输出最少花费。	输入
5 1 10
01000
输出
11

输入
5 10 1
01000
输出
2

输入
7 2 3
1111111
输出
0	1500	https://codeforces.com/contest/997/submission/205172377

如果没有 0，输出 0。
如果 x < y，那么可以把所有 0 通过多次 reverse 操作聚在一起，然后再操作一次 flip。
reverse 的操作次数就是 0 组的个数减一。例如 001101000 中有三个 0 组，需要两次 reverse。
如果 x >= y，那么把每个 0 组 flip 掉即可。		
2023年5月8日	https://codeforces.com/problemset/problem/520/B

输入两个不同的整数 n m，范围都在 [1,1e4]。

每次操作，可以 n*=2，或者 n-=1。
至少操作多少次可以得到 m？

如果还可以加一呢？
https://codeforces.com/problemset/problem/710/E	输入 4 6
输出 2

输入 10 1
输出 9	1400	https://codeforces.com/contest/520/submission/204549550

如果 n > m，就只能不断 -1 了，所以直接输出 n-m。

如果 n < m，可以用 BFS（稍微限制一下数字的上界，比如不能超过 10m）。

下面说一个 O(log) 的做法。

由于 *2 不稳定（不知道什么时机 *2 最好），逆向思维，改成从 m 出发，通过 /2 和 +1 变成 n。

能不能执行连续两次 +1，再 /2 呢？

这不如先 /2 再 +1，只需要两次操作
所以只要 m 是偶数就 /2，奇数才 +1。直到 m <= n 退出循环，因为必须都 +1。这样可以做到 O(log) 的时间复杂度。

O(1) 做法见右侧链接。	https://codeforces.com/contest/520/submission/205035892	
2023年5月5日	https://codeforces.com/problemset/problem/915/F

输入 n (1≤n≤1e6) 和长为 n 的数组 a(1≤a[i]≤1e6)，下标从 1 开始。
然后输入一棵树的 n-1 条边，节点编号从 1 开始。

定义 Δ(x,y) 表示从 x 到 y 的简单路径上的 a[i] 的最大值与最小值的差。
输出所有 Δ(i,j) 的和，其中 1≤i≤j≤n。	输入
4
2 2 3 1
1 2
1 3
1 4
输出 6	2400	https://codeforces.com/problemset/submission/915/203430331

贡献法。

最大值和最小值分别计算贡献。

先算最大值的贡献。
随着 a[i] 不断变大，以 a[i] 为最大值的连通块的大小也在变大，这可以用并查集维护。
但是并查集一般是维护边的，怎么维护点呢？
把边 u-v 的边权当作 max(a[u],a[v]) 即可。
所以实际上是按照 max(a[u],a[v]) 对边排序，然后再并查集计算。
合并 u 和 v 的时候，计算 max(a[u],a[v]) 产生的贡献。根据乘法原理，这是 max(a[u],a[v]) * size[u] * size[v]，其中 size[i] 是合并前 i 所处连通块的大小。

最小值的贡献同理，按照 a[i] 从大到小计算。

代码实现时，可以让每条边的第二个端点的 a[i] 值更大，这样排序的时候就不需要求 max 了，效率更高。

相似题目
2421. 好路径的数目		
2023年5月4日	https://codeforces.com/problemset/problem/1479/B1

输入 n(1≤n≤1e5) 和长为 n 的数组 a(1≤a[i]≤n)。

从 a 中选择一个子序列 A，剩余元素作为另一个子序列 B。
定义 f(C) 表示对序列 C 不断去掉相邻相同元素，直到没有相邻相同元素为止，返回剩余元素的个数。
例如 f([1,1,2,1,1]) = f([1,2,1]) = 3。
输出 f(A) + f(B) 的最大值。

变形（这场的 B2）：输出 f(A) + f(B) 的最小值。	输入
7
1 1 2 2 3 3 3
输出 6

输入
7
1 2 3 4 5 6 7
输出 7	1900	https://codeforces.com/problemset/submission/1479/204384720

想象成往两个数组 s 和 t 的末尾不断添加元素。

为方便计算，初始时 s 和 t 中都添加一个 0。

如果 a[i] 与 s、t 的末尾元素都相同，那么加到哪个数组末尾都是一样的。
如果 a[i] 与 t 的末尾元素相同，那么加到 s 末尾。
如果 a[i] 与 s 的末尾元素相同，那么加到 t 末尾。
如果 a[i] 与 s、t 的末尾元素都不相同，例如 s 末尾为 1，t 末尾为 2，a[i]=3，此时应考察下一个 1 以及下一个 2 的位置，哪个位置更近，就加到哪个数组末尾（如果没有下一个元素就视作 n+1）。例如下一个 1 的位置更近，那么应当把 a[i] 加到 s 末尾，相当于把这两个 1 隔开；至于 t，后面还有机会把 t 末尾的 2 和下一个 2 隔开。更严谨的证明见右边链接。	https://codeforces.com/blog/entry/87598	
2023年5月3日	https://codeforces.com/problemset/problem/1608/C

输入 T(≤100) 表示 T 组数据。所有数据的 n 之和 ≤1e5。
每组数据输入 n(≤1e5)，长为 n 的数组 a(1≤a[i]≤1e9)，长为 n 的数组 b(1≤b[i]≤1e9)。
a 中无重复元素，b 中无重复元素。

有 n 名选手，两个比赛场地。
第 i 个选手在第一个场地的力量是 a[i]，在第二个场地的力量是 b[i]。
每次从剩余选手中选择两名选手，以及一处比赛场地。力量小的淘汰。
n-1 次比赛后，剩下的那个人是冠军。

安排谁和谁比赛的权力在你手上（你是懂暗箱操作的），请对每位选手都作出判断，如果第 i 位选手能成为冠军，输出 1，否则输出 0。	输入
3
4
1 2 3 4
1 2 3 4
4
11 12 20 21
44 22 11 30
1
1000000000
1000000000
输出
0001
1111
1	1700	https://codeforces.com/contest/1608/submission/203857553

方法不止一种。无需建图，下面讲只用循环的做法。

按照 a[i] 从小到大排序，方便研究。

手玩如下输入，如何让 a[i]=1 的这位选手获胜呢？
a = 1 2 3 4 5 6
b = 2 4 1 6 3 5

右边的选手可以通过第一个场地击败左边的
左边的选手可以通过第二个场地击败右边的（如果左边的选手 b[i] 大的话）

思考：
甲需要干掉 a 最大的人（只能是第二个场地），也就是找到一个 i<n 且 b[i]>b[n] 的 i。
乙干掉甲（只能是第一个场地），也就是找到一个 j>i 的人。
为了能让更左边的选手丙干掉乙（第二个场地），b[j] 越小越好。
然后再找人干掉丙（第一个场地）。
如此反复。

那么让 a[i]=1 的选手获胜的方案为：（数字表示 b[i]）
6 干掉 5
3 干掉 6（第一个场地）
4 干掉 3
1 干掉 4（第一个场地）
2 干掉 1

你能将上述过程转换成代码吗？

刚才算的是第一位选手能否获胜，如何计算其它选手能否获胜呢？
由于他可以干掉他左边的人（第一个场地）
那么把他和他左边的人的 b[i] 取最大值，合并成一名选手，就转换成上面的讨论了。		
2023年5月2日	https://codeforces.com/problemset/problem/1256/D

输入 T(≤1e4) 表示 T 组数据。所有数据的 n 之和 ≤1e6。
每组数据输入 n(≤1e6) k(≤n^2) 和长为 n 的 01 字符串 s。

你可以交换相邻字符，至多 k 次。
输出字典序最小的结果。

如果不是 01 串要怎么做？加强版：https://leetcode.cn/problems/minimum-possible-integer-after-at-most-k-adjacent-swaps-on-digits/	输入
3
8 5
11011010
7 9
1111100
7 11
1111100
输出
01011110
0101111
0011111	1500	https://codeforces.com/problemset/submission/1256/203854959

贪心。
0 往左移。
先移动左边的 0 更优。
那么从左到右遍历，同时统计 1 的个数 c1。如果遇到 0，且 c1 <= k，那么就直接移到开头，k 减小 c1；否则只能移动 k 次，循环结束。		
2023年5月1日	https://codeforces.com/problemset/problem/489/C

输入 m(1≤m≤100) 和 s(0≤s≤900)。
构造长为 m 的非负整数 x，无前导零，且数位和等于 s。
输出 x 的最小值和最大值。如果没有这样的 x，输出 -1 -1。	输入 2 15
输出 69 96

输入 3 0
输出 -1 -1	1400	https://codeforces.com/contest/489/submission/203167530

分类讨论。

最小的类似 1000069999
最大的类似 9999700000

具体细节见代码。		
2023年4月28日	https://codeforces.com/problemset/problem/1428/F

输入 n(1≤n≤5e5) 和长为 n 的字符串 s，只包含 '0' 和 '1'。

定义 f(t) 为 t 中最长连续 '1' 的长度。（如果 t 中没有 ‘1’，f(t)=0）
枚举 s 的所有子串 t，输出 f(t) 的和。	输入
4
0110
输出 12

输入
7
1101001
输出 30

输入
12
011100011100
输出 156	2400	https://codeforces.com/contest/1428/submission/203608811

增量法。推荐先做 https://leetcode.cn/problems/total-appeal-of-a-string/

定义 last[ones] 表示上一次出现连续 ones 个 1 的起始位置。
定义 sum 表示以 s[i] 结尾的字符串的 f(t) 之和。答案就是一边遍历 s，一边累加 sum。
于是重点关注 sum 是怎么变的。从 s[i-1] 到 s[i]，sum 增加了多少。

维护到 s[i] 连续出现了 ones 个 1。
如果 s[i] 是 1，考察 last[ones]。右端点为 i，左端点大于 last[ones] 的子串的 f 值都增加了 1，所以 sum 增加了 i-last[ones]。 
如果 s[i] 是 0，那么连续 1 中断了，在此时去更新 last[1], last[2], last[3], ..., last[ones]。为什么 s[i]=1 的时候不更新？那样时间复杂度是 O(n^2) 的，在 s[i]=0 时更新是均摊 O(1)。		
2023年4月27日	https://codeforces.com/problemset/problem/149/D

输入一个合法括号字符串，仅包含 '(' 和 ')'，长度范围 [2,700]。

对括号染色，必须满足如下所有条件：
1. 一个括号可以染成红色、蓝色或者不染色。
2. 对于一对匹配的括号，恰好其中一个被染色。
3. 两个相邻的染了色的括号，颜色不能相同。

求染色方案数，模 1e9+7。	输入 (())
输出 12

输入 (()())
输出 40

输入 ()
输出 4	1900	https://codeforces.com/problemset/submission/149/205292757

首先预处理每个左括号对应的右括号的位置，用栈来处理。

由于是从外到内递归，从内到外转移，所以是区间 DP，可以看 https://www.bilibili.com/video/BV1Gs4y1E7EU/

DP 除了记录区间左右端点 l r 外，为了判断条件 3，还需要记录 l-1 和 r+1 的颜色。
然后就是分类讨论了，具体见代码。		
2023年4月26日	https://codeforces.com/problemset/problem/295/B

输入 n(1≤n≤500) 表示 n 个点的有向完全图，然后输入 n*n 的邻接矩阵 a，其中 a[i][j] 表示 i 到 j 的边权，范围 [1,1e5]（特例是 a[i][i]=0）。
图的节点编号从 1 开始。
然后输入 1~n 的排列，表示我要一个个地删除图上的点，每删除一个点，这个点的出边和入边都会被删除。
输出 n 个数，第 i 个数表示第 i 次删除之前，所有剩余点对的最短路之和。	输入
1
0
1
输出
0

输入
2
0 5
4 0
1 2
输出
9 0

输入
4
0 3 1 1
6 0 400 1
2 4 0 1
1 1 1 0
4 1 2 3
输出
17 23 404 0	1700	https://codeforces.com/contest/295/submission/202933808

倒着加点。

每次添加点 k 后，跑只与 k 有关的 Floyd。
也就是对所有点对更新 d[i][j] = min(d[i][j], d[i][k]+d[k][j])
（相当于输入的这个排列规定了 Floyd 最外层的循环顺序。）

Floyd 原理见 https://www.bilibili.com/video/BV1Es4y1N7v1/ 第四题方法二。		
2023年4月25日	https://codeforces.com/contest/1272/problem/D

输入 n(2≤n≤2e5) 和长为 n 的数组 a(1≤a[i]≤1e9)。
你可以从 a 中去掉一个数（也可以不去掉）。
输出 a 的最长严格递增连续子数组的长度。	输入
5
1 2 5 3 4
输出 4

输入
2
1 2
输出 2

输入
7
6 5 4 3 2 4 3
输出 2	1500	https://codeforces.com/contest/1272/submission/148467966

前后缀分解。

计算从后往前的严格递增子数组长度 suf[i]。
计算从前往后的严格递增子数组长度 pre[i]。
如果 a[i-1] < a[i+1]，那么可以去掉 a[i]，用 pre[i-1] + suf[i+1] 更新答案。

注：也可以状态机 DP，f[i][0/1] 表示到 i 的答案，0/1 表示是否消耗了一次去掉的机会。		
2023年4月24日	https://codeforces.com/problemset/problem/1095/C

输入 n(1≤n≤1e9) k(1≤k≤2e5)。
把 n 分解为 k 个正整数，要求这些数都是 pow(2,i)，即 1,2,4,8,……
如果无法做到，输出 NO，否则输出 YES 和这 k 个数。	输入
9 4
输出
YES
1 2 2 4

输入
8 1
输出
YES
8

输入
5 1
输出
NO

输入
3 7
输出
NO	1400	https://codeforces.com/contest/1095/submission/202908506

什么时候输出 NO？
k > n，或者 k < n 的二进制中的 1 的个数。
否则一定可以，因为可以把 2^i 拆分成两个更小的 2^(i-1)。

也可以先从 n 中减去 k 个 1，得到 n'，表示剩余需要分配的量。
然后初始化所有 ans[i]=1，
从 a[1]=1 出发，如果 a[1]<=n'，那么把 a[1] 从 1 变成 2，n'-=1
如果 a[1]<=n'，那么把 a[1] 从 2 变成 4，n'-=2。
如此不断循环直到 a[1]>n'，
再尝试让下一个 a[2] 不断变大，……		
2023年4月21日	https://codeforces.com/problemset/problem/1485/F

输入 T(≤1e4) 表示 T 组数据。所有数据的 n 之和 ≤2e5。
每组数据输入 n(≤2e5) 和长为 n 的数组 b(-1e9≤b[i]≤1e9)，下标从 1 开始。

构造下标从 1 开始的数组 a，对于每个 i，满足 b[i] = a[i] 或者 b[i] = a[1] + a[2] + ... + a[i]。
输出有多少个不同的 a，模 1e9+7。	输入
4
3
1 -1 1
4
1 2 3 4
10
2 -1 1 -2 2 3 -5 0 2 -1
4
0 0 0 1
输出
3
8
223
1	2400	https://codeforces.com/contest/1485/submission/202820084

提示 1：两个 a 不同，当且仅当这两个 a 的前缀和不同。那么考虑 a 的前缀和有多少不同的。

提示 2：设 a 的前缀和为 s，则有：
s1 = a1 = b1
s2 = s1 + a2 = b2 或 s1 + b2
s3 = s2 + a3 = b3 或 s2 + b3
……
画出的分支图以及样例一见右。注意对于样例一，b3=b1+b2+b3，所以下面只有一个分支

提示 3：定义 f[i] 表示从 a[i] 开始的不同后缀的个数。
右图最左边的 1 这棵树就是 f[1]，-1 这棵树就表示 f[2]，右下的 1 这棵树就表示 f[3]。
设 j 是最小的满足 a[i] + ... + a[j-1] = 0 的下标，那么
f[i] = f[i+1] + ... + f[j]
如果 j 不存在，那么
f[i] = f[i+1] + ... f[n] + 1
从状态转移方程可以看出，需要倒序循环计算 f。
所以，记录 a 的后缀和的位置信息，可以算出 j。记录 f 的后缀和，可以 O(1) 算出 f[i]。
答案为 f[1]。	图片	
2023年4月20日	https://codeforces.com/problemset/problem/1404/B

输入 T(≤1e4) 表示 T 组数据。所有数据的 n 之和 ≤1e5。
每组数据输入 n(2≤n≤1e5) 表示一棵 n 个节点的树（节点编号从 1 开始）。
然后输入树上两个不同的点 a 和点 b，表示 Alice 和 Bob 的位置。
然后输入 da db，范围在 [1,n-1]。表示 Alice 和 Bob 每次传送的最大距离。例如从 x 传送到 y，那么 x 到 y 的简单路径的边数不能超过最大距离。
然后输入这棵树的 n-1 条边。

Alice 和 Bob 轮流在树上传送（可以原地不动），Alice 先手。
Bob 逃，Alice 追。
如果在有限步内 Alice 和 Bob 能在同一个点，输出 Alice，否则输出 Bob。
注意从 x 传送到 y，并不会经过从 x 到 y 的简单路径的中间节点。	输入
4
4 3 2 1 2
1 2
1 3
1 4
6 6 1 2 5
1 2
6 5
2 3
3 4
4 5
9 3 9 2 5
1 2
1 6
1 9
1 3
9 5
7 9
4 8
4 3
11 8 11 3 3
1 2
11 9
4 9
6 5
2 10
3 2
5 9
8 3
7 4
7 10
输出
Alice
Bob
Alice
Alice	1900	https://codeforces.com/contest/1404/submission/202566203

分类讨论：

如果 2*da >= db，那么 Alice 每次向 Bob 移动一步，必然可以在某个时刻让 Bob 无路可走。

如果 Alice 到 Bob 的距离 <= da，那么 Alice 第一步就可以和 Bob 相遇。

如果 2*da >= 树的直径，那么 Alice 只要走到树的直径的中点，就可以传送到树的任意位置，也就可以和 Bob 相遇了。

其余情况，Bob 总是可以「跨过」Alice。
Bob 可以选择留在原地，只要 Alice 覆盖到了 Bob，就立刻跳出 Alice 的覆盖范围。

注：树的直径可以用 DP，也可以用两次 DFS。

---

@Aging：这题告诉我们既要有生存能力也要有生存空间。	https://www.bilibili.com/video/BV17o4y187h1/	
2023年4月19日	https://codeforces.com/problemset/problem/1344/A

输入 T(≤1e4) 表示 T 组数据。所有数据的 n 之和 ≤2e5。
每组数据输入 n(≤2e5) 和长为 n 的数组 a(-1e9≤a[i]≤1e9)。

如果对于任意两个不同的整数 k1 和 k2，都满足 a[k1 mod n] + k1 ≠ a[k2 mod n] + k2，则输出 YES，否则输出 NO。
注意对于负数 k，k mod n 的结果也在 [0,n-1] 内。	输入
6
1
14
2
1 -1
4
5 5 5 1
3
3 2 1
2
0 1
5
-239 -2 -100 -3 -11
输出
YES
YES
YES
NO
NO
YES	1600	https://codeforces.com/contest/1344/submission/202560069

考虑什么时候输出 NO。
设 k1 = p1*n + i, k2 = p2*n + j
则有 a[i] + (p1*n + i) = a[j] + (p2*n + j)
变形得 (a[i] + i) - (a[j] + j) = (p2-p1) * n
由于 p2-p1 可以随意取，所以变成 a[i] + i 和 a[j] + j 模 n 同余。
所以问题变成 a 中是否有相同的 (a[i]+i) % n，用 bool 数组记录即可。
注意取模为负数时要调整到非负数。		
2023年4月18日	https://codeforces.com/problemset/problem/1444/A

输入 T(≤50) 表示 T 组数据。
每组数据输入 p(1≤p≤1e18) 和 q(2≤q≤1e9)。

输出最大的 x，满足 p 是 x 的倍数，且 x 不是 q 的倍数。	输入
3
10 4
12 6
179 822
输出
10
4
179	1500	https://codeforces.com/problemset/submission/1444/202556296

如果 p 不是 q 的倍数，那么答案就是 p。
如果 p 是 q 的倍数，那么考虑质因子分解：
例如 p = 2^5 * 3^4，q = 2^3 * 3^4，通过把 p 中 2 的幂次减小到 2，得到 2^2 * 3^4，就可以满足题目要求了（不是 q 的倍数）
也可以把 p 中 3 的幂次减小到 3，得到 2^5 * 3^3，同样不是 q 的倍数。
遍历 q 的每个质因子（必然都是 p 的质因子），幂次减小后的数的最大值即为答案。

怎么实现呢？模拟的做法是质因子分解（之前周赛讲过），计算质因子的幂次。也可以从 p 开始不断除质因子，直到无法被 q 整除时为止。		
2023年4月17日	https://codeforces.com/problemset/problem/1369/C

输入 T(≤1e4) 表示 T 组数据。所有数据的 n 之和 ≤2e5。
每组数据输入 n k(1≤k≤n≤2e5) 和长为 n 的数组 a(-1e9≤a[i]≤1e9)，长为 k 的数组 w(1≤w[i]≤n 且 sum(w)=n)。

把这 n 个数放到 k 个盒子中，使得第 i 个盒子恰好有 w[i] 个数。
定义一个盒子的价值为该盒子中的最大数与最小数之和。特别地，如果一个盒子只有一个数 x，那么这个盒子的价值为 2x。
累加所有盒子的价值，输出它的最大值。	输入
3
4 2
1 13 7 17
1 3
6 2
10 10 10 10 11 11
3 3
4 4
1000000000 1000000000 1000000000 1000000000
1 1 1 1
输出
48
42
8000000000	1400	https://codeforces.com/contest/1369/submission/201955758

提示 1：前 k 大的数一定可以作为最大值。且尽量把大的数放在 w[i] = 1 的组中，这样可以计入答案两次。
如果某个前 k 大的数 x 没有作为最大值（其中一个组的最大值是不在前 k 大中的 y），那么把 x 和 y 交换，
如果 x 是某个组的最小值，那么交换后 y 必然也是最小值，此时答案不变。
如果 x 不是某个组的最小值（这个组的最小值是 z）：
       如果 y 交换后变成了最小值，那么答案变大了 x-z。
       如果 y 交换后也不是最小值，那么答案变大了 x-y。
无论如何，这样交换都不会使答案变小，因此前 k 大的数一定可以作为最大值。

提示 2：然后来说最小值。a 的最小值必然要分到某个组中，为了「跳过」尽量多的较小的数，优先把 a 中较小的数分到 w 较大的组中。所以 a 从小到大遍历，w 从大到小遍历。		
2023年4月14日	https://codeforces.com/problemset/problem/1469/E

输入 T(≤1e4) 表示 T 组数据。所有数据的 n 之和 ≤1e6。
每组数据输入 n k(1≤k≤n≤1e6) 和长为 n 的 01 字符串 s。

定义两个长为 k 的字符串 x 和 y「一点点相同」：存在某个下标 i，使得 x[i] = y[i]。
你需要找到一个长为 k 的字典序最小的 01 串 t，使得 t 与 s 的每个长为 k 的子串都「一点点相同」。
如果不存在这样的 t，输出 NO；否则输出 YES 和 t。	输入
7
4 2
0110
4 2
1001
9 3
010001110
9 3
101110001
10 3
0101110001
10 10
1111111111
11 10
11111111110
输出
YES
11
YES
00
YES
010
YES
101
NO
YES
0000000001
YES
0000000010	2400	https://www.luogu.com.cn/blog/endlesscheng/solution-cf1469e

我的题解，欢迎点赞~		
2023年4月13日	https://codeforces.com/problemset/problem/1154/E

输入 n k(1≤k≤n≤2e5) 和一个 1~n 的排列 p。
每次操作，选择 p 中最大的数字，然后删除 p 及其左右各 k 个未被删除的元素。
对于每个 p[i]，如果它是第 1,3,5,… 次操作被删除的，输出 1；如果它是第 2,4,6,… 次操作被删除的，输出 2。	输入
5 2
2 4 5 3 1
输出 11111

输入
5 1
2 1 3 5 4
输出 22111
解释 第一次操作删除 [3,5,4]，第二次操作删除 [2,1]

输入
7 1
7 2 1 3 5 4 6
输出 1121122

输入
5 1
2 4 5 3 1
输出 21112	1800	https://codeforces.com/contest/1154/submission/201766208

由于数据范围是 1~n，可以用一个 pos 数组记录每个数的下标，然后用双向链表模拟。
从 n 开始倒着找这个数的位置，比如叫 i，如果它没有被删除，就在双向链表上删除 i 及其前后各 k 各节点。

双向链表可以用数组实现，维护 prev 和 next。		
2023年4月12日	https://codeforces.com/problemset/problem/1473/D

输入 t(≤1e3) 表示 t 组数据。所有数据的 n 之和 ≤2e5，m 之和 ≤2e5。
每组数据输入 n(≤2e5) m(≤2e5) 和长为 n 的字符串 s，仅包含 '+' 和 '-'，分别表示 +1 和 -1，下标从 1 开始。
然后输入 m 个询问，每个询问输入 L 和 R，表示区间 [L,R] (1≤L≤R≤n)。
把从 s[L] 到 s[R] 的这段子串去掉后，s 的剩余部分记作 t。
对于数字 x=0，逐个执行 t 中的字符，输出你能得到多少个不同的数字。
例如 t="+--"，那么 x 分别为 0,1,0,-1，一共有 3 个不同的数字，输出 3。
又例如 t=""，那么只有 0，输出 1。
每个询问互相独立。	输入
2
8 4
-+--+--+
1 8
2 8
2 5
1 1
4 10
+-++
1 1
1 2
2 2
1 3
2 3
3 3
1 4
2 4
3 4
4 4
输出
1
2
4
4
3
3
4
2
3
2
1
2
2
2	1700	https://codeforces.com/contest/1473/submission/201614540

提示 1：前后缀分解，预处理从左往右、从右往左的信息。只需要记录哪些信息？

提示 2：
从左往右，需要知道：
- 当前 x，记作 cur。；
- x 的历史最大值，记作 max。
- x 的历史最小值，记作 min。
记录到数组 pre 中。

从右往左，由于需要拼接在某个 pre 之后，当前 x 的值是不重要的，重要的是：
- x 的历史最大值减去当前 x 的值，记作 up。换句话说，拼接的那个值可以增大多少。
- x 的历史最小值减去当前 x 的值，记作 down。换句话说，拼接的那个值可以减小多少。
记录到数组 suf 中。

把某个 pre 和某个 suf 拼接后：
最大值 = max(pre.max, pre.cur + suf.up)
最小值 = min(pre.min, pre.cur + suf.down)
不同 x 的个数 = 最大值 - 最小值 + 1	这题两年前还没想明白，现在已经可以秒了	
2023年4月11日	https://codeforces.com/problemset/problem/1296/C

输入 t(≤1e3) 表示 t 组数据。所有数据的 n 之和 ≤2e5。
每组数据输入 n(≤2e5) 和长为 n 的字符串 s，仅包含 LRUD，分别表示左右上下四个方向。

一个机器人初始在 (0,0)，按照 s 移动，每一步移动一个单位长度。
设机器人最终移动到了 (x,y)。
你需要从 s 中删除一段尽量短的非空连续子串，得到 s'，使得机器人从 (0,0) 出发，按照 s' 也能移动到 (x,y)。
输出你删除的这段子串的左右端点（下标从 1 开始）。
如果无法做到，输出 -1。	输入
4
4
LRUD
4
LURD
5
RRUDU
5
LLDDR
输出
1 2
1 4
3 4
-1	1500	https://codeforces.com/contest/1296/submission/201606705

提示 1：如果只有左右两个方向，要怎么做？

提示 2：转换成 -1 和 +1，问题变成去掉一个子数组，使得数组的和等于 0。

提示 3：经典前缀和+哈希表的套路。

提示 4：回到原问题，遍历 s，用哈希表记录位置 (x,y) 及此时的下标。
如果 (x,y) 在哈希表中出现过，那么就找到了要删除的左端点。
维护删除长度的最小值。		
2023年4月10日	https://codeforces.com/problemset/problem/1201/C

【灵茶の试炼】一周年纪念。

输入 n(1≤n≤2e5 且是奇数) k(1≤k≤1e9) 和长为 n 的数组 a(1≤a[i]≤1e9)。

每次操作你可以把 a 中的一个数加一。
至多操作 k 次。

输出 a 的中位数的最大值。	输入
3 2
1 3 5
输出 5

输入
5 5
1 2 1 1 1
输出 3

输入
7 7
4 1 2 4 3 4 4
输出 5	1400	https://codeforces.com/contest/1201/submission/201600969

首先排序，下标小于 n/2 的都不用变。或者说，中位数至少为 a[n/2]。（注意 n 是奇数）

方法一：二分答案 mid，统计 a[n/2:] 中有多少个小于 mid 的数要变成 mid，比较操作次数与 k。

方法二：贪心，从 a[n/2] 开始增加，如果和后面的数一样就一起加，具体见代码。		
2023年4月7日	https://codeforces.com/problemset/problem/1610/E

输入 t(≤1e4) 表示 t 组数据。所有数据的 n 之和 ≤2e5。
每组数据输入 n(2≤n≤2e5) 和长为 n 的有序数组 a(1≤a[i]≤1e9)，有重复元素。

你需要从 a 中删除一些元素，使得对于 a 的任意非空子序列 b，都必须满足：
设 avg 为 b 的平均值（可以是小数），b 中比 avg 小的数的个数必须 >= b 中比 avg 大的数的个数。

例如 [1,4,4,5,6] 的平均值为 4，有 1 个数比 4 小，有 2 个数比 4 大，这是不满足要求的。
而 [4,4,5,6] 是满足要求的。

最少需要删除多少个数？

注：子序列不要求连续。	输入
4
3
1 2 3
5
1 4 4 5 6
6
7 8 197860736 212611869 360417095 837913434
8
6 10 56026534 405137099 550504063 784959015 802926648 967281024
输出
0
1
2
3	2300	https://codeforces.com/problemset/submission/1610/200982867

提示 1：长为 3 的子序列需要满足什么性质？

设这三个数分别为 x，y，z，那么 y <= avg = (x+y+z)/3，变形得 z >= 2y-x = 2(y-x)+x

提示 2：在长为 3 的子序列的基础上，增加一个数，这个数需要满足什么性质？

设增加的数为 u，那么 x，z，u 必须是满足要求的，即 u >= 2z-x >= 2(2y-x)-x = 4y-3x = 4(y-x)+x

依此类推，增加的数必须 >= 2^k*(y-x)+x，这是指数增长的，所以子序列 b 的长度不会超过 log(max(a))。

这样就可以暴力了，为了让去掉的数尽量少，那么保留的数要尽量多。
1. y-x 尽量小（但不能为 0），那么枚举所有 a[i] != a[i+1] 作为 x 和 y。
2. 从 x,y 开始构建子序列 b，二分找下一个数。

注意重复元素，所有重复的 x 都可以保留。		
2023年4月6日	https://codeforces.com/problemset/problem/1628/B

输入 t(≤100) 表示 t 组数据。所有数据的 n 之和 ≤1e5。
每组数据输入 n(≤1e5) 和长为 n 的字符串数组 a，每个 a[i] 长度都不超过 3，由小写字母组成。

能否从 a 中找到一个非空子序列 b，使得按顺序连接 b 中的字符串，得到的是一个回文串。
输出 YES 或 NO。

注：子序列不要求连续。	输入
6
5
zx
ab
cc
zx
ba
2
ab
bad
4
co
def
orc
es
3
a
b
c
3
ab
cd
cba
2
ab
ab
输出
YES
NO
NO
YES
YES
NO	1700	https://codeforces.com/contest/1628/submission/157119596

从 a[i] 的长度不超过 3 入手。

如果 a[i] 已经是回文串，那么输出 YES。

剩下是长度为 2 和 3 的非回文串。

如果子序列有超过 2 个字符串，那么首尾必然可以组成回文串。
（思考 2+2, 2+3, 3+2, 3+3，比如 "ab" + ... + "cba" 是回文串，但是 "ab" + "cba" 就已经是回文串了）

所以子序列的长度不会超过 2。

所以问题变成：a 中是否有回文串，或者 a[i] + a[j] 是否为回文串。
后者可以用类似两数之和的做法搞定（哈希表）。

你也可以想想只用数组怎么做。（见代码）		
2023年4月5日	https://codeforces.com/problemset/problem/1555/D

输入 n(≤2e5) m(≤2e5) 和长为 n 的字符串 s，仅包含小写字母 'a' 'b' 'c'，下标从 1 开始。
然后输入 m 个询问，每个询问输入 L R(1≤L≤R≤n)。
对每个询问，要使 s[L] 到 s[R] 中没有长度大于等于 2 的回文子串，至少需要修改多少个字符？注意你只能使用 'a' 'b' 'c' 来修改。
每个询问是独立的，即修改操作不影响其他询问。	输入
5 4
baacb
1 3
1 5
4 5
2 3
输出
1
2
0
1	1600	https://codeforces.com/contest/1555/submission/130420793

手玩一下发现只能由 abc 的某个排列重复多次，才能没有长度大于等于 2 的回文子串。

所以预处理 abc 的 6 种排列对应的修改次数的前缀和，就可以 O(1) 回答每个询问了。		
2023年4月4日	https://codeforces.com/problemset/problem/1436/C

输入 n x(1≤x≤n≤1e3) pos(0≤pos≤n-1)。

输出满足以下条件的数组 a 的个数：
1. a 是一个 1~n 的排列，且 a[pos] = x（下标从 0 开始）
2. 调用 BinarySearch(a, x) 的结果是 true。
答案模 1e9+7。















	输入 4 1 2
输出 6

输入 123 42 24
输出 824071958	1500	https://codeforces.com/contest/1436/submission/96620271

要能二分查找到正确的 x，只需要每一步的 a[middle] 和 x 的大小关系是正确的。
因此统计二分中会遇到几次 middle < pos 的和几次 middle > pos 的。
middle < pos 的情况，a[middle] 一定要 <x；
middle > pos 的情况，a[middle] 一定要 >x。
这相当于统计 a 中有几个位置上的数一定比 x 小，有几个位置上的数一定比 x 大（注意 a 是一个排列）。

设有 L 个比 x 小的数，有 g 个比 x 大的数，那么：
需要从 x-1 个数中选出 L 个数，填到这 L 个二分中的位置上，且可以随意排列，即 A(x-1,L) 种方案；
需要从 n-x 个数中选出 g 个数，填到这 g 个二分中的位置上，且可以随意排列，即 A(n-x,g) 种方案；
其余的 n-1-L-g 个数任意排列，即 (n-1-L-g)! 种方案。
这三个方案数相乘，即为答案（乘法原理）。		
2023年4月3日	https://codeforces.com/problemset/problem/1348/B

输入 t(≤50) 表示 t 组数据。
每组数据输入 n k(1≤k≤n≤100) 和长为 n 的数组 a(1≤a[i]≤n)。

你可以在 a 中插入任意多个整数（包括开头和末尾），这些数必须在区间 [1,n] 内。
设插入之后的数组为 b，要求 b 中每个长为 k 的子数组的元素和必须都相同，且 b 的长度不能超过 1e4。

如果无法做到，输出 -1。否则输出数组 b 的长度，以及数组 b。
如果有多个答案，输出任意一个均可。	输入
4
4 2
1 2 2 1
4 3
1 2 2 1
3 2
1 2 3
4 4
4 3 4 2
输出 
5
1 2 1 2 1
4
1 2 2 1
-1
7
4 3 2 1 4 3 2	1400	https://codeforces.com/contest/1348/submission/127732185

相关题目：上周六双周赛第三题

突破口在 1e4，构造一个长为 k 的循环节，这个循环节要包含 a 中所有数字。把循环节重复 n 次得到 b，这样可以保证 a 是 b 的一个子序列，且长度至多 n*k 不会超过 1e4。
例如 a=[2,2,3,3]，k=3，构造循环节 [2,3,1]（a 去重，如果不足 k 个，补上 1），重复 4 次得到 [2,3,1,2,3,1,2,3,1,2,3,1]。
如果 a 去重后，元素个数大于 k，则输出 -1。		
2023年3月31日	https://codeforces.com/problemset/problem/1365/F

输入 t(≤500) 表示 t 组数据。
每组数据输入 n(≤500) 和两个长为 n 的数组 a b，元素范围在 [1,1e9]。

你可以执行如下操作任意次：
首先选择一个在 [1,n/2] 范围内的整数 k，然后交换 a 的长为 k 的前缀与长为 k 的后缀。
例如 [1,2,3,4,5,6] k=2 交换后为 [5,6,3,4,1,2]
a 能否变成 b？输出 Yes 或 No。

进阶：如果可以做到，用 3n/2 次操作完成。	输入
5
2
1 2
2 1
3
1 2 3
1 2 3
3
1 2 4
1 3 4
4
1 2 3 2
3 1 2 2
3
1 2 3
1 3 2
输出 
Yes
Yes
No
Yes
No	2100	https://codeforces.com/problemset/submission/1365/199894156

提示 1：操作不会改变什么性质？

提示 2：如果两个数 x y 在交换前关于 n/2 对称，那么交换后也是对称的（即便位置变了）
简单证明：x 向右移动距离 = y 向左移动距离（任意被交换的元素移动距离都是相等的）
统计 a 中对称位置组成的数对及其个数，b 中对称位置组成的数对及其个数。
如果所有个数都相同，则方案存在。（注意 n 为奇数时 a[n/2] 需要等于 b[n/2]）

具体可以从内向外构造
例如 abczyx 变成 xcybza，可以先从最内部的 yb 开始。
abczyx -> yxczab -> bxczay -> zaybxc
k 分别是 2,1,3（把 y 和 b 移动到最外侧，然后交换到内侧）

然后解决 cz，k=2 即可：
zaybxc -> xcybza		
2023年3月30日	https://codeforces.com/contest/988/problem/D

输入 n(≤1e5) 和长为 n 的整数数组 a(-1e9≤a[i]≤1e9)，没有相同元素。

从 a 中选择尽量多的数，组成集合 b，要求 b 中任意两个数的差的绝对值都是 2 的幂次。
输出 b 的大小以及 b 中的每个数。（没有顺序要求，多解输出任意一解）	输入
6
3 5 4 7 10 12
输出 
3
7 3 5

输入
5
-1 2 5 8 11
输出 
1
8	1800	https://codeforces.com/contest/988/submission/171194913

如果选两个数 x<y，那么枚举 k 寻找 y-x=2^k，做法类似两数之和。

如果选三个数 x<y<z，那么必须有 y-x=z-y=2^k，否则 z-x 不是 2 的幂次。做法同 2367. 算术三元组的数目

选四个是无法做到的，根据上面可知必须是等差数列，但这样最大-最小是 3*2^k，也不是 2 的幂次。
那么选大于四个数就更不可能了，因为相当于在四个数的基础上多了一个数，四个数不行就更别说大于四个数了。		
2023年3月29日	https://codeforces.com/problemset/problem/382/C

输入 n(1≤n≤1e5) 和长为 n 的整数数组 a(1≤a[i]≤1e8)。

请你往 a 中添加恰好一个整数 x，使得 a 排序后是一个等差数列。
输出所有满足要求的 x 的个数，以及这些 x（按升序输出）。
如果满足要求的 x 有无穷多个，输出 -1。

【易错题】	输入
3
4 1 7
输出 
2
-2 10

输入
1
10
输出 
-1

输入
4
1 3 5 9
输出 
1
7

输入
4
4 3 4 5
输出 
0

输入
2
2 4
输出 
3
0 3 6	1700	https://codeforces.com/problemset/submission/382/199610473

分类讨论，样例基本上把所有情况都列出来了，具体见代码注释。	分类讨论	
2023年3月28日	https://codeforces.com/contest/1622/problem/C

输入 t(≤1e4) 表示 t 组数据。所有数据的 n 之和 ≤2e5。
每组数据输入 n(≤2e5) k(1≤k≤1e15) 和长为 n 的数组 a(1≤a[i]≤1e9)。

每次操作，选择一个 a[i]，要么把 a[i] 变成 a[i]-1，要么变成另外一个 a[j]。
要使 sum(a) <= k，至少需要操作多少次？

注意可以把 a[i] 减成负数。	输入
4
1 10
20
2 69
6 9
7 8
1 2 1 3 1 2 1
10 1
1 2 3 1 2 6 1 6 8 10
输出 
10
0
2
7	1600	https://codeforces.com/contest/1622/submission/155250743

提示 1：对于减一操作来说，把两个数减一，把一个数减二，都需要操作两次。
考虑到一个数更小，越有利于修改操作（把 a[i] 变成 a[j]），
所以减一操作只需要在 a 中最小的数上进行。

提示 2：先减一，再修改。

提示 3-1：修改最大的若干个数，变成最小的数。

提示 3-2：枚举修改了最大的 0/1/2/3/... 个数，可以反推要执行多少次减一操作。		
2023年3月27日	https://codeforces.com/problemset/problem/1535/C

输入 t(≤1e4) 表示 t 组数据。所有数据的字符串长度之和 ≤2e5。
每组数据输入一个长度不超过 2e5 的字符串 s，仅包含 '0' '1' '?' 三种字符。

定义灵茶字符串为：把字符串中的每个 ? 都改成 0 或者 1（每个 ? 怎么改是独立的），可以使字符串变成 0101... 或者 1010... 这样的 01 交替字符串。
例如 0，0??10，??? 都是灵茶字符串，而 00，?1??1 不是。
输出 s 中有多少个子串是灵茶字符串。

注：子串是连续的。	输入
3
0?10
???
?10??1100
输出 
8
6
25	1400	https://codeforces.com/problemset/submission/1535/199246246

提示 1：
从左到右遍历 s。
由于 ? 怎么变都可以，重点应该放在值为 0 或 1 的 s[i] 上。
你也可以思考在没有 ? 的情况下，这题要怎么做。

提示 2：
假设 s[i] 是灵茶子串的末尾字符，那么灵茶子串的起始位置最远能到哪？
例如 s = "01101"，如果 s[4] 是灵茶子串的末尾字符，起始位置最远可以到 s[2]。
那么 s[2]~s[4], s[3]~s[4], s[4]~s[4] 这三个都是灵茶子串。
如何记录这样的起始位置呢？

提示 3：
如果没有 ?，上一个 s[i] == s[i-1] 的 i 就是起始位置。
但是由于 ? 的存在，无法判断相邻字符。如何解决？
尝试从 i 和 s[i] 的自身关系去思考，不再依赖其余位置。

提示 4：
定义 pos[0] 为上一个 i 和 s[i] 奇偶性相同的 i，
定义 pos[1] 为上一个 i 和 s[i] 奇偶性不同的 i。
（这里 s[i] != '?'）
例如 s = "01101"，遍历到 s[4] 时，pos[0] = 1，pos[1] = 4

按照 pos 的定义，min(pos[0], pos[1]) + 1 就是起始位置了。
i-min(pos[0], pos[1]) 就是末尾字符为 s[i] 的灵茶子串个数了。
累加 i-min(pos[0], pos[1]) 就是答案。

为方便计算，初始化 pos[0] = pos[1] = -1		
2023年3月24日	https://codeforces.com/contest/1626/problem/D

输入 t(≤1e4) 表示 t 组数据。所有数据的 n 之和 ≤2e5。
每组数据输入 n(≤2e5) 和长为 n 的数组 a(1≤a[i]≤n)。

你需要选择两个整数 x y (x<y)，把 a 中小于 x 的数分为一组，大于等于 y 的分为一组，其余的分为一组，一共三组。
对每一组，如果组的大小不是 2 的幂次，则增加到最近的 2 的幂次，花费为增量。比如 5 补齐到 8，花费为 8-5=3。如果已经是 2 的幂次，则花费为 0。
计算花费之和的最小值。	输入
4
4
3 1 2 1
1
1
6
2 2 2 1 1 1
8
6 3 6 3 6 3 6 6
输出 
0
2
3
2	2100	https://codeforces.com/contest/1626/submission/198620816

提示 1：如果只有两个组，要如何快速枚举？

提示 2：假设第一个组的大小可以是 3 5 6 9 10，那么只需要枚举 3 6 10 这些离 2^k 最近的数。
反证法：假设选的不是离 2^k 最近的数（比如不选 6 选 5），第一个组的花费会变大，另外一个组的花费要么同等变小，要么越过了 2^k 变得更大。所以只需要贪心枚举离 2^k 最近的数。

提示 3：统计 cnt，求 cnt 的前缀和，然后枚举第三个组的大小，转换成两个组的问题。然后枚举并在前缀和上二分查找 2^k，作为第一个组的大小。		
2023年3月23日	https://codeforces.com/problemset/problem/1624/E

输入 t(≤1e4) 表示 t 组数据。所有数据的 n*m 之和 ≤1e6。
每组数据输入 n(≤1e3) m(≤1e3) 和长为 n 的字符串数组 a。
然后再输入一个字符串 s。
所有字符串长度均为 m，仅包含 '0'~'9'。

你需要将 s 划分成若干个长度至少为 2 的子串，且每个子串都是某个 a[i] 的子串（不同子串对应的 a[i] 可以不同）。
如果无法划分，输出 -1；否则输出划分出的子串个数 k，然后输出 k 行，每行三个数字 l r i，表示这个子串等于 a[i] 的子串 [l,r]。注意 l r i 的下标均从 1 开始。注意输出的 k 行要与划分的顺序相同。
如果有多种划分方案，输出任意一种。	输入
5

4 8
12340219
20215601
56782022
12300678
12345678

2 3
134
126
123

1 4
1210
1221

4 3
251
064
859
957
054

4 7
7968636
9486033
4614224
5454197
9482268
输出 
3
1 4 1
5 6 2
3 4 3
-1
2
1 2 1
2 3 1
-1
3
1 3 2
5 6 3
3 4 1	2000	https://codeforces.com/contest/1624/submission/198571126

提示 1：任意 >=4 的数字都可以拆分为若干 2 和 3 的和。

提示 2：预处理所有长为 2 和 3 的子串及其位置。

提示 3：线性 DP，定义 f[i] 表示能否拆分 s[:i]，那么 f[i] 从 f[i-2] 或 f[i-3] 转移，需要看末尾能拆出 2 个字符还是 3 个字符。
f[0]=true，答案为 f[n]。

由于要输出具体方案，转移时可以记录转移来源，也可以像我代码中那样再算一次从哪转移来的。

相似题目：https://leetcode.cn/problems/check-if-there-is-a-valid-partition-for-the-array/		
2023年3月22日	https://codeforces.com/problemset/problem/1181/C

输入 n(≤1e3) m(≤1e3) 和一个 n 行 m 列的字符矩阵，元素都是小写字母。

定义「国旗」为一个 3h 行的子矩阵，前 h 行的字符都相同，中间 h 行的字符都相同，后 h 行的字符都相同，它们分别记作 A B C，要求 A 和 B 的字符不同，B 和 C 的字符不同（A 和 C 无要求）。
输出是国旗的子矩阵数量。	输入
4 3
aaa
bbb
ccb
ddd
输出 
6
解释 见右图

输入
6 1
a
a
b
b
c
c
输出 
1	1900	https://codeforces.com/contest/1181/submission/198473717

提示 1：枚举子矩阵的右边界（第 j 列）。

提示 2：枚举第 j 列的连续三种字符。
比如这一列从上到下是 aabbbbcccddcc，那么压缩成 abcdc，枚举 abc bcd cdc，这一列上的国旗只会有这三种情况。

提示 3：需要知道从 (i,j) 往左连续出现了多少个相同字符，记作 f[i][j]，这可以递推预处理，或者一边遍历一边算。
这个国旗的最远左边界就是 f[i][j] 的最小值。从最远左边界到 j 都可以作为国旗的左边界，贡献答案。		
2023年3月21日	https://codeforces.com/problemset/problem/1325/D

输入 u 和 v，范围均在 [0,1e18]。

构造一个长度最短的数组，满足异或和等于 u，和等于 v。
如果无法构造，输出 -1，否则输出数组长度和任意满足要求的数组。	输入
2 4
输出
2
3 1
解释：3^1=2, 3+1=4

输入
1 3
输出
3
1 1 1

输入
8 5
输出
-1

输入
0 0
输出
0	1700	https://codeforces.com/contest/1325/submission/97080317

提示 1：u <= v

提示 2：如果 u 是奇数，那么必然有奇数个奇数，所以 v 也是奇数；同理，偶数……
所以 v-u 必须是偶数

提示 3：设 x = (v-u)/2，那么构造数组 [u,x,x]，其异或和为 u，元素和为 2x+u = v
这说明数组长度至多为 3。
什么时候数组长度为 2？也就是说，找到两个数 a b 满足 a^b=u，a+b=v。

提示 4-1：你能得到 | ^ & + 这些运算的关系吗？

提示 4-2：
a|b = (a^b) + (a&b)    类比集合论
a+b = (a|b) + (a&b)    类比加法器
联立得
a+b = (a&b)*2 + (a^b)

提示 5-1：x = a&b

提示 5-2：
如果 u&x = 0，那么直接把 x 放到 u 里面，数组为 [u|x, x] 
如果 u&x ≠ 0，说明有个比特位都是 1，但是 p^q=1 和 p&q=1 不能同时成立，所以此时无法构造长为 2 的数组。		
2023年3月20日	https://codeforces.com/problemset/problem/1157/E

输入 n(≤2e5) 和两个长为 n 的数组 a b，元素范围在 [0,n-1]。

你可以重排数组 b。
还有一个长为 n 的数组 c，其中 c[i] = (a[i] + b[i]) % n。
输出字典序最小的 c。	输入
4
0 1 2 1
3 2 1 1
输出
1 0 0 2 

输入
7
2 5 1 5 3 4 3
2 4 3 5 6 5 1
输出
0 0 0 1 0 2 4 	1700	https://codeforces.com/contest/1157/submission/198294259

对于 a[i]，需要去找 (n-a[i])%n，如果不存在就找更大的，如果找到 n-1 都没有，就从 0 开始找。

这样做是暴力的，有多种优化方法：

- 类似 multiset 这样的平衡树，只维护存在的
- 并查集，如果 x 不存在，则把 x 和 x+1 合并，这样可以快速找到下一个存在的。		
2023年3月17日	https://codeforces.com/problemset/problem/118/C

输入 n k(2≤k≤n≤1e4) 和长为 n 的字符串 s，仅包含 '0'~'9'。

每次操作你可以把一个 s[i] 修改成任意 '0'~'9'，假设修改成 b，则花费为 abs(s[i]-b)。
要使 s 中至少有 k 个相同字符，求最小总花费。
同时，你需要在总花费最小的前提下，让修改后的 s 的字典序尽量小。
输出最小总花费以及修改后的 s。

思考：如果把 s 换成一个值域范围更大的整数数组，你能想出一个更优的做法吗？	输入
6 5
898196
输出
4
888188

输入
3 2
533
输出
0
533

输入
10 6
0001112223
输出
3
0000002223	1900	https://codeforces.com/contest/118/submission/197621784

枚举+贪心。

枚举修改后有 k 个 0/1/2/.../9。取花费最小且字典序最小的为答案。

比如修改成 4，那么从近到远依次考虑，修改 53627189 成 4。（注意先改 5 再改 3）
为了让字典序尽量小：
比 4 大的数字，从左到右修改。
比 4 小的数字，从右到左修改。		
2023年3月16日	https://codeforces.com/problemset/problem/1054/D

输入正整数 n(≤2e5) k(≤30) 和长为 n 的数组 a(0≤a[i]≤pow(2,k)-1)。

设 mask = (1<<k)-1，每次操作你可以把任意 a[i] 修改为 a[i] XOR mask，你可以操作任意次（包括 0 次）。
修改后，最多有多少个 a 的非空连续子数组，其异或和不等于 0？	输入
3 2
1 3 0
输出 5

输入
6 3
1 4 4 7 3 4
输出 19	1900	https://www.luogu.com.cn/blog/endlesscheng/solution-cf1054d

我的题解（一步步提示） 👆		
2023年3月15日	https://codeforces.com/problemset/problem/687/C

输入正整数 n(≤500) k(≤500) 和长为 n 的数组 c(1≤c[i]≤500)。

从 c 中选择若干个数，组成数组 A，满足 sum(A) = k。
从 A 中再选择若干个数，组成数组 B（可以为空）。
你需要计算 sum(B) 的所有可能的值。
输出这些值的个数 q，然后按升序输出这 q 个数。	输入
6 18
5 6 1 10 12 2
输出
16
0 1 2 3 5 6 7 8 10 11 12 13 15 16 17 18 

输入
3 50
25 25 50
输出
3
0 25 50 	1900	https://codeforces.com/problemset/submission/687/197390629

提示 1：问题转换成，能否从 c 中选出两个不相交的子集，其中一个和为 x，另一个和为 k-x。（求所有 x）

提示 2：相当于一个二维体积的 0-1 背包问题。
每个 c[i] 要么不选，要么放入一种体积，要么放入另一种体积。

所以
f[i][j1][j2] = f[i-1][j1][j2] || f[i-1][j1-c[i]][j2] || f[i-1][j1][j2-c[i]]

代码实现时第一个维度可以优化掉（倒序循环）

答案就是所有 f[x][k-x] 为 true 的 x。		
2023年3月14日	http://codeforces.com/problemset/problem/1156/B

输入 t(≤100) 表示 t 组数据。每组数据输入一个长度不超过 100 的字符串 s，只包含小写字母。

你需要重排 s 中的字母（或者保持 s 不变），使得 abs(s[i]-s[i+1]) != 1，即任意相邻字母在字母表中不相邻。
输出任意一个符合要求的结果，如果不存在，输出 No answer。	输入
4
abcd
gg
codeforces
abaca
输出
cadb
gg
codfoerces
No answer	1800	https://codeforces.com/contest/1156/submission/197311349

提示 1：想想 s 中没有重复字母要怎么做。

提示 2：s 排序后，按照 ASCII 码的奇偶性分组，设为 x 和 y。

提示 3：看看 x+y 或者 y+x 行不行，如果这样都不行就无解。比如 acb，bac 等。		
2023年3月13日	http://codeforces.com/problemset/problem/1304/D

输入 t(≤1e4) 表示 t 组数据。所有数据的 n 之和 ≤2e5。

每组数据输入 n(2≤n≤2e5) 和长为 n-1 的字符串 s，仅包含 '<' 和 '>'。

s[i]='<' 表示 a[i]<a[i+1]，
s[i]='>' 表示 a[i]>a[i+1]。

请构造两个 1~n 的排列，符合字符串 s，且第一个数组的 LIS 最短，第二个数组的 LIS 最长。
如果有多种构造方案，输出任意一种。

思考题：在这题的基础上，构造长度恰好为 k 的 LIS。

相似题目：https://leetcode.cn/problems/construct-smallest-number-from-di-string/	输入
3
3 <<
7 >><>><
5 >>><
输出
1 2 3
1 2 3
5 4 3 7 2 1 6
4 3 1 7 5 2 6
4 3 2 1 5
5 4 2 1 3	1800	https://codeforces.com/contest/1304/submission/71173824
https://codeforces.com/contest/1304/submission/197174298

for _ in range(int(input())):
    n, s = input().split()
    n = int(n)
    a = [list(range(n, 0, -1)), list(range(1, n + 1))]
    i = 0
    while i < n - 1:
        h = i
        while i < n - 1 and s[i] == s[h]: i += 1
        b = a[s[h] == '>']
        b[h:i + 1] = b[h:i + 1][::-1]
    print(*a[0])
    print(*a[1])

最短：拆分成若干上升段，那么把最大的数字分配给最左边的上升段，剩余的最大数字分配给第二个上升段，依此类推。

最长：拆分成若干下降段，那么把最小的数字分配给最左边的下降段，剩余的最小数字分配给第二个下降段，依此类推。		
2023年3月10日	https://codeforces.com/problemset/problem/1379/C

输入 t(≤1e4) 表示 t 组数据。所有数据的 m 之和 ≤1e5。

每组数据输入 n(≤1e9) m(≤1e5) 表示有 m 种物品，每种物品有无限个，你需要选择 n 个。
然后输入 m 行，每行两个数字 a[i] 和 b[i]，范围在 [0,1e9]。

如果第 i 种物品选 x 个（x>0），收益为 a[i]+(x-1)*b[i]。
输出最大收益。	输入
2
4 3
5 0
1 4
2 2

5 3
5 2
4 2
3 1
输出
14
16	2000	https://codeforces.com/contest/1379/submission/87405052

提示 1：至多有一个物品要选超过 1 个。（反证法：如果有两个，只选 b 更大的那个更优）

提示 2：枚举第 i 个物品选了超过 1 个，那么比 b[i] 大的物品必须选 1 个。

提示 3：对 a 排序，然后二分或者双指针。		
2023年3月9日	https://codeforces.com/problemset/problem/652/D

输入 n(≤2e5) 和 n 个闭区间，区间左右端点范围在 [-1e9,1e9]，所有端点互不相同。

对每个区间，输出它包含多少个其它的区间。	输入
4
1 8
2 3
4 7
5 6
输出
3
0
1
0

输入
3
3 4
1 5
2 6
输出
0
1
1	1800	https://codeforces.com/contest/652/submission/122430936

离散化后，按照右端点排序。

对于每个区间 [left,right]，统计从 left 到 right 之间有多少个其余的左端点。
由于按照右端点排序，这些区间一定能包含。

统计后把 left 加到数据结构中。

可以用树状数组或者名次树维护。		
2023年3月8日	https://codeforces.com/problemset/problem/337/D

输入 n m(1≤m≤n≤1e5) d(0≤d≤n-1) 表示一棵 n 个节点的树，其中 m 个节点有怪物，这些怪物是由一个传送门生成的，传送门与任意怪物的距离不超过 d。
然后输入 m 个互不相同的数，表示怪物所在节点编号（从 1 开始）。
然后输入 n-1 行，每行两个节点编号，表示树的边。

输出可能存在传送门的节点的个数。注意传送门只有一个。	输入
6 2 3
1 2
1 5
2 3
3 4
4 5
5 6
输出 3	2000	https://codeforces.com/contest/337/submission/116580503

换根 DP。

第一次 DFS 以 1 为根，对每个点记录往下走的最远怪物距离和次远怪物距离，以及最远怪物在哪棵子树中。

第二次 DFS，从 v 到 w 时：
如果 w 是 v 的最远怪物所在子树，那么 w 往上的最远怪物距离就是 max(v 往上最远怪物距离, v 往下次远怪物距离)+1；
如果 w 不是 v 的最远怪物所在子树，那么 w 往上的最远怪物距离就是 max(v 往上最远怪物距离, v 往下最远怪物距离)+1。
对于一个点 v，如果 v 往上往下的最远怪物距离都不超过 d，那么 v 就可能是传送门所在位置。		
2023年3月7日	https://codeforces.com/problemset/problem/148/E

输入 n(≤100) m(≤1e4) 和 n 个双端队列（dq），对于每个 dq，先输入 k(≤100) 表示 dq 的大小，然后输入 dq 中的 k 个数，范围在 [1,100]。所有 k 之和 ≥m。

你需要从这 n 个 dq 中取出 m 个数，输出这 m 个数的和的最大值。

提示：1e8 可过。	输入
2 3
3 3 7 2
3 4 1 5
输出 15

输入
1 3
4 4 3 1 2
输出 9	1900	https://codeforces.com/problemset/submission/148/196263614

看成分组背包。周赛 t4 讲过了。

每个 dq 就是一个组，需要计算在这个 dq 中选 x 个数的最大数字和。

这可以用前缀和+枚举预处理。		
2023年3月6日	https://codeforces.com/problemset/problem/219/D

输入 n(2≤n≤2e5) 和 n-1 条边 v w，表示一条 v->w 的有向边。（节点编号从 1 开始）
保证输入构成一棵树。

你可以把边反向，即 v->w 改成 w->v。
定义 f(x) 表示以 x 为根时，要让 x 能够到达任意点，需要反向的边的数量。
输出 min(f(x))，以及所有等于 min(f(x)) 的节点编号（按升序输出）。

2023.9.16 押题成功！ https://leetcode.cn/contest/biweekly-contest-113/problems/minimum-edge-reversals-so-every-node-is-reachable/	输入
3
2 1
2 3
输出
0
2 

输入
4
1 4
2 4
3 4
输出
2
1 2 3 	1700	https://codeforces.com/contest/219/submission/196143678

和双周赛 t4 一样，换根 DP。

先把以 1 为根的答案求出来。

从 v 换到 w 时，如果有 v->w，那么答案加一，否则答案减一。		
2023年3月3日	https://codeforces.com/contest/1525/problem/D

输入 n(≤5000) 和长为 n 的数组 a，其中只有 0 和 1。保证 1 的数量不超过 n/2。
a[i]=0 表示位置 i 处有一把椅子，a[i]=1 表示位置 i 处有一个人。

一把椅子只能坐一个人。
一个人从 i 移动到 j 的耗时为 abs(i-j)。
问所有人都坐到椅子上，所有人的耗时之和最小是多少？	输入
7
1 0 0 1 0 0 1
输出 3

输入
6
1 1 1 0 0 0
输出 9	1800	https://codeforces.com/contest/1525/submission/195527208

提示 1：贪心地想，最后一个人坐的椅子一定在其它人的右边（如果不是这样，交叉移动是不会更优的）。

提示 2：统计椅子和人的坐标。考虑前 i 把椅子坐前 j 个人的最小耗时和，记作 f[i][j]。

提示 3：第 i 把椅子不选，f[i-1][j]；选，f[i-1][j-1] + abs(chair[i]-people[j])
因此 f[i][j] = min(f[i-1][j], f[i-1][j-1] + abs(chair[i]-people[j]))

注意可以像 0-1 背包那样空间优化+倒序遍历。		
2023年3月2日	https://codeforces.com/problemset/problem/1554/C

输入 t(≤3e4) 表示 t 组数据，每组数据输入两个整数 n 和 m，均在 [0,1e9] 范围内。

定义数组 a = [n xor 0, n xor 1, n xor 2, ..., n xor m]。
输出不在 a 中的最小非负整数。	输入
5
3 5
4 6
3 2
69 696
123456 654321
输出
4
3
0
640
530866	1800	https://codeforces.com/contest/1554/submission/164112524

提示 1：把答案记作 mex，把所有 a[i] 和 mex 都异或上 n，
那么 n xor mex 不能在 [0,1,2,...,m] 中，也就是 n xor mex >= m+1。

提示 2：从高到低考虑 mex 的每一位。

提示 3：如果 n 这一位是 0，m+1 这一位是 1，那么 mex 这一位一定要是 1。
如果 n 这一位是 1，m+1 这一位是 0，那么 mex 这一位可以是 0，此时 n xor mex 是 1，已经大于 m+1 了，退出循环。其余情况 mex 可以是 0，但是不能退出循环。		
2023年3月1日	https://codeforces.com/problemset/problem/1552/D

输入 t(≤20) 表示 t 组数据，每组数据输入 n(≤10) 和长为 n 的数组 a(-1e5≤a[i]≤1e5)。

如果存在一个长为 n 的数组 b，对于任意 i，都存在 j 和 k，使得 a[i]=b[j]-b[k]，则输出 YES，否则输出 NO。
注意 j 可以等于 k。	输入
5
5
4 -7 -1 5 10
1
0
3
1 10 100
4
-3 2 10 2
9
25 -171 250 174 152 242 100 -205 -258
输出
YES
YES
NO
YES
YES	1800	https://www.luogu.com.cn/blog/endlesscheng/solution-cf1552d

题解👆		
2023年2月28日	https://codeforces.com/problemset/problem/388/B

输入 k(1≤k≤1e9)。
构造一个节点个数不超过 1000 的简单无向图（节点编号从 1 开始），使得从节点 1 到节点 2 的最短路径的数量恰好为 k。
输出 n 以及一个 n*n 的邻接矩阵 g，如果 i 和 j 之间有边，则 g[i][j]='Y'，否则为 'N'。
注意不能有自环，即 g[i][i] 必须为 'N'。

进阶：请最小化 n。

注：这个构造方案可以用来 hack 一些用方案数取模来做连通性判定的代码。	输入
2
输出
4
NNYY
NNYY
YYNN
YYNN

输入
9
输出
8
NNYYYNNN
NNNNNYYY
YNNNNYYY
YNNNNYYY
YNNNNYYY
NYYYYNNN
NYYYYNNN
NYYYYNNN	1900	https://codeforces.com/problemset/submission/388/195218387

提示 1：尝试构造 k=2/4/8/16/...

提示 2：把其中一些构造方案「组合」起来，每个方案构成 k 的二进制分解中的一个 1。

提示 3：如果你使用了超过 1000 个节点，尝试复用。

构造方案如右图 (k=7)，使用了 5m 个节点，m 是 k 的二进制长度。

群友的其它方案也补上了。（大约是 3m）		
2023年2月27日	https://codeforces.com/problemset/problem/1659/D

输入 t(≤1000) 表示 t 组数据，每组数据输入 n(≤2e5) 和长为 n 的数组 c(0≤c[i]≤n)。
所有数据的 n 之和不超过 2e5。

对于只有 0 和 1 的数组 a，定义 b[i] 为把 a 的前 i 个元素从小到大排序后的新数组（下标从 1 开始）。
定义 c[j] = b[1][j] + b[2][j] + ... + b[n][j]。
现在数组 c 输入给你了，请你构造任意一个符合要求的数组 a。输入保证数组 a 存在。

*本题做法不止一种，欢迎在群内交流。	输入
5
4
2 4 2 4
7
0 3 4 2 3 2 7
3
0 0 0
4
0 0 0 4
3
1 2 3
输出
1 1 0 1 
0 1 1 0 0 0 1 
0 0 0 
0 0 0 1 
1 0 1 	1900	https://codeforces.com/problemset/submission/1659/195082636

提示 1：从特殊到一般，思考 a 中只有一个 1 时，数组 c 会是什么样的。你可以从这个 1 在末尾开始思考。

看到不变量了吗？

提示 2：a 中 1 的数量等于 sum(c)/n，记作 k。

提示 3：试试倒着构造 a。

提示 4：假设 c[n]=n，此时 a[n]=1。
为了把问题转换成 n-1 个数的问题，需要从 c 中去掉 b[n] 带来的影响。如何去掉？
由于 b[n] 是一个末尾有 k 个 1 的数组，所以把 c 中的 [n-k+1,n] 都减一即可。
用差分数组/树状数组/线段树实现。
继续思考，注意每次都需要把 b[i] 带来的影响去掉。		
2023年2月24日	https://codeforces.com/problemset/problem/708/B

对于 01 字符串 s，定义 f(x,y) 表示子序列 [x,y] 在 s 中的出现次数。
输入 f(0,0), f(0,1), f(1,0) 和 f(1,1)，范围在 [0,1e9]。
请构造任意一个满足输入的非空字符串 s。
如果不存在，输出 Impossible。
注：子序列是从 s 中删除某些元素得到的。

可能是道易错题	输入 1 2 3 4
输出 Impossible

输入 1 2 2 1
输出 0110	1900	https://codeforces.com/contest/708/submission/194669010

提示 1：根据 f(0,0) 可以求出 0 的个数 c0，因为 f(0,0) = C(c0,2)；同理可求出 1 的个数 c1。

提示 2：f(0,1) + f(1,0) = c0 * c1		
2023年2月23日	https://codeforces.com/problemset/problem/1179/B

输入 n m (n*m≤1e6)，表示一个 n 行 m 列的棋盘，行列编号从 1 开始。
初始时，你在 (1,1)。每一步，你可以使用一个方向向量 (dx,dy)，然后从当前位置 (x,y) 移动到 (x+dx,y+dy)。
你需要访问每个格子恰好一次，且每一步使用的方向向量互不相同。
如果存在这样的移动方案，输出任意一组符合要求的 n*m 个坐标，表示你每一步所在的位置。否则输出 -1。	输入
2 3
输出
1 1
1 3
1 2
2 2
2 3
2 1

输入
1 1
输出
1 1	1800	https://codeforces.com/contest/1179/submission/108111481

提示 1：方案一定存在。

提示 2：从左上角跳到右下角，这个方向向量以后绝不会再用到了。

提示 3：然后再从右下角跳到 (1,2)，这个方向向量以后也绝不会再用到了。		
2023年2月22日	https://codeforces.com/problemset/problem/584/C

输入 n t(0≤t≤n≤1e5) 和两个长度均为 n 的字符串 s1 和 s2，均由小写字母组成。

定义 f(a,b) 表示 a[i]!=b[i] 的下标数量。
构造一个长为 n 的，由小写字母组成的字符串 s3，使得 f(s1,s3)=f(s2,s3)=t。
如果无法构造，输出 -1。	输入
3 2
abc
xyc
输出
ayd

输入
1 0
c
b
输出
-1	1700	https://codeforces.com/contest/584/submission/194532015

先算出 f(s1,s2)，记作 d。
把 s3 初始化成：如果 s1[i]=s2[i]，则 s3[i] = s1[i]，否则 s3[i] 是一个和 s1[i] 和 s2[i] 都不一样的字母。

如果 d<t，说明还需要整点不一样的，从 s1[i]=s2[i] 里面找。
如果 d>t，说明整多了，从 s1[i]!=s2[i] 里面恢复，每个 d 要改两个 s3[i]，一个等于 s1[i]，一个等于 s2[j]

具体的技巧见代码。		
2023年2月21日	https://codeforces.com/problemset/problem/5/C

输入括号字符串 s，长度不超过 1e6。

输出 s 的最长合法括号子串的长度和数量。
如果不存在，输出 0 1。	输入 )((())))(()())
输出 6 2

输入 ))(
输出 0 1	1900	https://leetcode.cn/problems/longest-valid-parentheses/solution/zui-chang-you-xiao-gua-hao-by-leetcode-solution/

方法三的基础上额外套一个计数器。		
2023年2月20日	https://codeforces.com/problemset/problem/600/C

输入字符串 s，长度不超过 2e5，由小写字母组成。

你可以修改多个 s[i]，使得修改后的 s，通过重新排列，可以得到回文串。
设最少修改 x 次。输出修改 x 次且重排后字典序最小的回文串。	输入 aabc
输出 abba

输入 aabcd
输出 abcba	1800	https://codeforces.com/contest/600/submission/97136757

提示 1：修改出现次数为奇数的字符。

提示 2：为了让字典序尽量小，这些奇数字母也要对应匹配。设 adef 出现了奇数次，那么把 f 改成 a，e 改成 d。 

提示 3：注意有奇数个奇数的情况，此时回文中心是不需要修改的。		
2023年2月17日	
https://codeforces.com/problemset/problem/1272/E

输入 n(≤2e5) 和长为 n 的数组 a(1≤a[i]≤n)，下标从 1 开始。

从位置 i，你可以移动到位置 i-a[i] 或者 i+a[i]，移动后的位置必须在 [1,n] 内。
定义 d(i) 表示从位置 i 出发，移动到某个位置 j 的最小移动次数，要求 a[i] 和 a[j] 的奇偶性不同。如果不存在这样的 j，则 d(i) 为 -1。
输出 d(1),d(2),...,d(n)。	输入
10
4 5 7 6 7 5 4 4 6 4
输出
1 1 1 2 -1 1 1 3 1 1 	1900	https://codeforces.com/contest/1272/submission/193830507

提示 1：从起点出发不好计算的话，试试从终点出发反着走。

提示 2：以偶数为例，定义终点为能直接到达奇数的位置。
从终点出发，在反图上 BFS。
反图怎么建？如果存在 v->w 的边，则建一条 w->v 的边。

偶数奇数各跑一次 BFS。		
2023年2月16日	https://codeforces.com/problemset/problem/1095/E

输入 n(≤1e6) 和长为 n 的括号字符串 s。

你必须执行如下操作恰好一次：
选择一个下标 i，如果 s[i] 是 ')'，则修改为 '('，反之亦然。

有多少个不同的 i，可以使 s 是一个合法的括号字符串？

思考：如果可以改两个 s[i] 呢？	输入
6
(((())
输出 3

输入
6
()()()
输出 0

输入
1
)
输出 0

输入
8
)))(((((
输出 0	1900	https://codeforces.com/contest/1095/submission/193708110

记 c 为 s 的平衡度，遇到 '(' 就 +1，遇到 ')' 就 -1。

中途 c 不能小于 -2。最后 abs(c) 必须为 2。

分类讨论：
如果 c 为 -2，那么要改 ')'，且只能修改从开头到第一次 c=-1 这一段的 )。
如果 c 为 2，那么要改 '('，那么 c 在任何时候都不能小于 0。倒着遍历 s，统计 c > 1 时的 '('，因为一旦 c<=1 了，改成 ')' 肯定不能得到合法括号字符串了。（其实示例一是一个挺好的提示）		
2023年2月15日	https://codeforces.com/problemset/problem/1213/D2

输入 n k (1≤k≤n≤2e5) 和长为 n 的数组 a(1≤a[i]≤2e5)。

每次操作你可以让一个 a[i] 变为 floor(a[i]/2)。
要想得到至少 k 个相同的数，最少需要多少次操作？

进阶：你能想出一个时间复杂度为 O(max(a)) 的做法吗？	输入
5 3
1 2 2 4 5
输出 1

输入
5 3
1 2 3 4 5
输出 2

输入
5 3
1 2 3 3 3
输出 0	1600	https://codeforces.com/contest/1213/submission/193430181

设 U=max(a)。
O(Ulog^2U) 或者 O(UlogU) 的做法是把每个 a[i] 变成 a[i]/2^j 的次数 j 存到 x=a[i]/2^j 里面。每个 x 都有一个列表去存储次数 j。
然后对每个 1~U 的数 x，累加列表中最小的 k 个次数，最小的和就是答案。

O(U) 的做法是从 U~1 倒着考虑数 x，每个 x 都有一个列表，列表的第 j 项记录有多少个数可以通过操作 j 次变为 x。
如果无法得到到 k 个 x，那么就把这个列表左边插入个 0，然后合并到 x/2 的列表中。
时间复杂度看上去是 O(UlogU)，但是 x 越大，列表的长度越短，仔细计算可以得到所有列表长度之和其实是 O(U) 的。		
2023年2月14日	https://codeforces.com/contest/1374/problem/E1

输入 n k (1≤k≤n≤2e5)，表示有 n 本书，然后输入 n 行，每行输入 t(1≤t≤1e4) a b，其中 a=0/1 表示 A 不喜欢/喜欢这本书，b=0/1 表示 B 不喜欢/喜欢这本书。

你需要选择一些书，使得其中至少有 k 本是 A 喜欢的，至少有 k 本是 B 喜欢的。
如果无法满足输出 -1，否则输出所选书的 t 之和的最小值。

进阶：如果要选恰好 m 本书呢？	输入
8 4
7 1 1
2 1 1
4 0 1
8 1 1
1 0 1
1 1 1
1 0 1
3 0 0
输出 18	1600
进阶 2500	https://codeforces.com/contest/1374/submission/193557671

提示：枚举有 x 本书是两个人都喜欢的。
剩下的就是选 k-x 本只有 A 喜欢的，k-x 本只有 B 喜欢的。
排序后用双指针加速计算。	https://codeforces.com/contest/1374/submission/193671570	
2023年2月13日	https://codeforces.com/contest/1324/problem/E

输入 n(≤2000) h L R (0≤L≤R<h≤2000) 和长为 n 的数组 a(1≤a[i]<h)。

对于每个 a[i]，你可以把它减一，或者保持不变（换句话说，每个 a[i] 至多 -1 一次）。
定义前缀和 s[0]=a[0], s[i]=s[i-1]+a[i]。
如果 s[i]%h 落在闭区间 [L,R] 内，则分数加一。
最大化分数。	输入
7 24 21 23
16 17 14 20 20 11 22
输出 3	1700	https://codeforces.com/contest/1324/submission/193356533
https://codeforces.com/contest/1324/submission/193357512
https://codeforces.com/contest/1324/submission/193357666

我在 https://www.bilibili.com/video/BV1Xj411K7oF/ 中讲了，先把记忆化搜索写出来，再转成递推是最容易的。

那么定义 dfs(i,s)，i 表示当前在 a[i]，s 表示前面累计的和，返回最大分数。
那么 dfs(i,s) = max(dfs(i+1,(s+a[i])%h),dfs(i+1,(s+a[i]-1)%h)) + (l<=s<=r)
具体细节见代码（包含记忆化搜索、递推、空间优化）。		
2023年2月10日	https://codeforces.com/problemset/problem/1361/B

输入 t(≤1e5) 表示 t 组数据，每组数据输入 n(≤1e6) p(1≤p≤1e6) 和长为 n 的数组 k(0≤k[i]≤1e6)。所有数据的 n 之和不超过 1e6。

从这 n 个数中选出若干个数（可以为空）组成一组，剩余的数组成另一组。
每组计算 pow(p,k[i]) 之和。
输出这两个和的差值的最小值，对结果模 1e9+7。	输入
4
5 2
2 3 4 4 3
3 1
2 10 1000
4 5
0 1 1 100
1 8
89
输出
4
1
146981438
747093407	1900	https://codeforces.com/contest/1361/submission/192575286

提示：从大到小遍历 k，栈，消消乐

例如 p=3，k=[4,3,3,2,2,1,1,1]，第一个 4 放一组，剩余的放另一组。在遍历的时候为了判断能否抵消，需要用到栈来统计 k[i] 及其出现次数，如果凑齐 p 个，那么就可以合成一个更大的 k。

为什么一定可以消除？因为小的 p**k 一定是大的 p**k 的因子。		
2023年2月9日	https://codeforces.com/problemset/problem/1141/F2

输入 n(≤1500) 和长为 n 的数组 a(-1e5≤a[i]≤1e5)，下标从 1 开始。

你需要从 a 中选出尽量多的非空连续子数组，这些子数组不能重叠，且元素和相等。
输出子数组的个数 k，然后输出 k 行，每行两个数表示子数组的左右端点。
可以按任意顺序输出，多种方案可以输出任意一种。	输入
7
4 1 2 2 1 5 3
输出
3
7 7
2 3
4 5	1900	https://codeforces.com/contest/1141/submission/192610240

暴力统计每个子数组的和，用哈希表把和相同的子数组左右端点记录下来。
对于每一组，问题变成最多不重叠线段个数。
这是个经典贪心，按照右端点从小到大排序+遍历，一旦遇到左端点大于上一个记录的右端点，答案加一，更新右端点。		
2023年2月8日	https://codeforces.com/contest/1442/problem/A

输入 t(≤3e4) 表示 t 组数据，每组数据输入 n(≤3e4) 和长为 n 的数组 a(1≤a[i]≤1e6)。所有数据的 n 之和不超过 3e4。

每次操作，你可以把 a 的任意一个前缀或后缀的元素都减一。
你能否把所有 a[i] 都变成 0？输出 YES 或 NO。	输入
4
3
1 2 1
5
11 7 9 6 8
5
1 3 1 3 1
4
5 2 1 10
输出
YES
YES
NO
YES	1800	https://codeforces.com/contest/1442/submission/97771793

提示 1：区间加减，用差分数组 d 来思考。
定义 d[0] = a[0]，d[i] = a[i] - a[i-1]。

提示 2：
前缀减一，视作 d[0]-- 和 d[i]++。
后缀减一，视作 d[i]--（和 d[n]++，可以忽略）。
我们需要把 d[i] 都变成 0。

提示 3：
前缀操作用于修改 d[i]<0 的，但是操作次数之和不能超过 d[0]。
后缀操作用于修改 d[i]>0 的，无其他约束。

所以只需要判断「负数 d[i] 的绝对值之和」<= d[0]，满足就是 YES，否则为 NO。		
2023年2月7日	https://atcoder.jp/contests/arc111/tasks/arc111_b

输入 n(≤2e5) 和一个 n 行 2 列的矩阵，矩阵元素范围 [1,4e5]。
从每行中恰好选一个数，你最多能选出多少个不同的数？	输入
4
1 2
1 3
4 2
2 3
输出
4

输入
2
111 111
111 111
输出
1	1334	https://atcoder.jp/contests/arc111/submissions/38552445

把每行的两个数当作图的一条边的两个端点。

对每个连通块分别统计。
如果连通块是树，那么答案是边数。
如果连通块不是树，那么答案是点数。		
2023年2月6日	https://codeforces.com/problemset/problem/1695/C

输入 t(≤1e4) 表示 t 组数据，每组数据输入 n(≤1e3) m(≤1e3) 和一个 n 行 m 列的矩阵，元素值只有 -1 和 1。所有数据的 n*m 之和不超过 1e6。

你从矩阵左上出发，走到右下，每步只能向下或者向右。
路径上的元素和能否为 0？输出 YES 或 NO。	输入
5
1 1
1
1 2
1 -1
1 4
1 -1 1 -1
3 4
1 -1 -1 -1
-1 1 1 -1
1 1 1 -1
3 4
1 -1 1 1
-1 1 -1 1
1 -1 1 1
输出
NO
YES
YES
YES
NO	1700	https://codeforces.com/contest/1695/submission/192354976

提示 1：交换路径中的相邻两步，比如向右向下变成向下向右，路径和会发生什么变化？

路径和会 +0/+2/-2。

因此，如果 n+m 是偶数，路径和必然为奇数，无法变成 0。此时可以直接输出 NO。

如果 n+m 是奇数，路径和必然为偶数，然后要怎么判断？

提示 2：求出最小路径和以及最大路径和，如果一个 <=0，一个 >=0，根据提示 1，可以通过交换，变成 0。

怎么求？这是个经典 DP，见 https://leetcode.cn/problems/minimum-path-sum/

是不是有点双周赛求轮廓的味道了？		
2023年2月3日	https://atcoder.jp/contests/arc119/tasks/arc119_c

输入 n(2≤n≤3e5) 和长为 n 的数组 a(1≤a[i]≤1e9)。

每次操作，你可以选择两个相邻的数字，把它们都加一，或者都减一。
对于 a 的一个连续子数组 b，如果可以通过执行任意多次操作，使 b 的所有元素为 0，则称 b 为好子数组。
输出 a 的好子数组的数量。	输入
5
5 8 8 6 6
输出
3	1354	文字题解：
https://www.luogu.com.cn/blog/endlesscheng/solution-at-arc119-c		
2023年2月2日	https://atcoder.jp/contests/arc148/tasks/arc148_c

输入 n(2≤n≤2e5) q(≤2e5)，然后输入 p2,p3,...,pn 表示一棵根为 1 的树，pi 表示点 i 的父节点。
然后输入 q 个询问，每个询问先输入 m，然后输入 m 个互不相同的特殊节点 v1,v2,...,vm。所有询问的 m 之和不超过 2e5。

每个节点都有一盏灯，其中特殊节点的灯打开，其余节点的灯关闭。
每次操作，你可以选择一棵子树，切换子树内所有灯的开/闭状态。
对每个询问，回答：要使所有灯关闭，至少需要多少次操作。	输入
6 6
1 1 2 2 5
6 1 2 3 4 5 6
3 2 5 6
1 3
3 1 2 3
3 4 5 6
4 2 3 4 5
输出
1
2
1
3
2
3	1488	https://atcoder.jp/contests/arc148/submissions/38529258

提示 1：如果只有一盏灯 v 亮着，要使所有灯关闭，需要操作 v 和 v 的所有儿子，也就是 1 + child[v] 次，其中 child[v] 表示 v 的儿子个数。

提示 2：如果 v 的儿子已经亮着，就不用操作儿子了；同样地，如果 p[v] 已经亮着，就不用操作 v 自己了。		
2023年2月1日	https://atcoder.jp/contests/arc153/tasks/arc153_c

输入 n(1≤n≤2e5) 和长为 n 的数组 a，只包含 -1 和 1。

你需要构造一个严格递增数组 b，元素范围在 [-1e12,1e12]，且 sum(a[i]*b[i]) = 0
如果无法构造，输出 No；否则输出 Yes 和数组 b。	输入
5
-1 1 -1 -1 1
输出
Yes
-3 -1 4 5 7

输入
1
-1
输出
Yes
0

输入
2
1 -1
输出
No	1960	https://atcoder.jp/contests/arc153/submissions/38517162

提示 1：b 的首尾元素受到的约束最小，是最灵活的。

提示 2：如果 a 的首尾元素相同，那么无论中间算出的是多少，都可以通过调整 b 的首尾元素让 sum=0。

提示 3：如果 a 的首尾元素不同，基于提示 2，找 a 的一个前缀和，它与 a 的末尾元素的正负号相同；找 a 的一个后缀和，它与 a[0] 的正负号相同。这样的前缀和/后缀和就能作为一个「整体」，达到和提示 2 一样的效果。
如果不存在，则无法构造。		
2023年1月31日	https://codeforces.com/contest/797/problem/D

输入 n(1≤n≤1e5) 和一棵二叉树的 n 个节点（节点按照输入顺序编号为 1 到 n）。每行输入 x l r，对应节点值 [0,1e9] 和左右儿子的编号，如果没有则为 -1。
输入保证恰好有一个节点没有父节点，即根节点。

如下是一个在二叉搜索树中查找元素的伪代码：
bool find(TreeNode t, int x) {
    if (t == null)
        return false;
    if (t.value == x)
        return true;
    if (x < t.value)
        return find(t.left, x);
    else
        return find(t.right, x);
}
find(root, x);

把二叉树的每个节点值应用上述代码，输出你会得到多少次 false。
注意节点值可能有重复的。	输入
3
15 -1 -1
10 1 3
5 -1 -1
输出 2
解释 5 和 15 是找不到的	2100	https://codeforces.com/contest/797/submission/190439455

考虑有多少个节点值可以找到。
参考 https://www.bilibili.com/video/BV14G411P7C1/ 的方法一，把合法查询范围作为递归参数传下去。
如果节点值 x 在范围内，则有 cnt[x] 个 x 可以找到。

注：用 cnt 是因为有重复的节点，这些节点值都可以找到（即使某些节点无法访问到）。		
2023年1月30日	https://atcoder.jp/contests/abc270/tasks/abc270_e

输入 n(≤1e5) k(≤1e12) 和长为 n 的数组 a(0≤a[i]≤1e12, sum(a)≥k)

有 n 堆苹果顺时针围成一圈，第 i 堆有 a[i] 个苹果。
你从第一堆苹果开始吃，每堆吃了一个苹果后，就顺时针走到下一个还有苹果的堆，重复该过程，直到吃了 k 个苹果。
输出此时每堆剩余苹果数。

你能想出两种不同的做法吗？	输入
3 3
1 3 0
输出
0 1 0 	1211	https://atcoder.jp/contests/abc270/submissions/38448191

方法一：二分 O(nlogk)

二分最多可以完整地吃多少圈。
check 吃 mid 圈，如果吃的苹果超过 k 说明 mid 大了，否则说明 mid 小了。
二分出结果后，最后一圈手动模拟。

方法二：排序 O(nlogn)

想一想，每一圈吃的苹果个数 b，在何时会减少？
不去一圈圈模拟，而是在 b 减少的时候，才去计算又吃了多少苹果。
具体见代码，有注释。		
2023年1月27日	https://codeforces.com/contest/1359/problem/D

输入 n(1≤n≤1e5) 和长为 n 的数组 a(-30≤a[i]≤30)。
设 b 为 a 的一个非空连续子数组。
输出 sum(b)-max(b) 的最大值。	输入
5
5 -2 10 -1 4
输出 6

输入
8
5 2 5 3 -30 -30 6 9
输出 10

输入
3
-10 6 -15
输出 0	2000	https://codeforces.com/contest/1359/submission/95405228

注意值域很小。

枚举 max(b)，把 > max(b) 的去掉，分裂出每个子段都求一遍最大子段和（力扣 53 题）再减去枚举的 max(b)。
所有结果的最大值即为答案。		
2023年1月26日	https://atcoder.jp/contests/arc145/tasks/arc145_a

输入 n(2≤n≤2e5) 和长为 n 的字符串 s，仅包含 'A' 和 'B'。

你可以执行如下操作任意多次：
选择两个相邻字符 s[i] 和 s[i+1]，把 s[i] 替换成 'A'，s[i+1] 替换成 'B'。
能否使 s 变成回文串？输出 Yes 或 No。	输入
3
BBA
输出 Yes
解释 替换后两个字符，得到 BAB

输入
4
ABAB
输出 No	596	https://atcoder.jp/contests/arc145/submissions/38323634

手玩。

操作方法如下：
如果 s[0]='B'，从 s[1] 开始，左到右替换，得到 BAA...AAB。
如果 s[n-1]='A'，从 s[n-2] 开始，右到左替换，得到 ABB...BBA。

那么，只有两种情况无法操作：
s="BA"。
s[0]='A' 且 s[n-1]='B'。		
2023年1月25日	https://codeforces.com/contest/961/problem/D

输入 n(≤1e5) 和 n 个点 (xi,yi)，范围在 [-1e9,1e9]，所有点都是不同的。
你能否画至多两条直线，覆盖所有点？输出 YES 或 NO。	输入
5
0 0
0 1
1 1
1 -1
2 2
输出 YES

输入
5
0 0
1 0
2 1
1 1
2 3
输出 NO	2000	https://codeforces.com/contest/961/submission/190438603

提示 1：如果可以画，那么任意三点中必然有两个点在所画直线上。

提示 2：枚举前三个点中的两个点，确定一条直线，然后看其余点是否在一条直线上。		
2023年1月24日	https://codeforces.com/contest/1661/problem/C

输入 t(≤2e4) 表示 t 组数据，每组数据输入 n(≤3e5) 和长为 n 的数组 h(1≤h[i]≤1e9)，表示 n 棵树的高度。所有数据的 n 之和不超过 3e5。

在第 1,3,5,... 天，你可以把一棵树的高度+1，或者不做任何事。
在第 2,4,6,... 天，你可以把一棵树的高度+2，或者不做任何事。
要使所有树的高度一样，至少要多少天？	输入
3
3
1 2 4
5
4 4 3 5 5
7
2 5 4 8 3 7 4
输出
4
3
16
解释 第一组数据的操作：第一棵树+1，第二棵树+2，跳过，第一棵树+2	1700	https://codeforces.com/contest/1661/submission/190218911

提示 1：最终高度只能是 max(h) 和 max(h)+1，更高的高度只会比这两个的天数多。

提示 2：为什么可以是 max(h)+1？因为两个 1 可以当成 2，而 2 无法当作 1。
例如 h=[1,1,1,1,1,1,2]，max(h) 需要 11 天，而 max(h)+1 需要 9 天。

提示 3：贪心，或者二分答案。二分答案的 check 是需要补奇数的树必须用个+1，其他的随意，所以先用 +1，然后看剩下的能否补到所有高度都一样。

贪心的做法是分类讨论，记 c1 表示需要补奇数高度的树的个数，c2 为每棵树需要补充的高度除以 2 下取整之和：
- 如果 c1>c2，那么需要 c1*2-1 天。
- 如果 c1=c2，那么需要 c2*2 天。
- 如果 c1<c2，例如 12_2_2_2 这种，可以把空出的前两个 1 补到最后一个 2 上，这样只需要 6 天。
总的来说需要研究 _2_2_2... 这种需要多少天，你可以手玩下推出这个长度在模 3=0/1/2 时有不同的结果。
设 d = (c2-c1)*2，那么前面的 1212... 需要 c1*2 天，后面的 _2_2_2... 需要 d/3*2+d%3 天。		
2023年1月23日	https://codeforces.com/problemset/problem/1661/D

输入 n k(k≤n≤3e5) 和长为 n 的数组 b(1≤b[i]≤1e12)。

初始你有一个长为 n 的数组 a，元素都为 0。
每次操作你要选一个长度恰好等于 k 的连续子数组，从左到右，第1个数加1，第2个数加2，……第k个数加k。
要使每个 a[i] >= b[i]，至少需要操作多少次？	输入
3 3
5 4 6
输出
5

输入
6 3
1 2 3 2 2 3
输出
3

输入
6 3
1 2 4 1 2 3
输出
3

输入
7 3
50 17 81 25 42 39 96
输出
92	1900	https://codeforces.com/problemset/submission/1661/190145738

提示 1：倒着思考，这样可以贪心处理每个下标要操作多少次。

提示 2：用差分数组来处理这个等差数列，维护差分的差分。		
2023年1月20日	https://codeforces.com/problemset/problem/1598/D

输入 t(≤5e4) 表示 t 组数据，每组数据输入 n(3≤n≤2e5) 和 n 个点 (xi,yi)，横纵坐标都在 [1,n] 内。没有重复的点。所有数据的 n 之和不超过 2e5。

从 n 个点中选出 3 个点，满足「横坐标互不相同」或者「纵坐标互不相同」。
输出有多少种选择方案。注意选的是组合，(1,2,3) 和 (3,2,1) 算相同的方案。	输入
2
4
2 4
3 4
2 1
1 3
5
1 5
2 4
3 3
4 2
5 1
输出
3
10
解释 第一组数据，你可以选 (1,2,4),(1,3,4),(2,3,4)，数字表示点的编号	1700	https://codeforces.com/problemset/submission/1598/189793851

提示 1：正难则反，考虑哪些不满足要求的选法。

提示 2：如果选了三个横坐标相同的点，由于题目保证没有重复的点，所以三个纵坐标互不相同，这样是满足题目要求的。纵坐标同理，因此我们只能选恰好有两个横坐标相同的点，恰好有两个纵坐标相同的点。

提示 3：这三个点组成了一个 L 型。

提示 4：枚举每个点 (x,y) 作为 L 型的拐点，那么另外有 cntX[x]-1 个横坐标相同的点，cntY[y]-1 个横坐标相同的点。对答案的贡献是 (cntX[x]-1)*(cntY[y]-1)。
答案为 C(n,3) - 这些贡献之和。		
2023年1月19日	https://codeforces.com/problemset/problem/1721/D

输入 t(≤1e4) 表示 t 组数据，每组数据输入 n(≤1e5) 和两个长为 n 的数组 a b，元素范围在 [0,2^30)。所有数据的 n 之和不超过 1e5。

数组 b 可以随意打乱。
输出 (a[1] XOR b[1]) AND (a[2] XOR b[2]) AND ... AND (a[n] XOR b[n]) 的最大值。	输入
3
5
1 0 0 3 3
2 3 2 1 0
3
1 1 1
0 0 3
8
0 1 2 3 4 5 6 7
7 6 5 4 3 2 1 0
输出
2
0
7	1800	https://codeforces.com/contest/1721/submission/189632358

提示 1：从最高位往最低位一位一位思考。

提示 2：a 中的 0 需要和 b 中的 1 匹配，a 中的 1 需要和 b 中的 0 匹配。

提示 3：如果可以匹配，则分组，问题规模缩小，可以用递归来思考更低位的匹配。
但是，如果当前位的任意一个子问题匹配失败，则对于这个位，所有匹配都是无效的（因为算的是 AND）。此时应该跳过这个位上的所有匹配，直接计算下一个更低位的匹配。

提示 4：用 BFS+双数组，从而能实现这个跳过的逻辑。
匹配失败时，直接还原回原来的数组。具体见代码。		
2023年1月18日	https://atcoder.jp/contests/abc222/tasks/abc222_f

输入 n(2≤n≤2e5) 和一棵树的 n-1 条边（节点编号从 1 开始），每条边输入两个端点和边权。
然后输入 n 个数 d，d[i] 表示点 i 的点权。

定义 f(x,y) = 从 x 到 y 的简单路径的边权之和，再加上 d[y]。
定义 g(x) = max{f(x,i)}，这里 i 取遍 1~n 的所有不为 x 的点。
输出 g(1),g(2),...,g(n)。	输入
3
1 2 2
2 3 3
1 2 3
输出
8
6
6	1934	https://atcoder.jp/contests/abc222/submissions/38126974

换根 DP。

我的思路是从 1 开始 dfs，记录从每棵子树的根往下走能得到的最大值 fi 和次大值 se，以及哪个子树可以得到最大值。
然后换根，从 v 到 w，把根从 v 换成 w：如果 w 是 v 的最大值对应的子树，那么对于 w 来说，它往上走能得到的最大值可以是 v 的 se，否则往上走能得到的最大值可以是 v 的 fi。
由于 g(x,y) 和 d[y] 有关，所以对于 w 来说，往上走的最大值还需要与 d[v]+(v-w的边权) 求最大值。具体见代码。

不了解换根 DP 可以先做做 834. 树中距离之和
https://leetcode.cn/problems/sum-of-distances-in-tree/		
2023年1月17日	https://codeforces.com/problemset/problem/1409/E

输入 t(≤2e4) 表示 t 组数据，每组数据输入 n(≤2e5) k(≤1e9) 和长为 n 的数组 a(1≤a[i]≤1e9) 和数组 b。所有数据的 n 之和不超过 2e5。

把 a[i] 标记到数轴上，问两条长为 k 的线段，最多可以覆盖多少 a[i]（线段端点可以覆盖 a[i]）。
注意：数组 b 是没用的，但是你要读入它。

扩展：有 m 条线段：2209. 用地毯覆盖后的最少白色砖块
https://leetcode.cn/problems/minimum-white-tiles-after-covering-with-carpets/

2023.2.4 押题成功！  
https://leetcode.cn/contest/biweekly-contest-97/problems/maximize-win-from-two-segments/	输入
4
7 1
1 5 2 3 1 5 4
1 3 6 7 2 5 4
1 1
1000000000
1000000000
5 10
10 7 5 15 8
20 199 192 219 1904
10 10
15 19 8 17 20 10 9 2 10 19
12 13 6 17 1 14 7 9 19 3
输出
6
1
5
10
解释 对于第一组数据，你可以覆盖 1,1,2,4,5,5	1800	https://codeforces.com/contest/1409/submission/189420578

先排序。

如果只有一个线段，那就是双指针问题。

两个线段的话，第二个线段用双指针，顺带加上 left 之前的最大覆盖数，则需要额外维护一个覆盖数的前缀最大值。

具体来说，pre[i] 记录以 i-1 结尾的单个线段的最大覆盖数，那么有
ans = max(ans, right-left+1+pre[left])
pre[right+1] = max(pre[right], right-left+1)
这里 left 和 right 是双指针里面的变量。
		
2023年1月16日	https://codeforces.com/problemset/problem/1691/D

输入 t(≤1e5) 表示 t 组数据，每组数据输入 n(≤2e5) 和长为 n 的数组 a (-1e9≤a[i]≤1e9)。所有数据的 n 之和不超过 2e5。

请你判断，对数组 a 的每个非空子数组 b，是否都有 max(b) >= sum(b)？
如果是，输出 YES，否则输出 NO。
注：子数组是连续的。

进阶：做到 O(n) 时间复杂度。	输入
3
4
-1 1 -1 2
5
-1 2 -3 2 -1
3
2 3 -1
输出
YES
YES
NO
解释 对于第三组数据，子数组 b=[2,3] 是不满足的。	1800	https://codeforces.com/contest/1691/submission/189346222

提示 1：看到子数组+min/max，就要想单调栈。
对于本题，假设把 a[i] 当作最大值，那么需要得到能把 a[i] 当作最大值的区间左端点的最小值 L，和右端点的最大值 R。这就需要单调栈了。

提示 2：用前缀和思考。
需要在 L 到 i 之间选一个最小的前缀和，i 到 R 之间选一个最大的前缀和。这样子数组和才最大。
如果子数组和 > a[i]，那么输出 NO。
这可以用 ST 表或者线段树实现。

还有更快的做法吗？

提示 3：继续研究，如果从 i-1 向左走，累加元素和，会得到一个 >0 的元素和的话，那么它 + a[i] > a[i]，就要输出 NO 了。
可以在单调栈出栈的时候，去判断是否有这样的情况。
为什么只需要考虑单调栈的元素？
因为其他的下标已经被之前的元素弹出去了，这个下标到 i-1 的元素和必然是 <= 0 的。
对于从 i+1 向右走的情况也一样，倒序单调栈的同时去判断。		
2023年1月13日	https://codeforces.com/problemset/problem/777/D

输入 n(≤5e5) 和长为 n 的字符串数组 a，每个字符串都以 # 开头，所有字符串的长度之和不超过 5e5。
你可以把字符串的任意后缀去掉。
输出使得 a 变为字典序升序，至少需要去掉多少字符。	输入
3
#book
#bigtown
#big
输出
#b
#big
#big

输入
3
#book
#cool
#cold
输出
#book
#co
#cold	1800	https://codeforces.com/contest/777/submission/171012642

提示 1：贪心，从后往前枚举，每个字符串要保留尽可能多的字符。

提示 2：由于字典序的传递性，只需要比较相邻的字符串。		
2023年1月12日	https://codeforces.com/problemset/problem/1490/G

输入 t(≤1e4) 表示 t 组数据，每组数据输入 n(≤2e5) m(≤2e5) 和长为 n 的数组 a(-1e9≤a[i]≤1e9)，表示一个由数组 a 无限重复的序列 b。
然后输入 m 个询问，每个询问输入 x(1≤x≤1e9)。
对每个询问，输出 b 的前缀和中首次 ≥x 的下标（下标从 0 开始），如果不存在，输出 -1。
所有数据的 n 之和、m 之和均不超过 2e5。	输入
3
3 3
1 -3 4
1 5 2
2 2
-2 0
1 2
2 2
0 1
1 2
输出
0 6 2 
-1 -1 
1 3 	1900	https://codeforces.com/contest/1490/submission/108014953

提示 1：计算 a 的前缀和的所有 record 下标 p（record 指比上一个最大值更大的前缀和的下标）。
因为前缀和中任何一个递减或相同的地方都是不重要的。

提示 2：做一些与 x 大小有关的分类讨论，在 p 上二分。

提示 3：至少需要重复多少次？需要保证最后一次是 >= max(前缀和) 的，这类似青蛙跳井问题。		
2023年1月11日	https://codeforces.com/problemset/problem/547/B

输入 n(n≤2e5) 和长为 n 的数组 a(1≤a[i]≤1e9)。
定义 f(x) 为 a 中「长为 x 的连续子数组的最小值」的最大值。
输出 f(1), f(2), ..., f(n)。	输入
10
1 2 3 4 5 4 3 2 1 6
输出
6 4 4 3 3 2 2 1 1 1 	1900	https://codeforces.com/problemset/submission/547/188764909

提示 1：考虑每个数的贡献。

提示 2：用单调栈算出每个数 v 作为最小值的范围最大是多少，设范围最大为 size，那么所有 x <= size 的 f(x) 都应维护下最大值 v。但这样太慢了，除非你用线段树区间更新。

提示 3：实际上没有必要用线段树，只需要更新 f(size) 的最大值，最后再倒着遍历 f，把最大值从右向左推过去就好了（即后缀最大值）。		
2023年1月10日	https://codeforces.com/problemset/problem/1358/D

输入 n(n≤2e5) x 和长为 n 的数组 d(1≤d[i]≤1e6 且 1≤x≤sum(d))。
在某地，一年有 n 月，其中第 i 月有 d[i] 天，天数从 1 到 d[i]，在第 j 天你可以得到 j 元。
问在该地连续呆 x 天你最多能得到多少元。
注意：从当年最后一月呆到下一年的第一月是可以的。	输入
3 2
1 3 1
输出 5
解释 在二月呆最后两天，得到 2+3=5

输入
3 6
3 3 3
输出 12
解释 任意完整两月均可，得到 (1+2+3)+(1+2+3)=12

输入
5 6
4 2 3 1 3
输出 15
解释 最后一月呆 2 天，第一月呆 4 天，得到 (2+3)+(1+2+3+4)=15	1900	https://codeforces.com/problemset/submission/1358/188648522

提示 1：看成是环形数组，那么数组复制一份接在后面，就变成非环形的了（注意 x 不超过 sum(d)）。

提示 2：这是个窗口大小为 x 的滑窗问题，但是 x 太大了，如何优化？

提示 3：窗口的开头或者末尾只需要在某些关键的 day 就行了，是什么样的 day 呢？

提示 4：月末收益最大。

提示 5：窗口末尾只需要在月末就行。可以用反证法证明：
假设窗口末尾不在月末是最优的，设窗口末尾在第 k 天是最优的，那么右边一定是第 k+1 天。
如果窗口向右滑，由于我们假设不在月末更优，因此窗口的元素和减少，所以从左边出去的元素必然大于 k+1，出去的元素的左边那个元素必然大于 k。那么把窗口改为向左滑，窗口左边进来一个大于 k 的数，右边出去一个等于 k 的数，窗口元素和变大，矛盾，因此窗口末尾一定在月末是最优的。

那么在 d 数组上双指针模拟就好了。		
2023年1月9日	https://codeforces.com/problemset/problem/1370/D

输入 n k (2≤k≤n≤2e5) 和长为 n 的数组 a (1≤a[i]≤1e9)。
从 a 中选出一个长为 k 的子序列 s，下标从 1 开始。
定义 x=max(s[1],s[3],s[5],...)，y=max(s[2],s[4],s[6],...)
输出 min(x,y) 的最小值。
注：子序列不一定是连续的。	输入
4 2
1 2 3 4
输出 1
解释 s=[1,3]

输入
4 3
1 2 3 4
输出 2
解释 s=[1,2,4]

输入
5 3
5 3 4 2 6
输出 2

输入
6 4
5 3 50 2 4 5
输出 3
解释 s=[3,50,2,4]	2000	https://codeforces.com/contest/1370/submission/95403435

提示 1：讨论 min(x, y) 是 x 还是 y，那么问题就变成「最小化最大值」了，二分答案。

提示 2：假设是 x，遍历 a，遇到一个 <= mid 的数，把它当作是属于 x 的，计数器+1；同时后面一个数必须要属于 y，那么随便选（因为只看 x），计数器也+1。如果最后计数器 >= k 那么 check 返回 true，否则返回 false。
假设是 y，那么同理，只不过要从 a 的第二个数开始算（第一个数已经属于 x 了）。
		
2023年1月6日	http://codeforces.com/problemset/problem/1739/D

输入 t(≤1e4) 表示 t 组数据，每组数据输入 n k(0≤k<n≤2e5)，有一颗 n 个节点的树，输入 n-1 个数 p[2],p[3],...,p[n]，p[i] 表示点 i 的父节点为 p[i]。
所有数据的 n 之和不超过 2e5。
你可以做如下操作至多 k 次：
断开 p[i] 和 i 之间的边，然后在 1 和 i 之间连边。
输出操作后，这颗树的最小高度。
高度的定义为 1 到最远叶子节点的路径的边数。	输入
5
5 1
1 1 2 2
5 2
1 1 2 2
6 0
1 2 3 4 5
6 1
1 2 3 4 5
4 3
1 1 1
输出
2
1
5
3
1	1900	https://codeforces.com/contest/1739/submission/188029675

提示 1：由于最终的树越高，操作次数越少，最终的树越矮，操作次数越多，满足单调性，因此可以二分答案。

提示 2：check 需要写一个树形 DP，自底向上计算最长路径长度，达到 mid-1 的时候，切断当前节点和父节点的边，计数器 cnt++，如果最后 cnt≤k 则说明答案不超过 mid。	类似求直径的那种树形 DP	
2023年1月5日	https://codeforces.com/problemset/problem/1718/A2

输入 t(≤500) 表示 t 组数据，每组数据输入 n(≤1e5) 和长为 n 的数组 a (0≤a[i]<2^30)。
所有数据的 n 之和不超过 1e5。
每次操作你可以把 a 的下标从 L 到 R 的元素都异或一个数，花费为 ceil((R-L+1)/2)。
输出把 a 的所有元素都变成 0 的最小代价。	输入 
7
4
5 5 5 5
3
1 3 2
2
0 0
3
2 5 7
6
1 2 3 3 2 1
10
27 27 34 32 2 31 23 56 52 4
5
1822 1799 57 23 55
输出
2
2
0
2
4
7
4	1900	https://codeforces.com/contest/1718/submission/187981040

提示 1：ceil((R-L+1)/2) 有什么性质？

提示 2：对一个长为 4 的子数组操作，相当于对两个长为 2 的子数组操作；对一个长为 3 的子数组操作，相当于对一个长为 2 和一个长为 1 的子数组操作。换句话说，可以只有长为 1 和 2 的操作。

提示 3：如果有一个子数组的异或和为 0，那么可以用若干长为 2 的子数组来操作，这样花费是长度-1。

提示 4：答案是 n - 异或和为 0 的不相交子数组的个数。

代码实现时可以用前缀和+哈希表快速判断。
为了保证不相交，在遇到相同前缀和时，需要把哈希表重置为 {0}，前缀和重置为 0。
也可以重置为 {xor}，这样前缀和无需重置。		
2023年1月4日	https://codeforces.com/problemset/problem/1733/D2

输入 t(≤1000) 表示 t 组数据，每组数据输入 n(5≤n≤5000) x y(1~1e9) 和两个长为 n 的二进制数 s 和 t。
所有数据的 n 之和不超过 5000。
每次操作你可以把 s 的两个比特位翻转（0 变 1，1 变 0），如果两个比特位相邻，则代价为 x，否则为 y。
输出把 s 变成 t 的最小代价，如果无法做到，输出 -1。

进阶：你能做到 O(n) 时间复杂度吗？

2023.10.8 押题成功！https://leetcode.cn/contest/weekly-contest-366/problems/apply-operations-to-make-two-strings-equal/	输入 
6
5 8 9
01001
00101
6 2 11
000001
100000
5 7 2
01000
11011
7 8 3
0111001
0100001
6 3 4
010001
101000
5 10 1
01100
01100
输出
8
10
-1
6
7
0	2000	O(n)：
https://codeforces.com/problemset/submission/1733/187727396

空间优化：
https://codeforces.com/problemset/submission/1733/187727663

我的题解，欢迎点赞：
https://www.luogu.com.cn/blog/endlesscheng/solution-cf1733d2		
2023年1月3日	https://atcoder.jp/contests/abc249/tasks/abc249_f

初始时 x=0。
输入 n k(k≤n≤2e5)，以及 n 个操作，每个操作是如下两种之一：
"1 y"，表示把 x 替换成 y；
"2 y"，表示 x+=y。(-1e9≤y≤1e9)
你可以跳过至多 k 个操作，你需要最大化最后的 x，输出这个最大值。	输入 
5 1
2 4
2 -3
1 2
2 1
2 -3
输出 3
解释 跳过最后一个

输入 
1 0
2 -1000000000
输出 -1000000000	1786	https://atcoder.jp/contests/abc249/submissions/37631511

提示 1：由于操作 1 会覆盖之前的所有操作，因此倒序思考这些操作更合适。

提示 2：假设某个操作 1 是最后一次操作 1，那么在它之后的操作 1 都应该 skip。

提示 3：如果 skip 的操作达到了 k，后面又遇到了操作 2，那么我们应该「撤销」之前的 skip，也就是把最大的负数 y 撤销掉（绝对值最小的 y）。

提示 4：用堆来实现。（这个套路也叫反悔堆）

代码实现时可以在最前面插入一个 "1 0" 方便统一操作。		
2023年1月2日	https://codeforces.com/problemset/problem/379/D

输入 k(3≤k≤50) x(0≤x≤1e9) n(1≤n≤100) m(1≤m≤100)。
你需要构造长分别为 n 和 m 的字符串 s[1] 和 s[2]，它们只能包含大写字母。
然后按照 s[i]=s[i-2]+s[i-1] 的方式，生成字符串 s[k]，要求子串 "AC" 在 s[k] 中恰好出现 x 次。
如果可以构造，输出任意符合要求的 s[1] 和 s[2]，否则输出 "Happy new year!"。	输入 
3 2 2 2
输出
AC
AC

输入 
3 3 2 2
输出
Happy new year!

输入 
3 0 2 2
输出
AA
AA	2000	https://codeforces.com/problemset/submission/379/187613695

AC 只能发生在这些地方：
s[1] 内部
s[2] 内部
s[1]+s[1] 交界处（这是不可能的）
s[1]+s[2] 交界处
s[2]+s[1] 交界处
s[2]+s[2] 交界处

那么暴力枚举 s[1] 中有多少 AC，开头是否为 C，结尾是否为 A。
s[2] 同理。
然后迭代计算 s[k] 的 AC 个数，看是否为 x。
具体见代码。

注意如果 AC 数量超过 x，要及时退出循环，否则会溢出。虽然这题没有针对 hack 这种代码的数据，但是还是要注意不要写出错误的代码。		
2022年12月30日	https://atcoder.jp/contests/abc259/tasks/abc259_f

输入 n(≤3e5)，长为 n 的数组 d，和一颗带权树的 n-1 条边，边权 [-1e9,1e9]。
d[i] 不会超过点 i 的度数。
移除一些边，使得点 i 的度数不超过 d[i]。
输出剩余边的边权之和的最大值。	输入
7
1 2 1 0 2 1 1
1 2 8
2 3 9
2 4 10
2 5 -3
5 6 8
5 7 3
输出 28

这题数据有点弱，再补一个数据
输入
2 0
1 -1
2 -1
输出 -2	1961	https://atcoder.jp/contests/abc259/submissions/37624720

写一个树形 DP。

类似打家劫舍 III，子树返回两个数：子树连了至多 d 条边，子树连了至多 d-1 条边（预留一条边给父节点）。
这两个数分别记作 full 和 notFull。

把 full 累加起来，这是一条边都不连的情况。
然后思考：在这个基础上，与哪些子树连边的收益最大？

把边权记作 weight，优先选择 weight + notFull - full 更大的子树，与之连边，这样收益最大。注意这个数有可能是负数，这种情况是不能连边的。

注意 d=0 的情况。	https://leetcode.cn/problems/house-robber-iii/	
2022年12月29日	https://atcoder.jp/contests/abc267/tasks/abc267_f

输入 n(≤2e5) 和一棵树的 n-1 条边（节点编号从 1 开始）。
然后输入 q(≤2e5) 和 q 个询问，每个询问输入 u 和 k。
输出到 u 的距离为 k 的任意一个点。如果这个点不存在则输出 -1。
距离指两点最短路上的边的数目。	输入
5
1 2
2 3
3 4
3 5
3
2 2
5 3
3 3
输出
4
1
-1	1939	https://atcoder.jp/contests/abc267/submissions/37595672

求出树的任意一条直径，设直径端点为 x 和 y。

从 x 出发 dfs，同时记录 dfs 路径上的点。
如果点 u 的深度 d >= k，那么 dfs 路径上的第 d-k 个点就是答案。

一次 dfs 不一定能满足所有点，再从 y 出发 dfs 一次就能保证所有点都有答案（除了 k 非常大的）。		
2022年12月28日	https://atcoder.jp/contests/abc268/tasks/abc268_f

输入 n(≤2e5) 和 n 个字符串，总长度不超过 2e5。
每个字符串包含 X 和数字 1~9。
重排这些字符串，然后拼接成一个字符串 t。
对每个 1≤i<j≤len(t)，如果 t[i]=X 且 t[j]=1 则得 1 分，如果 t[i]=X 且 t[j]=2 则得 2 分，依此类推。
输出你最多可以得到多少分。	输入
3
1X3
59
XXX
输出 71
解释 t=XXX1X359	1807	https://atcoder.jp/contests/abc268/submissions/37573533

提示 1：邻项交换法，对于两个字符串，哪个应该排在前面？

提示 2：X 越多，数字之和越小的。		
2022年12月27日	https://atcoder.jp/contests/abc270/tasks/abc270_f

输入 n m (≤2e5)。有 n 个岛屿。
输入 n 个数，表示在第 i 个岛屿上修建机场的花费(≤1e9)。如果两个岛都有机场，则可以互相到达。
输入 n 个数，表示在第 i 个岛屿上修建港口的花费(≤1e9)。如果两个岛都有港口，则可以互相到达。
输入 m 条边，每条边输入 a b z 表示在岛屿 a 和 b 造桥的花费为 z(≤1e9)。
输出使得任意两个岛可以互相到达的最小花费。	输入
4 2
1 20 4 7
20 2 20 3
1 3 5
1 4 6
输出 16

输入
3 1
1 1 1
10 10 10
1 2 100
输出 3	1834	https://atcoder.jp/contests/abc270/submissions/37572585

提示 1：如果一定要用上机场和港口的话，可以创建两个超级源点，建机场/港口就往超级源点连边。

提示 2：枚举是否要用上机场/港口，总共 4 种情况。

提示 3：最小生成树。		
2022年12月26日	https://atcoder.jp/contests/abc269/tasks/abc269_f

输入 n m (≤1e9) q(≤2e5)。表示一个 n 行 m 列的矩阵。
第 i 行第 j 列的元素为 (i-1)*m+j，但是如果 i+j 是奇数，则该元素为 0。
输入 q 个询问，每个询问输入 r1 r2 c1 c2。
对每个询问，输出所有在第 r1~r2 行 c1~c2 列的元素之和，模 998244353。	输入
5 4
6
1 3 2 4
1 5 1 1
5 5 1 4
4 4 2 2
5 5 4 4
1 5 1 4
输出
28
27
36
14
0
104	1601	https://atcoder.jp/contests/abc269/submissions/37478697

用二维前缀和简化计算。
推公式。		
2022年12月23日	https://atcoder.jp/contests/abc271/tasks/abc271_e

输入 n m k (≤2e5)，然后输入 m 条边，每条边输入两个点 x y（表示从 x 到 y 的一条有向边，点的编号 1~n）和一个值在 [1,1e9] 内的边权，每条边的编号 1~m。
图中没有自环，但可能有重边。
然后输入一个长为 k 的数组 a (1≤e[i]≤m)。
找到一条从 1 到 n 的路径，满足路径上的边的编号是 a 的子序列。
输出满足这个要求的路径的最短长度。如果不存在，输出 -1。	输入
3 4 4
1 2 2
2 3 2
1 3 3
1 3 5
4 2 1 2
输出 4

输入
3 2 3
1 2 1
2 3 1
2 1 1
输出 -1	1402	https://atcoder.jp/contests/abc271/submissions/37441829

类似最短路，按照数组 a 的顺序放松边，即如果 dis[x] + 边权 < dis[y]，那么就更新 dis[y]。		
2022年12月22日	https://atcoder.jp/contests/abc273/tasks/abc273_e

一开始你有一个空数组 a 和一个 1e9 页的笔记本，每页上都记录着一个空数组。
有四种类型的操作：
ADD x：在 a 的末尾添加元素 x (1≤x≤1e9)。
DELETE：如果 a 不为空，删除 a 的最后一个元素。
SAVE y：把 a 记在第 y 页上（覆盖原来的数组）。
LOAD z：把 a 替换为第 z 页上的数组。

输入 q(≤5e5) 和 q 个操作。
在每个操作结束后，你需要输出 a 的最后一个元素（数组为空时输出 -1）。	输入
11
ADD 3
SAVE 1
ADD 4
SAVE 2
LOAD 1
DELETE
DELETE
LOAD 2
SAVE 1
LOAD 3
LOAD 1
输出
3 3 4 4 3 -1 -1 4 4 -1 4	1624	https://atcoder.jp/contests/abc273/submissions/37430977

提示：用类似字典树 Trie 的结构来模拟。具体见代码。		
2022年12月21日	https://atcoder.jp/contests/abc275/tasks/abc275_f

输入 n(≤3000) m(≤3000) 和长为 n 的数组 a (1≤a[i]≤3000)。
每次操作你可以删除 a 的一个非空连续子数组。
定义 f(x) 表示使 sum(a) = x 的最小操作次数。
输出 f(1), f(2), ..., f(m)。	输入
4 5
1 2 3 4
输出
1
2
1
1
1

输入
1 5
3
输出
-1
-1
0
-1
-1	1608	https://atcoder.jp/contests/abc275/submissions/37418527

这题和 01 背包有点像，但是直接按照 01 背包那样定义状态是不够的，需要加一个维度。

定义 f[i][j][0/1] 表示前 i 个数，和为 j，其中第 i 个数【0=删除，1=保留】

f[i][j][0] = min(f[i-1][j][0], f[i-1][j][1]+1)
f[i][j][1] = min(f[i-1][j-a[i]][0], f[i-1][j-a[i]][1])

初始值 f[0][0][0]=inf, f[0][0][1]=1, f[i>0][0][0]=1, f[i>0][0][1]=inf。
答案为 min(f[n][j][0], f[n][j][1])。

代码实现时可以像 01 背包那样压缩空间。		
2022年12月20日	https://atcoder.jp/contests/abc266/tasks/abc266_f

输入 n (3≤n≤2e5) 和 n 条边，点的编号在 [1,n] 内，表示一个没有重边和自环的无向连通图。
然后输入 q(≤2e5) 表示有 q 个询问，每个询问输入两个数 x 和 y (1≤x<y≤n)。
对于每个询问，如果 x 和 y 之间只存在唯一的简单路径，则输出 Yes，否则输出 No。	输入
5
1 2
2 3
1 3
1 4
2 5
3
1 2
1 4
1 5
输出
No
Yes
No	1525	https://atcoder.jp/contests/abc266/submissions/37391833

基环树问题的套路题。

讲解见我之前写的教程 https://leetcode.cn/problems/maximum-employees-to-be-invited-to-a-meeting/solutions/1187830/nei-xiang-ji-huan-shu-tuo-bu-pai-xu-fen-c1i1b/
往下翻到「下面介绍基环树问题的通用处理方法……」处。		
2022年12月19日	https://atcoder.jp/contests/abc272/tasks/abc272_e

输入 n(≤2e5) m(≤2e5) 和长为 n 的整数数组 a (-1e9≤a[i]≤1e9)，下标从 1 开始。
执行如下操作 m 次：
对 1~n 的每个 i，把 a[i] += i。
每次操作后，输出 mex(a)，即不在 a 中的最小非负整数。	输入
3 3
-1 -1 -6
输出
2
2
0

输入
5 6
-2 -2 -5 -7 -15
输出
1
3
2
0
0	1434	https://atcoder.jp/contests/abc272/submissions/37376965

提示 1：由于 a 中只有 n 个数，因此在 [0,n-1] 范围之外的 a[i] 是没有意义的。

提示 2：对于每个 i，有多少次操作，使得操作后 a[i] 仍然在 [0,n-1] 范围内？

提示 3：根据调和级数，总共有 O(nlogn) 次这样的操作。

提示 4：对每个 a[i]，把满足提示 2 的操作次数以及操作后的结果存下来，按照操作次数分组归类。

提示 5：每个操作次数所对应的结果记录到一个哈希表中，暴力枚举计算 mex（提示 3）。
代码实现时可以用时间戳来优化。		
2022年12月16日	https://atcoder.jp/contests/abc214/tasks/abc214_e

输入 t(≤2e5) 表示 t 组数据，每组数据输入 n(≤2e5) 和 n 个区间 [L,R]，范围在 [1,1e9]。
所有数据的 n 之和不超过 2e5。

你有 n 个球，第 i 个球需要放在区间 [L,R] 内的整数位置上。
但每个整数位置上至多能放一个球。
如果可以做到，输出 Yes，否则输出 No	输入
2
3
1 2
2 3
3 3
5
1 2
2 3
3 3
1 3
999999999 1000000000
输出
Yes
No	1835	https://atcoder.jp/contests/abc214/submissions/37293686

按左端点排序。
遍历区间，把左端点相同的区间的右端点放到一个最小堆中，每次优先选一个右端点最小的。		
2022年12月15日	https://atcoder.jp/contests/keyence2020/tasks/keyence2020_d

输入 n(≤18) 和两个长为 n 的数组 a b，元素范围在 [1,50]。
a[i] 和 b[i] 表示第 i 张牌的正面数字和背面数字。
初始所有牌正面朝上。
每次操作你可以交换第 i 和 i+1 张牌的位置，同时翻转这两张牌。
输出让看到的数字从左往右是递增（允许相等）所需要的最小操作次数。
如果无法做到，输出 -1。	输入
3
3 4 3
3 2 3
输出 1
解释 操作前两张牌

输入
2
2 1
1 2
输出 -1	1841	https://atcoder.jp/contests/keyence2020/submissions/37285193

提示 1：无论操作多少次，背面朝上的卡牌数总是偶数。

提示 2：一张牌从位置 i 交换至位置 j，如果 |i-j| 是偶数则正面朝上，否则背面朝上。

提示 3：写一个爆搜，枚举每张牌是正面向上还是背面向上，
到边界时，把当前的牌和排序后的牌对比，仿照冒泡排序那样模拟操作。		
2022年12月14日	https://atcoder.jp/contests/arc091/tasks/arc091_c

输入 n a b (≤3e5)。
构造一个 1~n 的排列，其 LIS 的长度为 a，LDS 的长度为 b。
如果不存在这样的排列，输出 -1，否则输出任意一个满足要求的排列。
注：LIS 指最长上升子序列，LDS 指最长下降子序列。	输入 5 3 2
输出 2 4 1 5 3

输入 7 7 1
输出 1 2 3 4 5 6 7

输入 300000 300000 300000
输出 -1	1889	https://atcoder.jp/contests/arc091/submissions/37259778

手玩一下发现可以这样构造：
n=10 a=3 b=4
答案 = 4 3 2 1 8 7 6 5 10 9
n=10 a=4 b=5
答案 = 5 4 3 2 1 8 7 6 9 10
注意构造时，要为后面预留足够的数字，使得 LIS 的长度可以为 a。

从这里可以发现，如果 a+b-1 > n，则一个递增和递减都无法满足；
或者 a*b<n，构造 a 个长为 b 的递减也无法满足。
这两种都要输出 -1。		
2022年12月13日	https://atcoder.jp/contests/arc125/tasks/arc125_c

输入 n k (k≤n≤2e5) 和一个长为 k 的严格递增数组 a，元素范围 [1,n]。
输出一个 1~n 的排列 p，使得 a 是 p 的一个 LIS。
如果有多个这样的 p，输出字典序最小的那个。
注：LIS 指最长上升子序列。	输入
3 2
2 3
输出
2 1 3

输入
5 1
4
输出
5 4 3 2 1	1896	https://atcoder.jp/contests/arc125/submissions/37235888

提示 1：先思考（手玩）一个简单的情况，如果没有字典序最小的要求，要如何构造答案？

提示 2：继续手玩，让你构造出的排列的字典序尽量小。

提示 3：构造方案如下：
把不在 a 中的数字记到 miss 数组中。
双指针遍历 a 的前 k-1 个数以及 miss，如果 miss[j] < a[i]，那么 miss[j] 就可以插在 a[i] 和 a[i+1] 之间。
最后把 a[k-1] 加到剩余的 miss 中，从大到小输出。		
2022年12月12日	https://atcoder.jp/contests/arc147/tasks/arc147_b

输入 n(≤400) 和一个 1~n 的排列 p，下标从 1 开始。
你有两种操作：
操作 "A i" 可以交换 p[i] 和 p[i+1]；
操作 "B i" 可以交换 p[i] 和 p[i+2]。

你需要让 p 变为递增的。
最小化操作 A 的次数，同时总操作次数不能超过 1e5。
输出总操作次数，以及具体的操作内容，详见样例。
如果有多个符合要求的方案，输出任意一种。
保证存在这样的操作方案。	输入
4
3 2 4 1
输出
4
A 3
B 1
B 2
B 2

输入
3
1 2 3
输出
0

输入
6
2 1 4 3 6 5
输出
3
A 1
A 3
A 5	1167	https://atcoder.jp/contests/arc147/submissions/37226588

提示 1：操作 B 对于奇数下标和偶数下标是独立的。

提示 2：找到 p[i] 和 i 奇偶性不同的数字，这些数字只能用操作 A 处理。

提示 3：用操作 B 可以将提示 2 的数字聚合在一起，然后就可以使用操作 A 了。最后再用操作 B 排序。		
2022年12月9日	https://atcoder.jp/contests/arc132/tasks/arc132_c

输入 n(≤500) d(≤5) 和长为 n 的数组 a。
a 原本是一个 1~n 的排列 p，不过有些数字被替换成了 -1。
你需要还原 p，使得 abs(p[i]-i) ≤ d 对每个 i 都成立。
输出有多少个这样的 p，模 998244353。	输入
4 2
3 -1 1 -1
输出 2
解释 [3,2,1,4] 和 [3,4,1,2]

输入
5 1
2 3 4 5 -1
输出 0	1616	https://atcoder.jp/contests/arc132/submissions/37103023

定义 f[i][mask] 表示前 i 个数字构成的集合为 mask 时的方案数。
枚举第 i 个数字要填的数字 j，转移给 f[i+1][mask|(1<<j)]。
初始 f[0][0]=1，答案为 sum(f[n])。

你以为 mask 有 2^n-1 那么大？
注意到第 i 个数字能填的范围是有限的，所以 mask 至多是 2^(2d)-1。		
2022年12月8日	https://atcoder.jp/contests/arc144/tasks/arc144_c

输入 n 和 k (k<n≤3e5)。
请构造一个字典序最小的 1~n 的排列 p（下标从 1 开始），使得 abs(p[i]-i)≥k 对每个 i 都成立。
如果无法构造，输出 -1。否则输出 p。	输入 3 1
输出 2 3 1

输入 8 3
输出 4 5 6 7 8 1 2 3

输入 8 6
输出 -1	1622	https://atcoder.jp/contests/arc144/submissions/37093582

手玩一下 k=3 的情况，发现规律是 6 个一组，每组是
i+4,i+5,i+6,i+1,i+2,i+3
这里 i=6m+1

考虑 n 不是 6 的倍数，手玩发现最后残余 (n%(k*2)) 的一组会和倒数第二组有关系：
1. 如果残余数量 ≤ k
规律如样例 2
2. 如果残余数量 > k
例如残余 4
那么最后两组就是
4,5,6,1,8,9,10,2,3,7
例如残余 5
那么最后两组就是
4,5,6,1,2,9,10,11,3,7,8

按这个规律输出，就可以做到 O(1) 空间复杂度了。		
2022年12月7日	https://atcoder.jp/contests/arc140/tasks/arc140_c

输入 n 和 x (x≤n≤2e5)。
你需要构造一个 1~n 的排列 p，其中第一项为 x。
p 可以生成一个长为 n-1 的数组 a，使得 a[i]=abs(p[i]-p[i+1])。
通过构造合适的 p，最大化 a 的 LIS（最长严格递增子序列）的长度。
输出 p。	输入 3 2
输出 2 1 3
解释 a=[1,2]，LIS 的长度为 2

输入 3 1
输出 1 2 3
解释 a=[1,1]，LIS 的长度为 1	1596	https://atcoder.jp/contests/arc140/editorial/3970		
2022年12月6日	https://atcoder.jp/contests/abc059/tasks/arc072_a

输入 n (2≤n≤1e5) 和一个长为 n 的数组 a (-1e9≤a[i]≤1e9)。
每次操作你可以把一个 a[i] 加一或减一。
如果要让 a 的所有相邻前缀和的乘积都小于 0，至少需要操作多少次？	输入
4
1 -3 1 0
输出 4
解释 修改成 [1,-2,2,-2]，前缀和为 [1,-1,1,-1]	1409	https://atcoder.jp/contests/abc059/submissions/37050266

提示 1：前缀和的符号要么是 -+-+... 要么是 +-+-...

提示 2：如果一个前缀和的符号已经和期望的符号相同，那么就无需修改（因为修改后面的可以达到同样的效果）

因此，枚举前缀和要变成提示 1 中的哪一种，
然后从左到右遍历前缀和，如果符号和期望的不同，就直接改成 1 或者 -1。

代码实现时有一些技巧，可以看看。		
2022年12月5日	https://atcoder.jp/contests/abc102/tasks/arc100_b

输入 n (4≤n≤1e5) 和一个长为 n 的数组 a (1≤a[i]≤1e9)。
将 a 分割成 4 个非空连续子数组，计算这 4 个子数组的元素和。
你需要最小化这 4 个和中的最大值与最小值的差。
输出这个最小值。	输入
5
3 2 4 1 2
输出 2
解释 分成 [3],[2],[4],[1,2]，元素和分别为 3,2,4,3，最大-最小=2	1801	https://atcoder.jp/contests/abc102/submissions/37028653

三指针 left mid right，对应三条分割线。
枚举 mid，那么 left 应当把左边分割的尽量均匀，right 同理。
mid 增大时，left 和 right 都是只增不减的。
这样就可以 O(n) 实现了。

什么叫均匀？如果 left+1 分出的两段的元素和的绝对差比 left 更小，那么 left 就应当右移。		
2022年12月2日	https://atcoder.jp/contests/abc066/tasks/arc077_b

输入 n(≤1e5) 和一个长为 n+1 的数组 a，元素范围 [1,n]，且 [1,n] 的每个数都在 a 中。
对每个 [1,n+1] 的 k，输出有多少个长为 k 的不同子序列，模 1e9+7。
注：下标不同但内容相同的子序列，算相同的子序列。	输入
3
1 2 1 3
输出
3
5
4
1	1715	https://atcoder.jp/contests/abc066/submissions/36914590

如果无视不同的要求，那么答案就是 C(n+1,k)。
什么时候会有重复的呢？
只可能是 a 中那两个相同的数字，恰好选了其中一个导致的。
设 a 中那两个相同数字的下标分别为 p 和 q（下标从 0 开始），
手玩一下可以发现，如果剩余的 k-1 个数是在 p 左边或 q 右边中选的，就会导致重复。
这一共有 m = p + (n-q) 个数。
因此答案为 C(n+1,k) - C(m,k-1)。

计算组合数需要逆元。		
2022年12月1日	https://atcoder.jp/contests/arc116/tasks/arc116_d

输入 n(≤5000) 和 m (≤5000)。
你需要计算满足如下要求的数组个数：
1. 包含 n 个非负整数；
2. 所有数的和为 m；
3. 所有数的异或和为 0。
输出这样的数组个数，模 998244353。	输入 5 20
输出 475

输入 10 5
输出 0	1718	https://atcoder.jp/contests/arc116/submissions/36899692

定义 f(i) 表示元素和为 i 时的答案。由于异或和为 0，i 必须是偶数。
考虑这 n 个数的二进制的最低位有 j 个 1，从 n 个数中选，那么方案数是 C(n,j)，这里 j=0,2,4,...
除去最低位后，其余位数的元素和等于 i-j。为了缩小问题的规模，我们可以把所有数位右移，即考虑 f((i-j)/2)。
那么 f(i) = ∑f((i-j)/2) * C(n,j),    j=0,2,4,...
上面说的是记忆化搜索，你可以可以看成是递推式。
f[0]=1，答案为 f[m]。

计算组合数，可以用递推，也可以用逆元。
由于只用到第 n 行，递推的写法可以用滚动数组优化。		
2022年11月30日	https://atcoder.jp/contests/arc136/tasks/arc136_b

输入 n(3≤n≤5000) 和两个长为 n 的数组 a b，元素范围在 [1,5000]。
你可以对数组 a 执行如下操作任意多次：
选择三个相邻的数 a[i] a[i+1] a[i+2]，设这三个数为 x y z，更新 a[i]=z a[i+1]=x a[i+2]=y。
如果可以把 a 变成 b，输出 Yes，否则输出 No。	输入
4
3 1 4 5
4 1 5 3
输出 Yes

输入
3
1 2 3
2 3 4
输出 No	1358	https://atcoder.jp/contests/arc136/submissions/36888789

首先两个数组元素必须一样，即 Counter(a) == Counter(b)。

先考虑没有重复元素的情况。
由于操作是可逆的，尝试把 a 和 b 都变成一个有序数组。
通过操作，可以把前 n-2 小的元素都移到数组左边，也就是最大的两个数移到数组末尾。
由于最后两个数无法交换，所以如果不同，则输出 No。

如果数组中有重复元素，那么可以把其中的两个重复元素移到数组末尾。
因此只要有重复的，就输出 Yes。

代码实现时，对于无重复元素的情况，可以用 a 和 b 的逆序对的奇偶性是否相同来简化判定。
如果相同则输出 Yes，否则输出 No。
这是因为操作不会改变逆序对的奇偶性。		
2022年11月29日	https://atcoder.jp/contests/arc097/tasks/arc097_b

输入 n(≤1e5) m(≤1e5) 和一个 1~n 的排列 p。
然后输入 m 行，每行两个数 x 和 y，表示你可以交换 p[x] 和 p[y]（下标从 1 开始）。
这 m 个操作你可以按任意顺序执行任意多次。
输出你可以让多少个 p[i]=i。	输入
5 2
5 3 1 4 2
1 3
5 4
输出 2

输入
3 2
3 2 1
1 2
2 3
输出 3	1270	https://atcoder.jp/contests/arc097/submissions/36870960

把 x 和 y 连起来，组成一个图。
如果 p[i] 和 i 在同一个连通块，那么答案就+=1。		
2022年11月27日	https://atcoder.jp/contests/arc107/tasks/arc107_c

输入 n(≤50) 和 k(≤2n^2)。
然后输入 n^2 个数，表示一个 n*n 的矩阵 a，矩阵元素是 1~n^2 的一个排列。
每次操作，你可以选择下面的两个之一：
1. 选择两列 x 和 y，如果对于每个 i 都有 a[i][x]+a[i][y]≤k，则可以交换这两列。
2. 选择两行 x 和 y，如果对于每个 i 都有 a[x][i]+a[y][i]≤k，则可以交换这两行。
你可以执行任意多次操作。
输出你能得到的不同矩阵个数，模 998244353 的结果。	输入
3 13
3 2 7
4 8 9
1 6 5
输出 12	1223	https://atcoder.jp/contests/arc107/submissions/36849409

首先，行与列的交换是不会影响到对方的。
那么就分别统计，最后用乘法原理相乘。

对于行，在可以交换的行 x 和 y 之间连边，建图。
那么对于一个大小为 sz 的连通分量，它可以产生 sz! 个不同的行。
把所有连通分量的大小的阶乘相乘，就得到了答案。		
2022年11月25日	https://atcoder.jp/contests/arc119/tasks/arc119_b

输入 n(≤5e5) 和两个长为 n 的 01 字符串 s 和 t。
每次操作，你可以把 s 中形如 011..1 或 11..10 的子串的最左最右两个字符交换。
输出把 s 变成 t 最小操作次数，如果无法做到输出 -1。	输入
7
1110110
1010111
输出 2

输入
6
111100
111000
输出 -1	1196	https://atcoder.jp/contests/arc119/submissions/36760648

首先 0 的个数必须相同，否则输出 -1。

考察 s 和 t 中的第一个 0 的下标，设为 i 和 j。
无论 i>j 还是 i<j，都可以用一次操作，使得 s 中的 0 和 t 的匹配。

因此设 s 中 0 的下标数组为 p，t 中 0 的下标数组为 q。
那么答案就是 p[i] != q[i] 的个数。
代码实现时可以用双指针减小内存消耗。		
2022年11月24日	https://atcoder.jp/contests/arc133/tasks/arc133_c

输入 n m k (≤2e5) 和长度分别为 n 和 m 的数组 a 和 b，元素范围 [0,k-1]。
构造一个 n 行 m 列，元素范围在 [0,k-1] 的矩阵，使得第 i 行的元素和 % k = a[i]，第 j 列的元素和 % k = b[j]。
你只需要输出这个矩阵的元素和的最大值。
如果这个矩阵不存在，输出 -1。	输入
2 4 3
0 2
1 2 2 0
输出 11
解释
2022
2201

输入
3 3 4
0 1 2
1 2 3
输出 -1	1583	https://atcoder.jp/contests/arc133/submissions/36747125

不妨把矩阵的每个数都置为 k-1，然后慢慢减小。

对于第 i 行来说，这一行的元素总共需要减小 ((k-1)*m-a[i])%k，累加所有行的减小量，得到 sa。
对于第 j 列来说，这一列的元素总共需要减小 ((k-1)*n-b[j])%k，累加所有列的减小量，得到 sb。

如果 sa%k != sb%k，则无解。
否则 sa-sb 是 k 的倍数，不妨设 sa > sb，那么可以把第一列的减小量 += sa-sb，使得行列减小量之和相同。
然后就可以不断选择行列的减小量均为正数的，把这个元素减一。
这样最后会操作 max(sa,sb) 次。
所以答案是 n*m*(k-1) - max(sa,sb)。		
2022年11月23日	https://atcoder.jp/contests/arc120/tasks/arc120_c

输入 n(≤2e5) 和两个长为 n 的数组 a b，元素范围在 [0,1e9]。
每次操作你可以选择 a 中的两个相邻数字，设 x=a[i], y=a[i+1]，更新 a[i]=y+1, a[i+1]=x-1。
输出把 a 变成 b 的最小操作次数，如果无法做到则输出 -1。	输入
3
3 1 4
6 2 0
输出 2

输入
3
1 1 1
1 1 2
输出 -1	1478	https://atcoder.jp/contests/arc120/submissions/36718795

手玩一下可以发现，a[i] 左移 i 位就 +i，右移 i 位就 -i。
设 a[i] 最终和 b[j] 匹配，则有 a[i]+i-j=b[j]。
移项得 a[i]+i = b[j]+j。
设 a'[i] = a[i]+i，b'[i] = b[i]+i。
问题变成把 a' 通过邻项交换变成数组 b'，需要的最小操作次数。
这可以用树状数组解决，具体见代码。		
2022年11月22日	https://atcoder.jp/contests/abc178/tasks/abc178_f

输入 n(≤2e5) 和两个长为 n 的非降数组 a b，元素范围在 [1,n]。
如果可以重排 b，使得 a[i] != b[i] 对每个 i 都成立，则输出 Yes 和重排后的 b，否则输出 No。	输入
6
1 1 1 2 2 3
1 1 1 2 2 3
输出
Yes
2 2 3 1 1 1

输入
3
1 1 2
1 1 3
输出
No

输入
4
1 1 2 3
1 2 3 3
输出
Yes
3 3 1 2	1877	https://atcoder.jp/contests/abc178/submissions/36717693

如果 a+b 的众数出现次数 > n，根据鸽巢原理，必然会有相同的，输出 No。

否则答案一定存在，构造方法如下：

翻转 b，那么只可能存在中间一段是相同的，比如现在 a[i] = b[i] 了，那么从前面或者后面找 b[j] 和 b[i] 交换，如果交换后 a[i] != b[i] 且 a[j] != b[j]（不能影响原来的），那么就可以换。		
2022年11月21日	https://atcoder.jp/contests/abc106/tasks/abc106_d

输入 n(≤500) m(≤2e5) q(≤1e5)。
然后输入 m 个在 [1,n] 内的闭区间，即每行输入两个数表示闭区间 [L,R]。
然后输入 q 个询问，每个询问也是输入两个数表示闭区间 [p,q]。
对每个询问，输出在 [p,q] 内的完整闭区间的个数。	输入
2 3 1
1 1
1 2
2 2
1 2
输出
3
解释 输入的三个闭区间都在 [1,2] 内

输入
10 3 2
1 5
2 8
7 10
1 7
3 10
输出
1
1	1319	https://atcoder.jp/contests/abc106/submissions/36691336

定义 f[l][r] 表示在 [l,r] 内的完整闭区间个数。

容斥一下可得
f[l][r] = f[l+1][r] + f[l][r-1] - f[l+1][r-1] + a[l][r]
这里 a[l][r] 是 m 个闭区间中的 [l,r] 的个数。

这样就可以 O(1) 地回答每个询问了。		
2022年11月18日	https://atcoder.jp/contests/abc175/tasks/abc175_e

输入 n m (1≤n,m≤3000) k(≤min(2e5,r*c))，表示一个 n*m 的网格，和网格中的 k 个物品。
接下来 k 行，每行三个数 x y v(≤1e9) 表示物品的行号、列号和价值（行列号从 1 开始）。
每个网格至多有一个物品。

你从 (1,1) 出发走到 (n,m)，每步只能向下或向右。
经过物品时，你可以选或不选，且每行至多可以选三个物品。
输出你选到的物品的价值和的最大值。	输入
2 2 3
1 1 3
2 1 4
1 2 5
输出 8

输入
2 5 5
1 1 3
2 4 20
1 2 1
1 3 4
1 4 2
输出 29	1554	https://atcoder.jp/contests/abc175/submissions/36563526

定义 f[i][j][0/1/2/3] 表示从 (1,1) 走到 (i,j)，且当前行选了 0/1/2/3 个物品时的最大价值和。

转移方程如下：

f[i][j][0] = max(f[i-1][j])
f[i][j][1] = max(f[i][j-1][1], f[i][j][0]+a[i][j])
f[i][j][2] = max(f[i][j-1][2], f[i][j-1][1]+a[i][j])
f[i][j][3] = max(f[i][j-1][3], f[i][j-1][2]+a[i][j])

答案为 max(f[n][m])。

实际计算 max(f[][]) 时，f[][][0] 可以不计入。		
2022年11月17日	https://atcoder.jp/contests/abc210/tasks/abc210_d

输入 n m (2≤n,m≤1000) c(≤1e9) 和一个 n 行 m 列的矩阵 a，元素范围 [1,1e9]。
对于两个不同位置 (i,j) 和 (i',j')，输出 a[i][j] + a[i'][j'] + c*(|i-i'|+|j-j'|) 的最小值。	输入
3 4 2
1 7 7 9
9 6 3 7
7 8 6 4
输出 10

输入
3 3 1000000000
1000000 1000000 1
1000000 1000000 1000000
1 1000000 1000000
输出 1001000001	1507	https://atcoder.jp/contests/abc210/submissions/36539833

逐行遍历矩阵。

把式子拆开：

1. 如果 (i',j') 在 (i,j) 的正左/左上/正上，那么相当于求
a[i][j]+c*(i+j) + min{a[i'][j']-c*(i'+j')} 的最小值。
后面 min 的内容可以用一个 pre_min 数组维护。
正左可以用 pre_min[j-1]，左上和正上是 pre_min[j]。
代码实现时，为了避免出现 -1 下标，pre_min 的下标改成从 1 开始。

2. 如果 (i',j') 在 (i,j) 的右上，那么相当于求
a[i][j]+c*(i-j) + min{a[i'][j']-c*(i'-j')} 的最小值。
后面 min 的内容可以用一个 suf_min 数组维护。注意这个需要倒着遍历矩阵的行。

根据对称性，我们只需要考虑这两种情况。		
2022年11月16日	https://atcoder.jp/contests/abc203/tasks/abc203_d

输入 n k (1≤k≤n≤800) 和一个 n*n 的矩阵，元素范围 [0,1e9]。
定义 k*k 子矩阵的中位数为子矩阵的第 floor(k*k/2)+1 大的数。
输出中位数的最小值。
注：「第 x 大」中的 x 从 1 开始。	输入
3 2
1 7 0
5 8 11
10 4 2
输出 4

输入
3 3
1 2 3
4 5 6
7 8 9
输出 5	1622	https://atcoder.jp/contests/abc203/submissions/36519551

二分答案。

猜测答案为 up，如果子矩阵内的 ≤ up 的数至少有 ceil(k*k/2) 个，那么答案可以 ≤ up。

这是满足单调性的，所以可以用二分。

用二维前缀和加速计算。		
2022年11月15日	https://atcoder.jp/contests/abc210/tasks/abc210_e

输入 n(≤1e9) 和 m(≤1e5)，表示一个 n 个点，0 条边的图（节点编号从 0 开始），以及 m 个操作。
每个操作输入两个数 a(1≤a≤n-1) 和 c(≤1e9)，表示你可以花费 c，任意选择一个 [0,n-1] 内的数字 x，把 x 和 (x+a)%n 连边。
这 m 个操作，每个都可以执行任意多次，可以按任意顺序执行。
输出让图连通需要的最小花费。
如果无法做到，输出 -1。	输入
4 2
2 3
3 5
输出 11

输入
6 1
3 4
输出 -1	1618	https://atcoder.jp/contests/abc210/submissions/36506266

根据 Kruskal，按照 c 从小到大排序，对于每个操作，执行的次数等于执行前后连通块的数量之差。

由于每个操作需要尽可能多地执行，手玩一下可以发现，执行后的连通块数量等于 gcd(n, a0, a1, ..., ai)。

详细证明见右。

如果最后 gcd > 1，则输出 -1。	https://atcoder.jp/contests/abc210/editorial/2307	
2022年11月14日	https://atcoder.jp/contests/abc130/tasks/abc130_e

输入 n(≤2000) 和 m(≤2000)，长度分别为 n 和 m 的数组 a 和 b，元素范围 [1,1e5]。
从 a 和 b 中分别选出一个子序列（允许为空），要求这两个子序列相同。
输出有多少种不同的选法，模 1e9+7。
注意：选出的子序列不同，当且仅当下标不同（即使子序列的元素是相同的，也算不同）。	输入
2 2
1 3
3 1
输出 3
解释 注意空子序列也算

输入
2 2
1 1
1 1
输出 6	1676	https://atcoder.jp/contests/abc130/submissions/36480640

定义 f[i][j] 表示在 a 的前 i 个数和 b 的前 j 个数中选择子序列，能得到的答案。

考虑转移来源，可以是 f[i-1][j] 和 f[i][j-1]，但这两个都包含 f[i-1][j-1]，所以要减掉重复的 f[i-1][j-1]（类比二维前缀和）。

如果 a[i]=b[j]，那么我们可以把这两加到所有 f[i-1][j-1] 的末尾，再加上 1，即 a[i] 和 b[j] 单独组成子序列。

因此状态转移方程为：

f[i][j] = f[i-1][j] + f[i][j-1] - f[i-1][j-1] + (a[i]==b[j] ? f[i-1][j-1]+1 : 0)

最后答案为 f[n][m]+1（需要把空子序列加上）。		
2022年11月11日	https://atcoder.jp/contests/abc140/tasks/abc140_e

输入 n(≤1e5) 和一个 1~n 的排列 p。
输出 p 中所有长度至少为 2 的子数组的第二大元素的和。	输入
3
2 3 1
输出 5

输入
5
1 2 3 4 5
输出 30

输入
8
8 2 7 3 4 5 6 1
输出 136	1873	https://atcoder.jp/contests/abc140/submissions/36373341

方法一：贡献法，对每个 p[i]，求上个、上上个、下个、下下个更大元素的位置，分别记作 L LL R RR。
具体求法见双周赛第四题（链接见右）。
那么 p[i] 对答案的贡献为 p[i] * ((L-LL)*(R-i) + (RR-R)*(i-L))。

方法二：对于排列，其实不需要单调栈。
用双向链表思考（实现时用的数组）：
把 p 转换成双向链表，按元素值从小到大遍历 p[i]，那么方法一中的 4 个位置就是 p[i] 左边两个节点和右边两个节点。
算完 p[i] 后把 p[i] 从链表中删掉。
怎么用数组实现见代码。 

顺带一提，循环结束后，L[i] 和 R[i] 就是 p[i] 的上个/下个更大元素的位置。
如果要求更小元素位置，倒序遍历即可。	https://www.bilibili.com/video/BV1zP411P7Ej/	
2022年11月10日	https://atcoder.jp/contests/abc185/tasks/abc185_e

输入 n(≤1000) 和 m(≤1000)，长度分别为 n 和 m 的数组 a 和 b，元素范围 [1,1e9]。
从 a 中移除若干元素，得到一个子序列 a'；从 b 中移除若干元素，得到一个子序列 b'。
要求 a' 和 b' 的长度相同。
输出 (a和b总共移除的元素个数) + (a'[i]≠b'[i]的i的个数) 的最小值。	输入
4 3
1 2 1 3
1 3 1
输出 2

输入
4 6
1 3 2 4
1 5 2 6 4 3
输出 3

输入
5 5
1 1 1 1 1
2 2 2 2 2
输出 5	1468	https://atcoder.jp/contests/abc185/submissions/36352936

类似 LCS，定义 f[i][j] 表示 a 的前 i 个元素和 b 的前 j 的元素算出的答案。

- 不选 a[i] 选 b[j]：f[i-1][j]+1
- 选 a[i] 不选 b[j]：f[i][j-1]+1
- 选 a[i] 选 b[j]：f[i-1][j-1] + (a[i]==b[j] ? 0 : 1)
取最小值。

注：都不选是不用考虑的，这已经包含在 f[i-1][j] 或者 f[i][j-1] 中了。
也可以这么想：都不选是不如都选的。

边界：f[0][i]=f[i][0]=i。
答案：f[n][m]。		
2022年11月9日	https://atcoder.jp/contests/abc168/tasks/abc168_e

输入 n(≤2e5) 和 n 个点 (xi, yi)，范围 [-1e18,1e18]。
你需要从这 n 个点中选出一个非空子集，满足子集中任意两点都有 xi*xj+yi*yj ≠ 0。
子集的大小可以为 1。
输出有多少种不同的选法，模 1e9+7。

注意：可能有重复的点。	输入
3
1 2
-1 1
2 -1
输出 5

输入
10
3 2
3 2
-1 1
2 -1
-3 -9
-8 12
7 7
8 1
8 2
8 4
输出 479	1896	https://atcoder.jp/contests/abc168/submissions/36333766

把点看成向量，公式看成向量不能垂直。

根据对称性，可以把在 x 轴下方或 y 轴负半轴的向量，按原点对称。

然后分别统计在坐标原点的、在第一象限或 x 正半轴的（集合 P）、在第二象限或 y 正半轴的（集合 Q)，
其中 P 和 Q 是有可能垂直的，而 P Q 内部的向量是不会垂直的。

P 中的每个向量和其在 Q 中垂直的向量是不能同时选的，把这些找出来，当成一组，计算方案数。
具体见代码。

根据乘法原理。每组的方案数可以相乘。

最后统计 Q 中剩余向量的方案数；以及零向量的方案数，由于零向量只能选一个，所以方案数是 cnt0；别忘了去掉一个都不选的方案。		
2022年11月8日	https://atcoder.jp/contests/abc162/tasks/abc162_f

本题是力扣 198. 打家劫舍 的变形题。

输入 n (2≤n≤2e5) 和长为 n 的数组 a (-1e9≤a[i]≤1e9)。
数组 a 就是 198 题的房屋存放金额。
在本题中，你必须恰好偷 floor(n/2) 个房子。
输出你能偷窃到的最高金额。 

你能做到 O(1) 空间吗？	输入
6
1 2 3 4 5 6
输出 12

输入
5
-1000 -100 -10 0 10
输出 0

输入
10
1000000000 1000000000 1000000000 1000000000 1000000000 1000000000 1000000000 1000000000 1000000000 1000000000
输出 5000000000

输入
27
18 -28 18 28 -45 90 -45 23 -53 60 28 -74 -71 35 -26 -62 49 -77 57 24 -70 -93 69 -99 59 57 -49
输出 295	1764	https://atcoder.jp/contests/abc162/submissions/36315908

定义 f[i] 表示从前 i 个数中选 floor(i/2) 个数的最大收益。
下面讨论的下标从 1 开始。

f[0]=f[1]=0。
对于 i≥2，
如果选，那么 f[i] = f[i-2] + a[i]。
如果不选：
- 如果 i 为偶数，那么前面的选法是固定的，也就是所有奇数下标的和，记作 s。
- 如果 i 为奇数，那么需要选 (i-1)/2 个数，在不选的情况下，相当于从前 i-1 个数中选 (i-1)/2 个数，这恰好是 f[i-1]。
选或不选取 max。

答案为 f[n]。	O(1) 空间写法	
2022年11月7日	https://atcoder.jp/contests/abc171/tasks/abc171_f

输入 k(≤1e6) 和一个长度不超过 1e6 的字符串 s，由小写字母组成。
你需要在 s 中插入恰好 k 个小写字母。
输出你能得到的字符串的个数，模 1e9+7。	输入
5
oof
输出 575111451

输入
37564
whydidyoudesertme
输出 318008117	1795	https://atcoder.jp/contests/abc171/submissions/36296507

设 s 的长度为 n。

提示 1：如何避免重复统计？做一个规定，插入在 s[i] 左侧的字符，不能和 s[i] 相同，这不会影响答案的正确性。

提示 2：枚举最后一个字符的右侧插入了多少个字符，设为 i，这些字符没有限制，有 26^i 种方案。

提示 3：剩下 (n-1) + (k-i) 个字符，我们需要考虑其中 n-1 个字符的位置，这就是 C(n-1+k-i, n-1)。

提示 4：其余插入字符的方案数就是 25^(k-i)。

因此答案为 ∑26^i * C(n-1+k-i, n-1) * 25^(k-i), i=[0,k]

不知道组合数怎么算的，需要学一下逆元。		
2022年11月4日	https://atcoder.jp/contests/jsc2021/tasks/jsc2021_f

输入 n m q (≤2e5)，初始你有长为 n 的数组 a，长为 m 的数组 b，元素值都为 0，下标从 1 开始。
然后输入 q 个询问，每个询问形如 t x y (1≤y≤1e8)。
t=1，表示把 a[x]=y；t=2，表示把 b[x]=y。
每次修改后，输出 ∑∑max(a[i],b[j])，这里 i 取遍 [1,n]，j 取遍 [1,m]。	输入
2 2 4
1 1 10
2 1 20
2 2 5
1 1 30
输出
20
50
55
85

输入
3 3 5
1 3 10
2 1 7
1 3 5
2 2 10
2 1 1
输出
30
44
31
56
42

输入
200000 200000 4
2 112219 100000000
1 73821 100000000
2 26402 100000000
1 73821 100000000
输出
20000000000000
39999900000000
59999800000000
59999800000000	1954	https://atcoder.jp/contests/jsc2021/submissions/36189511
https://atcoder.jp/contests/jsc2021/submissions/36189772

提示 1：元素的顺序并没有那么重要。

提示 2：每次修改时，只需要知道另一个数组中，有多少个数比自己小（这些数的个数乘上自己），以及≥自己的数的和是多少。

最好写的应该是离散化+树状数组。  
注意把 0 也加到离散化中。		
2022年11月3日	https://atcoder.jp/contests/abc201/tasks/abc201_e

输入 n(≤2e5) 和一棵有边权的树的 n-1 条边，节点编号从 1 开始，边权范围 [0,2^60)。
定义 xor(i,j) 表示从 i 到 j 的简单路径上的边权的异或和。
累加所有满足 1≤i<j≤n 的 xor(i,j)，对结果模 1e9+7 后输出。 	输入
3
1 2 1
1 3 3
输出 6

输入
5
3 5 2
2 3 2
1 5 1
4 5 13
输出 62

输入
10
5 7 459221860242673109
6 8 248001948488076933
3 5 371922579800289138
2 5 773108338386747788
6 10 181747352791505823
1 3 803225386673329326
7 8 139939802736535485
9 10 657980865814127926
2 4 146378247587539124
输出 241240228	1694	https://atcoder.jp/contests/abc201/submissions/36166044

提示 1：逐位考虑。也就是假设边权只有 0 和 1。

提示 2：xor(i,j) = xor(1,i) ^ xor(1,j)。

提示 3：DFS，统计 xor(1,i) 中 1 的个数，记作 c。由于只有 1 和 0 异或才能是 1，这个比特位上的答案为 c * (n-c)。 		
2022年11月2日	https://atcoder.jp/contests/abl/tasks/abl_e

输入 n(≤2e5) 和 q(≤2e5)。
初始有一个长为 n 的字符串 s，所有字符都是 1，s 的下标从 1 开始。
然后输入 q 个替换操作，每个操作输入 L,R (1≤L≤R≤n) 和 d (1≤d≤9)。
你需要把 s 的 [L,R] 内的所有字符替换为 d。
对每个操作，把替换后的 s 看成一个十进制数，输出这个数模 998244353 的结果。	输入
8 5
3 6 2
1 4 7
3 8 3
2 2 2
4 5 1
输出
11222211
77772211
77333333
72333333
72311333

输入
200000 1
123 456 7
输出
641437905	1706	https://atcoder.jp/contests/abl/submissions/36147029

珂朵莉树练习题。

预处理 11...1 (i 个 1) 以及 10^i 的值，就可以套模板了，核心在于更新答案的逻辑。

比如把 111xxx 替换成 333xxx，那么 ans 增加了 (3-1)*111*1000。		
2022年11月1日	https://atcoder.jp/contests/abc173/tasks/abc173_f

输入 n (2≤n≤2e5) 和一棵树的 n-1 条边（节点编号从 1 开始）。
定义 f(L,R) 表示用节点编号在 [L,R] 内的点组成的连通块的个数（边的两个端点必须都在 [L,R] 内）。
输出满足 1≤L≤R≤n 的所有 f(L,R) 的和。	输入
3
1 3
2 3
输出 7

输入
2
1 2
输出 3

输入
10
5 3
5 7
8 9
1 9
9 10
8 4
7 4
6 10
7 2
输出 113	1892	https://atcoder.jp/contests/abc173/submissions/36127951

提示 1：假设一开始没有边，答案是多少？

提示 2：把边一条一条地加到树上，每加一条边，答案减少了多少？

提示 3：任何一个包含该边的两端点的区间 [L,R]，连通块的个数都会减少 1。有多少个这样的区间？		
2022年10月31日	https://atcoder.jp/contests/abc165/tasks/abc165_f

输入 n (2≤n≤2e5) 和长为 n 的数组 a (1≤a[i]≤1e9)，表示每个节点的点权。
然后输入一棵树的 n-1 条边（节点编号从 1 开始）。
输出 n 个数，第 i 个数为从节点 1 到节点 i 的路径上点权的 LIS 长度。

注：LIS 指最长严格递增子序列。	输入
10
1 2 5 3 4 6 7 3 2 4
1 2
2 3
3 4
4 5
3 6
6 7
1 8
8 9
9 10
输出
1
2
3
3
4
4
5
2
2
3	1843（实际应该没这么高）	https://atcoder.jp/contests/abc165/submissions/12963027

DFS 这棵树，把路径看成序列，用 O(nlogn) 的做法求 LIS。
回溯的时候注意还原现场。		
2022年10月28日	https://atcoder.jp/contests/abc252/tasks/abc252_f

输入 n (2≤n≤2e5) 和 L(≤1e15)，长为 n 的数组 a (1≤a[i]≤1e9, sum(a)≤L)。
有一根长为 L 的面包，需要分给 n 个小孩，每个小孩需要长度恰好为 a[i] 的面包。
对于任意一根长为 k 的面包，你可以切成两段，要求每段长度都为整数，切的花费为 k。
输出最小花费。	输入
5 7
1 2 1 2 1
输出 16

输入
3 1000000000000000
1000000000 1000000000 1000000000
输出 1000005000000000	1609	https://atcoder.jp/contests/abc252/submissions/36006064

逆向思维，把分割看成合并。这样就转换成经典的 Huffman 问题，用最小堆实现。
如果 sum(a) < L，可以把多余的面包额外当成一个新的小孩需要的。		
2022年10月27日	https://atcoder.jp/contests/abc255/tasks/abc255_e

输入 n (2≤n≤1e5) 和 m(≤10)，长为 n-1 的数组 s 和长为 m 的严格递增数组 x，元素值范围在 [-1e9,1e9]。
数组 x 中的元素叫做幸运数。
对于一个长为 n 的序列 a，如果所有相邻元素满足 a[i]+a[i+1]=s[i]，则称为一个好序列。
输出好序列中最多能有多少个数是幸运数（重复数字也算，见样例）。	输入
9 2
2 3 3 4 -4 -7 -4 -1
-1 5
输出 4
解释 a=[3,−1,4,−1,5,−9,2,−6,5]

输入
20 10
-183260318 206417795 409343217 238245886 138964265 -415224774 -499400499 -313180261 283784093 498751662 668946791 965735441 382033304 177367159 31017484 27914238 757966050 878978971 73210901
-470019195 -379631053 -287722161 -231146414 -84796739 328710269 355719851 416979387 431167199 498905398
输出 8	1519	https://www.luogu.com.cn/blog/endlesscheng/solution-at-abc255-e		
2022年10月26日	https://atcoder.jp/contests/abc169/tasks/abc169_e

输入 n (2≤n≤2e5) 和 n 个区间的左右端点，区间范围在 [1,1e9]。
每个区间内选一个整数，然后计算这 n 个整数的中位数。你能得到多少个不同的中位数？
注：偶数长度的中位数是中间两个数的平均值（没有下取整）。	输入
2
1 2
2 3
输出 3

输入
3
100 100
10 10000
1 1000000000
输出 9991	1353	https://atcoder.jp/contests/abc169/submissions/35971735

上下界思想，计算中位数的最小值和最大值，然后范围内的都可以取到。

由于偶数长度的中位数会存在小数点后为 0.5 的情况，所以答案是可以 *2 的。具体见代码。		
2022年10月25日	https://atcoder.jp/contests/abc251/tasks/abc251_e

输入 n (2≤n≤3e5) 和长为 n 的数组 a (1≤a[i]≤1e9)，下标从 1 开始。
有 n 只动物围成一圈，你可以花费 a[i] 喂食动物 i 和 i+1。特别地，你可以花费 a[n] 喂食动物 n 和 1。
输出喂食所有动物需要的最小花费。每只动物可以重复喂食。	输入
5
2 5 3 2 5
输出 7

输入
20
29 27 79 27 30 4 93 89 44 88 70 75 96 3 78 39 97 12 53 62
输出 426	1227	https://www.luogu.com.cn/blog/endlesscheng/solution-at-abc251-e		
2022年10月24日	https://atcoder.jp/contests/abc237/tasks/abc237_f

输入 n (3≤n≤1000) 和 m (3≤m≤10)。
输出有多少个满足如下条件的数组：
1. 数组长度为 n；
2. 数组元素范围在 [1,m]；
3. 数组的 LIS 的长度恰好等于 3。
对答案模 998244353。

注：LIS 指最长严格上升子序列。	输入 4 5
输出 135

输入 3 4
输出 4

输入 111 3
输出 144980434	1857	https://atcoder.jp/contests/abc237/submissions/35930996

回忆下 LIS 的 O(nlogn) 做法，在那个做法中，我们需要维护一个有序数组 arr。

定义 f[i][x][y][z] 表示长为 i 且 arr=[x,y,z] 的符合题目要求的数组个数。

计算 f[i][x][y][z] 时，枚举第 i 个数是多少，按照 LIS 的 O(nlogn) 做法转移到对应的 x/y/z 上。

代码实现时，可以初始化 f[0][m+1][m+1][m+1] = 1，表示 arr=[inf,inf,inf] 的初始状态。
答案为 sum(f[n][x][y][z])，1≤x<y<z≤m。

为了节省内存，可以将元素值改为从 0 开始。		
2022年10月21日	https://atcoder.jp/contests/abc250/tasks/abc250_e

输入 n(≤2e5) 和两个长为 n 的数组 a 和 b，元素范围在 [1,1e9]。
然后输入 q(≤2e5) 表示 q 个询问，每个询问输入两个数 x 和 y，范围在 [1,n]。
对每个询问，设 a 的前 x 个元素去重得到集合 A，b 的前 y 个元素去重得到集合 B，如果 A = B，输出 "Yes"，否则输出 "No"。	输入
5
1 2 3 4 5
1 2 2 4 3
7
1 1
2 2
2 3
3 3
4 4
4 5
5 5
输出
Yes
Yes
Yes
No
No
Yes
No	1421	https://atcoder.jp/contests/abc250/submissions/35814659

为方便处理，首先把数组 a 转换成升序：
例如，先把 31412 置换为 12324，然后求前缀最大值得到 12334（不影响答案的正确性）。

数组 b 也做同样的置换，然后我们需要找到一个前缀，恰好包含 1~x 所有数字（即不能有断开的部分）实现方法见 https://leetcode.cn/problems/max-chunks-to-make-sorted/ 中提到的技巧。
这样可以标记 b[i] 应该匹配到 a 中的哪个数。		
2022年10月20日	https://atcoder.jp/contests/abc221/tasks/abc221_e

【更新通知】
从今天开始，带你们刷 AtCoder 啦！难度分大概是之前的 -400

输入 n(≤3e5) 和长为 n 的数组 a (1≤a[i]≤1e9)。
输出有多少个 a 的长度至少为 2 的子序列，满足子序列的第一项 ≤ 子序列的最后一项。
由于答案很大，输出答案模 998244353 的结果。 

注：子序列不要求连续。	输入
3
1 2 1
输出 3
解释 [1,2], [1,1], [1,2,1]

输入
3
1 2 2
输出 4
解释 [1,2], [1,2], [2,2], [1,2,2]

输入
3
3 2 1
输出 0

输入
10
198495780 28463047 859606611 212983738 946249513 789612890 782044670 700201033 367981604 302538501
输出 830	1515	https://atcoder.jp/contests/abc221/submissions/35791225

这是一道基于逆序对的变形题。
不了解逆序对的同学，可以先看看我的讲解 https://www.bilibili.com/video/BV1tW4y1e7rb

用树状数组实现，这里的问题是，如何把 2 的幂次（中间的子序列的个数）也考虑进去。

我们可以把 2^(i-j) 转换成 2^i / 2^j，那么把 2^j 的逆元加到树状数组中即可。

注意需要离散化。

代码中展示了一个巧妙计算逆元的技巧。		
2022年10月19日	https://codeforces.com/problemset/problem/1208/E

输入 n(≤1e6) 和 w(≤1e6)，表示一个 n 行 w 列的表格。
然后输入 n 个数组，第 i 个数组放在第 i 行中。
输入的格式为：第一个数字表示数组的长度 m(≤w)，然后输入一个长为 m 的数组，元素范围 [-1e9,1e9]。
保证所有数组的长度之和不超过 1e6。

你可以滑动任意一行的整个数组。
对表格的每一列，输出这一列的元素和的最大值。
注意：每一列是单独计算的，不同列可以有不同的滑动方案。	输入
3 3
3 2 4 8
2 2 5
2 6 3
输出
10 15 16 
解释 如图

输入
2 2
2 7 8
1 -8
输出
7 8 	2200	https://codeforces.com/problemset/submission/1208/176949672
202ms with 读入优化 https://codeforces.com/contest/1208/submission/176961129

考虑每行能给答案带来多少贡献。

如果 2m <= w，那么对于最左边的 m-1 列和最右边的 m-1 列，选择方案是有约束的（前缀最大值/后缀最大值），其余列可以取 max(max(a),0)，这可以用差分数组统计。

如果 2m > w，那么问题变成长为 w-m+1 的滑动窗口最大值。这可以用单调队列实现，做法见力扣 239 题 https://leetcode.cn/problems/sliding-window-maximum/

最后求差分数组的前缀和，即为答案。		
2022年10月18日	https://codeforces.com/problemset/problem/1420/D

输入 n, k (1≤k≤n≤3e5) 和 n 个闭区间，区间的范围在 [1,1e9]。
你需要从 n 个区间中选择 k 个区间，且这 k 个区间的交集不为空。
输出方案数模 998244353 的结果。	输入
7 3
1 7
3 8
4 5
6 7
1 3
5 10
8 9
输出 9

输入
3 1
1 1
2 2
3 3
输出 3

输入
3 2
1 1
2 2
3 3
输出 0

输入
3 3
1 3
2 3
3 3
输出 1

输入
5 2
1 3
2 4
3 5
4 6
5 7
输出 7	1800	https://codeforces.com/contest/1420/submission/176225922
https://codeforces.com/contest/1420/submission/176225199

对于每个区间的左端点 L，可能存在某些选法，是以 L 为交集的左端点的。
如果有 m 个区间包含 L，且左端点为 L 的区间有 c 个，那么以 L 为交集左端点的方案数为 C(m, k) - C(m-c, k)，即减去不以 L 为交集左端点的方案数，防止重复统计。

两种实现方案：扫描线 / 差分哈希表。

有关组合数 + 逆元，请查阅相关资料。		
2022年10月17日	https://codeforces.com/problemset/problem/767/C

输入 n(3≤n≤1e6)，表示一颗有 n 个节点的有根树，节点编号从 1 开始。
每行输入两个数，表示当前节点的父节点编号（如果是 0 表示当前节点是根节点），以及节点的点权，范围在 [-100,100]。
例如节点 1 的父节点为 2，则表示一条 2->1 的边。

你需要删除两条边，将这棵树分成三个连通块，且每个连通块的点权和相等。
假设删除的边是 a->b 和 c->d，你需要输出 b 和 d。如果有多种方案，输出任意一种。
如果无法做到，输出 -1。	输入
6
2 4
0 5
4 2
2 1
1 1
4 2
输出 1 4
解释 见右图

输入
6
2 4
0 6
4 2
2 1
1 1
4 2
输出 -1	2000	https://codeforces.com/contest/767/submission/174193693

做法类似双周赛 t4，每统计到一个点权和等于 total / 3 的连通块，就断开它和父节点的边。取前两个作为答案。

https://www.bilibili.com/video/BV1cV4y157BY		
2022年10月14日	https://codeforces.com/problemset/problem/1407/D

输入 n(≤3e5) 和一个长为 n 的数组 h (1≤h[i]≤1e9)。
满足如下三个条件之一，就可以从 i 跳到 j (i<j)：
1. i+1=j
2. max(h[i+1],...,h[j-1]) < min(h[i],h[j])
3. min(h[i+1],...,h[j-1]) > max(h[i],h[j])
输出从 1 跳到 n 最少需要多少步。

相似题目：LC2297 https://leetcode.cn/problems/jump-game-viii/	输入
5
1 3 1 4 5
输出 3

输入
4
4 2 2 4
输出 1

输入
2
1 1
输出 1

输入
5
100 1 100 1 100
输出 2	2200	https://www.luogu.com.cn/blog/173660/solution-cf1407d

画画图，找找转移来源。转移来源有什么规律？

关键：转移来源一定在单调栈上，不断出栈直到不满足条件。

也可以把 DP 放到单调栈里面：https://codeforces.com/contest/1407/submission/175820402		
2022年10月13日	https://codeforces.com/problemset/problem/1286/A

输入 n(≤100) 和一个长为 n 的数组 p，p 原本是一个 1~n 的排列，但是有些数字丢失了，丢失的数字用 0 表示。
你需要还原 p，使得 p 中相邻元素奇偶性不同的对数最少。输出这个最小值。	输入
5
0 5 0 2 3
输出 2

输入
7
1 0 0 5 0 0 2
输出 1	1800	https://www.luogu.com.cn/blog/endlesscheng/solution-cf1286a

我的洛谷题解👆		
2022年10月12日	xhttps://codeforces.com/problemset/problem/1651/D

输入 n(≤2e5) 和 n 个二维平面上的互不相同的整点，坐标范围 [1,2e5]。
对每个整点，输出离它曼哈顿距离最近的，且不在输入中的整点。
两点的曼哈顿距离=横坐标之差的绝对值+纵坐标之差的绝对值。	输入
6
2 2
1 2
2 1
3 2
2 3
5 5
输出
1 1
1 1
2 0
3 1
2 4
5 4

输入
8
4 4
2 4
2 2
2 3
1 4
4 2
1 3
3 3
输出
4 3
2 5
2 1
2 5
1 5
4 1
1 2
3 2	1900	https://codeforces.com/contest/1651/submission/175313097

把输入想象成海岛（群岛），对每个点，求其最近的海岸点。

从最特殊的点入手，即海滩上的点，这些点可以直接取四周中的一个不在输入中的点作为答案。

从这些点出发，写一个 BFS，去求出那些被包围的点的答案。

需要一些实现能力。我的代码中用删除操作来代替 vis 数组。

相似题目：https://leetcode.cn/problems/pacific-atlantic-water-flow/		
2022年10月11日	https://codeforces.com/contest/988/problem/F

输入正整数 dst(≤2000), n(≤(dst+1)/2) 和 m(≤2000)。
然后输入 n 个互不相交的下雨区间，左右端点满足 0≤L<R≤dst。
然后输入 m 行，每行两个数表示雨伞的位置 x[i](≤dst) 和重量 w[i](≤1e5)。

你需要从 0 出发走到 dst。在下雨区间内移动必须打伞（区间端点处不算下雨）。
你可以中途换伞。
带着伞移动时，每走一单位长度，消耗的耐力等于伞的重量。
你可以丢掉伞，空手移动时消耗的耐力为零。
输出到达 dst 至少需要消耗多少耐力。如果无法到达 dst，输出 -1。

进阶：请写一个和坐标范围无关的代码，即使坐标范围达到 1e9 也可以通过。	输入
10 2 4
3 7
8 10
0 10
3 4
8 1
1 2
输出 14

输入
10 1 1
0 9
0 5
输出 45

输入
10 1 1
0 9
1 5
输出 -1	2100 (个人估计 1900)
昨天的题可能有帮助	https://codeforces.com/contest/988/submission/175402975

为方便计算答案，假设 dst 处（或者最后一个下雨的位置）还有一把伞。

定义 f[i] 表示到达 x[i] 时，至少需要消耗的耐力。
记 x'[i] 为 x[i] 左侧最近有雨的位置（这可以用双指针求出），我们可以在这里丢伞。
枚举上一把伞的位置，有
f[i] = min(f[j] + (x'[i] - x[j]) * w[j]), 其中 j 需满足 x[j] < x'[i]。

详细注释见代码，时间复杂度 O(m^2)。		
2022年10月10日	https://codeforces.com/problemset/problem/38/E

输入 n(≤3000)，表示在一维数轴上有 n 颗大小忽略不计的弹珠。
然后输入 n 对数字，每对数字表示这颗弹珠在数轴上的位置 xi，以及把这颗弹珠固定在 xi 上的花费 ci，数据范围均在 [-1e9,1e9] 之间，且 xi 互不相同。注意 ci 可以为负。

选择若干弹珠固定后，所有未固定的弹珠向左滚动，直到碰到固定住的弹珠。
总花费 = 固定弹珠的花费之和 + 所有未固定的弹珠的滚动距离之和。
输出总花费的最小值。
注：根据题意，最左边的弹珠一定要固定。	输入
3
2 3
3 4
1 2
输出 5

输入
4
1 7
3 1
5 10
6 1
输出 11	1800	https://codeforces.com/contest/38/submission/175293285
https://codeforces.com/contest/38/submission/175293327 滚动数组

按照坐标排序。

定义 f[i][j] 表示考虑前 i 颗弹珠，且最后一个固定的弹珠是 j 时的最小花费。
考虑第 i 颗弹珠是否固定，则有：
f[i][j] = f[i-1][j] + x[i] - x[j], j < i
f[i][i] = min(f[i-1][j]) + c[i]

初始 f[0][0] = c[0]，
答案 min(f[n-1])。

代码实现时，第一个维度可以去掉。		
2022年10月7日	https://codeforces.com/problemset/problem/862/E

输入 n, m (1≤n≤m≤1e5), q(≤1e5) 和长为 n 的数组 a (-1e9≤a[i]≤1e9)，长为 m 的数组 b (-1e9≤a[i]≤1e9)，下标从 1 开始。
定义 f(j) = abs(c1-c2+c3-c4...cn), 其中 ci = a[i]-b[i+j]。
首先，输出 f(0), f(1), ..., f(m-n) 的最小值。
然后输入 q 个询问，每个询问输入 l, r (1≤l≤r≤n), x(-1e9≤x≤1e9)，表示把 a[l], a[l+1], ..., a[r] 都加上 x，之后输出 f(0), f(1), ..., f(m-n) 的最小值。+x 的影响是永久的。	输入
5 6 3
1 2 3 4 5
1 2 3 4 5 6
1 1 10
1 1 -9
1 5 -1
输出
0
9
0
0
解释 答案分别为 f(0) f(1) f(1) f(0)	2100	https://codeforces.com/contest/862/submission/174832813

提示 1：对于 f(j)，把 a[i] 和 b[i+j] 分别计算。
设 a[i] 的交替和为 sa，b[i+j] 的交替和为 sb[j]，则 f(j) = abs(sa-sb[j])。

提示 2：用滑动窗口计算 sb[j]。

提示 3：去掉绝对值负号，问题变成离 0 最近的 sa-sb[j]。
由于 sa 是定值，问题又变成离 sa 最近的 sb[j]。

提示 4：把 sb[] 排序，然后二分。

提示 5：对于区间 +x 操作，注意到我们算的是交替和，中间的 +x -x 互相抵消，因此对 sa 的影响只有 +x -x 不变 这三种，根据 l 和 r 的奇偶性分类讨论。		
2022年10月6日	https://codeforces.com/problemset/problem/754/D

输入 n, k (1≤k≤n≤3e5) 和 n 个闭区间，区间左右端点在 [-1e9,1e9] 内，区间的编号从 1 开始。
请你选择 k 个区间，使得这 k 个区间的交集的大小尽量大（只考虑整数），输出这个最大值，以及对应的区间的编号。

思考题：如果改成并集呢？	输入
4 2
1 100
40 70
120 130
125 180
输出
31
1 2 

输入
3 2
1 12
15 20
25 30
输出
0
1 2 

输入
5 2
1 10
5 15
14 50
30 70
99 100
输出
21
3 4 	2100
输出方案也许值 200 分	https://codeforces.com/problemset/submission/754/174797228
Python https://codeforces.com/problemset/submission/754/174840684

提示 1：按照区间左端点排序。

提示 2：遍历区间，考虑把第 i 个区间的左端点当作交集的左端点，那么 i 左边这些区间都是可以选的，贪心来说，选其中第 k 大的右端点当作交集的右端点。

提示 3：用最小堆维护第 k 大的右端点。

提示 4：更新答案时，记录对应的左端点，从而知道并集的左右端点。
最后再次遍历区间，输出 k 个包含并集的区间编号。		
2022年10月5日	https://codeforces.com/problemset/problem/811/C

输入 n(≤5000) 和一个长为 n 的数组 a (0≤a[i]≤5000)。
你需要从 a 中选取若干个互不相交的子数组，且对于每个子数组 b，b 中的元素不会出现在 b 外面。
对每个子数组去重，求异或和，然后把所有异或和相加，输出相加后的最大值。

注：子数组是连续的。
注：你不需要把每个 a[i] 都选上，见样例二。	输入
6
4 4 2 5 2 3
输出 14
解释 选择 [4,4] [2,5,2] [3]，4+(2^5)+3=14

输入
9
5 1 3 1 5 2 4 2 5
输出 9
解释 选择 [3] [2,4,2]，3+(2^4)=9	1900	左右位置：https://codeforces.com/contest/811/submission/174568758
元素个数（代码更短）：https://codeforces.com/contest/811/submission/174568255

dp[i] = dp[j-1] + xor(unique(j..i)) if a[j..i] is valid.
判断合法有两种写法，见上面的代码。		
2022年10月4日	https://codeforces.com/problemset/problem/863/E

输入 n(≤2e5) 和 n 个闭区间，区间左右端点在 [0,1e9] 内，区间的编号从 1 开始。
你需要从中删除一个区间，使得删除前后，所有区间的并集不变（只考虑整数）。
如果不存在这样的区间，输出 -1；否则输出该区间的编号。	输入
3
1 3
4 6
1 7
输出 1

输入
2
0 10
0 10
输出 1

输入
3
1 2
3 4
6 8
输出 -1

输入
3
1 2
2 3
3 4
输出 2	2000	https://codeforces.com/contest/863/submission/174510216

方法一：会议室/上下车模型。把每个区间都+1，如果存在一个区间，其范围内的值都 ≥2，那么可以移除该区间。
实现：离散化/动态开点+线段树维护区间最小值。
注意把区间右端点也加入，保证「空位」也被考虑进去了。

方法二：贪心。按照左端点从小到大排序，左端点相同按右端点从大到小排序。
先遍历一遍，如果 a[i-1].right ≥ a[i].right，那么区间 a[i] 被区间 a[i-1] 包含。
否则说明右端点也单调递增，那么再次遍历，判断当前区间的左右相邻区间的并集能否包含当前区间，即 a[i-1].right+1 ≥ a[i+1].left。
实现见代码。		
2022年10月3日	https://codeforces.com/problemset/problem/276/D

输入 L 和 R (1≤L≤R≤1e18)。
输出区间 [L,R] 内任意两个数的异或的最大值。

思考题：如果还要求异或不超过某个 limit 呢？	输入 1 2
输出 3

输入 8 16
输出 31

输入 1 1
输出 0	1700	https://codeforces.com/contest/276/submission/118793107

如果 L 和 R 的二进制长度不一样，例如 L=2，R=9，那么我们可以用 7^8 得到最大的异或和 15。

推广，如果 L 和 R 的二进制长度一样，那么我们可以从高到低找到第一个二进制不同的位置，转换到长度不一样的情况。

总之，答案为 (1 << bit_length(L ^ R)) - 1。

思考题代码 https://github.com/EndlessCheng/codeforces-go/blob/master/copypasta/bits.go#L632		
2022年10月1日	https://codeforces.com/problemset/problem/965/D

输入 w(≤1e5) L(<w) 和一个长为 w-1 的数组 a (0≤a[i]≤1e4，下标从 1 开始)。
有一条宽为 w 的河，青蛙们在位置 0 处，位置 i 处有 a[i] 个石头，位置 w 为河对岸。
青蛙单次跳跃距离不超过 L。每个石头只能被一只青蛙用一次。
输出最多有多少只青蛙能过河。

相似题目：蓝桥杯2022年第十三届省赛真题-青蛙过河
https://www.dotcpp.com/oj/problem2667.html	输入
10 5
0 0 1 0 2 0 0 1 0
输出 3
解释 0-5-10, 0-5-10, 0-3-8-10

输入
10 3
1 1 1 1 2 1 1 1 1
输出 3
解释 0-3-6-9-10, 0-2-5-8-10, 0-1-4-7-10	1900	https://codeforces.com/contest/965/submission/174185143

答案为长为 L 的最小子数组和。

证明：看成是网络流问题，由于最大流等于最小割，得证。		
2022年9月30日	https://codeforces.com/problemset/problem/1178/E

输入一个长度不超过 1e6 的字符串 s，仅包含 a b c，且相邻字符不同。
你需要找到一个 s 的回文子序列 t，且 t 的长度至少是 s 长度的一半（下取整）。
输出任意一个符合要求的 t。
注意子序列不要求连续。	输入 cacbac
输出 aba

输入 abc
输出 a

输入 cbacacacbcbababacbcb
输出 cbaaacbcaaabc	1900	https://codeforces.com/contest/1178/submission/173928518
位运算做法 https://codeforces.com/contest/1178/submission/173928055
Python https://codeforces.com/contest/1178/submission/173920506

提示 1：根据鸽巢原理，s 的前两个字符和后两个字符中，必然有两个相同的字符，且由于 s 的相邻字符不同，这两个相同字符必然一个在前两个字符中，另一个在后两个字符中。

提示 2：去掉首尾各两个字符，按同样的方法处理剩余字符。

提示 3：如果剩余字符不足 4 个，可以任取一个字符，作为 t 的回文中心。		
2022年9月29日	https://codeforces.com/problemset/problem/558/C

输入 n(≤1e5) 和一个长为 n 的数组 a (1≤a[i]≤1e5)。
每次操作你可以将某个 a[i] 乘二或除二（下取整）。
输出至少需要多少次操作，可以让 a 的所有数都相同。

你能做到 O(nlogU) 的时间复杂度吗？ U=max(a)	输入
3
4 8 2
输出 2
解释 都变成 4。

输入
3
3 5 6
输出 5
解释 都变成 1。	1900	https://codeforces.com/contest/558/submission/173900538

方法一：朴素思路

提示 1：对于任意一个 a[i]，它能操作出多少个不同的数字？
观察：每个数字不会超过 max(a)，继续增大是没有意义的。
不妨以 a[0] 为准，设所有数字最终变成 x，那么 x 必然是由 a[0] 的二进制表示的某个前缀+若干个尾 0 组成（即 x = a[0] 右移若干位再左移若干位）。因此得到的不同 x 不会超过 O(17^2) 个。

提示 2：统计每个 a[i] 生成的 x，以及 a[i] 变成 x 需要操作多少次。如果能生成 n 个 x，那么对应的的操作次数就可能是答案（取最小值）。


方法二：优化思路（上面链接的写法）

方法一需要 O(17^2 * n) 的时间，可以进一步优化到 O(17n)。

统计每个前缀的出现次数 cnt[v]，以及减小到该前缀所需的操作次数 sum[v]。
那么最大的满足 cnt[v] = n 的 v 就是 x 的最小值，继续往下减小是没有意义的（最长公共前缀）。
对应的 sum[v] 也是答案的最大值。
根据中位数贪心的启发，尝试 2v 4v 8v ... 看能否得到更优解。
考虑操作次数的变化量，从 v 到 2v，有 cnt[2v] 个前缀可以少操作一次，有 n-cnt[2v] 个前缀要多操作一次。如果 cnt[2v] > n-cnt[2v]，那么所有数变成 2v 会得到更小的操作次数。依此类推。
如果 cnt[2v] > n-cnt[2v] 不成立，其实可以直接退出循环，这是因为数字越大 cnt 值就越小。		
2022年9月28日	https://codeforces.com/problemset/problem/292/E

输入 n(≤1e5) 和 m (≤1e5)，两个长度都为 n 的数组 a 和 b（元素范围在 [-1e9,1e9] 内，下标从 1 开始）。
然后输入 m 个操作：
操作 1 形如 1 x y k，表示把 a 的区间 [x,x+k-1] 的元素拷贝到 b 的区间 [y,y+k-1] 上（输入保证下标不越界）。
操作 2 形如 2 x，输出 b[x]。

思考题：双向 copy 怎么做？  @Hush@Aging	输入
5 10
1 2 0 -1 3
3 1 5 -2 0
2 5
1 3 3 3
2 5
2 4
2 1
1 2 1 4
2 1
2 4
1 4 2 1
2 2
输出
0
3
-1
3
2
3
-1	1900	https://codeforces.com/contest/292/submission/173659179
https://codeforces.com/contest/292/submission/173666674

提示 1：操作 1 可以转换为，把区间 [y,y+k-1] 上都打一个「偏移量」标记 x-y。设位置 i 的标记为 delta[i]，那么在输出 b[x] 的时候，输出 a[x+delta[x]] 即可。

提示 2：转换成一个区间赋值，单点查询问题。

提示 3：这可以用线段树或珂朵莉树解决。

由于操作的特殊性，线段树只需要一个 tag 数组。

注：本题还可以用 splay 模拟。

双向操作大概要一个支持可持久化+分裂合并的数据结构。		
2022年9月27日	https://codeforces.com/problemset/problem/274/B

输入 n(≤1e5)，表示一棵有 n 个节点的树。
然后输入 n-1 条边：这条边所连接的两点的编号（从 1 开始）。
最后输入 n 个数，表示每个节点的值 a[i](-1e9≤a[i]≤1e9)。

每次操作，你可以选择一个包含节点 1 的连通块，把所有点的值都 +1 或都 -1。
输出把树上所有节点的值都变为 0 的最少操作次数。	输入
3
1 2
1 3
1 -1 1
输出
3	1800	https://codeforces.com/contest/274/submission/173643473

提示 1：根据题意，以 1 为根，需要先把叶子节点变为 0，才能处理父节点。

提示 2：把处理子节点的操作次数，累加到当前节点上。

提示 3：由于子节点有负有正，需要分别计算对应的操作次数，并返回，继续传递给祖先节点。		
2022年9月26日	https://codeforces.com/problemset/problem/1213/G

输入 n(≤2e5) 和 m(≤2e5)，表示一棵有 n 个节点的树，和 m 个询问。
然后输入 n-1 条边：这条边所连接的两点的编号（从 1 开始），以及边权(1≤边权≤2e5)。
最后输入 m 个询问 q[i](1≤q[i]≤2e5)，你需要对每个询问，输出树上有多少条路径，要求路径至少有两个节点且无重复节点，且路径上的最大边权不超过 q[i]。
注意 a->b 和 b->a 的路径只统计一次。

相关题目：昨天周赛第四题 https://leetcode.cn/problems/number-of-good-paths/	输入
7 5
1 2 1
3 2 3
2 4 1
4 5 2
5 7 4
3 6 2
5 2 3 4 1
输出
21 7 15 21 3 

输入
1 2
1 2
输出
0 0 

输入
3 3
1 2 1
2 3 2
1 3 2
输出
1 3 3 	1800	https://codeforces.com/contest/1213/submission/160406169

提示 1：离线询问，把边权和询问都从小到大排序。

提示 2：遍历询问，用并查集把小于 q[i] 的边都合并。
合并时，两个连通块的大小的乘积累加到答案中。		
2022年9月23日	https://codeforces.com/problemset/problem/522/D

输入 n(≤5e5) 和 m(≤5e5)；然后输入一个长为 n 的数组 a(-1e9≤a[i]≤1e9)，数组下标从 1 开始；然后输入 m 个询问，每个询问表示一个数组 a 内的闭区间 [L,R] (1≤L≤R≤n)。

对每个询问，输出区间内的相同元素下标之间的最小差值。如果区间内不存在相同元素，输出 -1。

相似题目：https://www.luogu.com.cn/problem/P1972	输入
5 3
1 1 2 3 2
1 5
2 4
3 5
输出
1
-1
2

输入
6 5
1 2 1 3 2 3
4 6
1 3
2 5
2 4
1 6
输出
2
2
3
-1
2	2000	https://codeforces.com/contest/522/submission/173138916

本题用到的技巧十分经典（指提示 4），如果你对此题没有思路，请务必掌握这一技巧。

提示 1：在相同元素中，只需要考虑相邻的元素。换句话说，这些元素对可以看成是若干线段。

提示 2：问题转换成查询区间内的最短线段。

提示 3：把询问离线，按照右端点排序。

提示 4：把提示 1 中的线段长度记录在线段的左端点上。

提示 5：遍历排序后的询问 [L,R]，如果位置 R 有线段的右端点，则更新线段左端点处的线段长度，我们最后要做的就是查询区间 [L,R] 内的最小值。

提示 6：用线段树实现。

线段长度可以一边遍历数组 a，一边用一个 last map 记录。		
2022年9月22日	https://codeforces.com/problemset/problem/555/B

输入 n(2≤n≤2e5) 和 m(1≤m≤2e5)，然后输入 n 行，每行有两个数，表示一个闭区间（1≤L≤R≤1e18），然后输入一个长为 m 的数组 a (1≤a[i]≤1e18)。输入保证区间之间没有交集，且上一个区间的右端点小于下一个区间的左端点。

你有 m 座桥，每座桥的长为 a[i]，你需要选择 n-1 座桥连接所有相邻的区间。
要求桥的两个端点分别落在这两个闭区间内（这两个端点的差等于桥长）。

如果无法做到，输出 No；否则输出 Yes，然后按顺序输出这 n-1 座桥的编号（编号从 1 开始），输出的第一座桥连接第一个区间和第二个区间，输出的第二座桥连接第二个区间和第三个区间，依此类推。

思考：如果不要求连接的两个区间相邻，你能否连通所有区间？

本题算作区间与点的最大匹配/覆盖问题
类似的还有 https://www.luogu.com.cn/problem/P2887	输入
4 4
1 4
7 8
9 10
12 14
4 5 3 8
输出
Yes
2 3 1 

输入
2 2
11 14
17 18
2 9
输出
No

输入
2 1
1 1
1000000000000000000 1000000000000000000
999999999999999999
输出
Yes
1 	2000	https://codeforces.com/problemset/submission/555/173027350

方法一：

提示 1：转换成每对相邻区间，能放下的桥的长度的范围，记到一个数组 b 中。

提示 2：从小到大排序 a 和 b，其中 b 按照左端点排序。

提示 3：遍历 a，对于 b 中范围左端点在 a[i] 左边且没有使用过的范围，从中选出右端点最小且 ≥a[i] 的范围。

提示 4：用最小堆模拟。

方法二：

b 按照右端点排序，然后遍历 b，维护 a[i]<=右端点的 a[i]，每次取 >=左端点的最小的 a[i]，这可以用平衡树实现。		
2022年9月21日	https://codeforces.com/problemset/problem/1619/E

输入 t (≤1e4) 表示 t 组数据，每组数据输入 n(≤2e5) 和一个长为 n 的数组 a (0≤a[i]≤n)。所有数据的 n 之和不超过 2e5。
每次操作，你可以把数组中的一个数加一。
定义 mex(a) 表示不在 a 中的最小非负整数。
定义 f(i) 表示使 mex(a) = i 的最小操作次数。如果无法做到，则 f(i) = -1。
输出 n+1 个数：f(0), f(1), ..., f(n)。	输入
5
3
0 1 3
7
0 1 2 3 4 3 2
4
3 0 0 0
7
4 6 2 3 5 0 5
5
4 0 1 0 4
输出
1 1 0 -1 
1 1 2 2 1 0 2 6 
3 0 1 4 3 
1 0 -1 -1 -1 -1 -1 -1 
2 1 0 2 -1 -1 	1700	https://codeforces.com/contest/1619/submission/146932917

提示 1：什么情况下会输出 -1？
当 ≤ i 的元素不足 i+1 个时。

提示 2：从小到大计算 f(i)。
因为 f(i) 可以在 f(i-1) 的基础上操作。

提示 3：在计算 f(i) 时，如果数组中没有 i-1，那么需要操作哪个数呢？
在「多余」的数中，比 i 小且最大的数。
例如 [0,1,1,2,4] 中，1 就是多余的数，这个数可以变大。

提示 4：用栈存储多余的数，栈顶就是提示 3 中需要操作的数。		
2022年9月20日	https://codeforces.com/problemset/problem/377/A

输入 n(≤500) m(≤500) k 和一个 n 行 m 列的网格图，'#' 表示墙，'.' 表示平地。
保证所有 '.' 可以互相到达（四方向连通）。保证 k 小于 '.' 的个数。
你需要把恰好 k 个 '.' 修改成 'X'，使得剩余的所有 '.' 仍然是可以互相到达的。
输出修改后的网格图。	输入
3 4 2
#..#
..#.
#...
输出
#.X#
X.#.
#...

输入
5 4 5
#...
#.#.
.#..
...#
.#.#
输出
#XXX
#X#.
X#..
...#
.#.#	1600	https://codeforces.com/contest/377/submission/172785787

考察对 DFS 的理解程度。

提示 1：从任意一个 '.' 出发，DFS 连续访问过的位置是连通的。

提示 2：设总共有 s 个 '.'，连续访问 s-k 个 '.'，剩余没有访问过的 '.' 就可以修改成 '#' 了。

注：也可以用 BFS 做。		
2022年9月19日	https://codeforces.com/problemset/problem/1395/C

输入 n(≤200) 和 m(≤200)，长为 n 的数组 a(0≤a[i]<512) 和长为 m 的数组 b(0≤b[i]<512)。
对于每个 a[i]，你可以选择任意一个 b[j]，组成 c[i]=a[i]&b[j]。
输出 c 数组的所有元素按位或的最小值。 

思考：如果值域是 1e9 要怎么做？	输入
4 2
2 6 4 0
2 4
输出 2
解释 构造 c1=a1&b2=0, c2=a2&b1=2, c3=a3&b1=0, c4=a4&b1=0，得 c1|c2|c3|c4=2。

输入
7 6
1 9 1 9 8 1 0
1 1 4 5 1 4
输出 0

输入
8 5
179 261 432 162 82 43 10 38
379 357 202 184 197
输出 147	1600	https://codeforces.com/contest/1395/submission/148506798

方法一：暴力枚举

提示 1：枚举答案 ans。

提示 2：这意味着 c[i] | ans = ans。

提示 3：对每个 a[i]，枚举看是否存在 a[j] 使得 (a[i]&b[j]) | ans = ans。

时间复杂度 O(nmU)，U=512。

方法二：从高到低逐个考虑每个比特位

如果答案的某个比特位可以是 0，那么需要更新 a[i] 可以选择的 b[j] 的集合。

时间复杂度 O(nmlogU)，U=512。

可以参考 https://www.luogu.com.cn/blog/yltx/solution-cf1395c		
2022年9月16日	https://codeforces.com/problemset/problem/827/B

输入 n 和 k (2≤k<n≤2e5)。
构造一棵有 n 个节点的树，其中度数为 1 的点恰好有 k 个，且这些点之间的最大距离最小。
输出这个最小值，和这棵树的 n-1 条边。节点编号从 1 开始。
如果有多种构造方案，输出任意一种。

注：一个点的度数等于与该点相连的边的数目。	输入
3 2
输出
2
1 2
2 3
解释 见右图

输入
5 3
输出
3
1 2
2 3
3 4
3 5
解释 见右图	1800	https://codeforces.com/problemset/submission/827/172319103

提示 1：构造一个形如章鱼🐙的结构：根 + k 条链。

提示 2：其中有 (n-1)%k 条链的长度为 (n-1)/k+1，其余为 (n-1)/k。

上面代码的做法是，根的编号为 k+1，每条链的第一个节点的编号为 1~k。		
2022年9月15日	https://codeforces.com/problemset/problem/837/D

输入 n k (1≤k≤n≤200) 和一个长为 n 的数组 a (1≤a[i]≤1e18)。
从 a 中选择一个长为 k 的子序列，设这 k 个数的乘积为 m。
输出 m 的末尾 0 的个数的最大值。

子序列不一定连续。	输入
3 2
50 4 20
输出 3
解释 选择 [50,20]，m=1000

输入
5 3
15 16 3 25 9
输出 3
解释 选择 [15,16,25]，m=6000

输入
3 3
9 77 13
输出 0
解释 选择 [9,77,13]，m=9009	2100	https://codeforces.com/contest/837/submission/172210710
循环优化 https://codeforces.com/contest/837/submission/172219030

提示 1：转换成二维费用的 01 背包。

提示 2：物品可以看成「个数=1个，体积=因子5的个数，价值=因子2的个数」。

提示 3：定义 f[i][j][p] 表示前 i 个数字，选 j 个，因子 5 的个数等于 p 时，因子 2 的个数的最大值。

根据 01 背包，有 f[i][j][p] = max(f[i-1][j][p], f[i-1][j-1][p-cnt5[i]] + cnt2[i])。其中 cnt2[i] 和 cnt5[i] 为 a[i] 的因子 2 和因子 5 的个数。
初始项 f[0][0][0] = 0，其余为 -∞。
答案为 max{min(i, f[n][k][i])}。
代码实现时，第一个维度可以优化掉。(倒序循环）

注：对于每个数，因子 5 的个数至多有 25 个。		
2022年9月14日	http://codeforces.com/problemset/problem/543/A

输入 n (1≤n≤500) m (1≤m≤500) b (0≤b≤500) mod (1≤mod≤1e9+7) 和一个长为 n 的数组 a (0≤a[i]≤500)。

你接手了一个有很多祖传代码的老项目，该项目由 n 个程序员开发，目前有 m 行代码。
已知第 i 个程序员在一行代码中会产生 a[i] 个 bug。
你尚不知道每个程序员分别写了多少行代码，于是你思考：有多少种方案，能使项目的 bug 数量不超过 b 个？由于答案很大，你需要输出答案模 mod 的结果。

注意：两种方案不同，当且仅当某个程序员编写的行数不同。
可能有程序员一行代码都不写。	输入
3 3 3 100
1 1 1
输出 10

输入
3 6 5 1000000007
1 2 3
输出 0

输入
3 5 6 11
1 2 1
输出 0	1800	https://codeforces.com/contest/543/submission/172106263

转换成二维费用的完全背包：
f[i][j][k] 表示前 i 个程序员写 j 行代码产生 k 个 bug 的方案数。
用背包来理解，每个物品为 (1 行代码，a[i] 个 bug)
按照完全背包转移：f[i][j][k] = f[i-1][j][k] + f[i][j-1][k-a[i]]。
初始项：f[0][0][0] = 1。
答案：sum(f[n][m])。
代码实现时，第一个维度可以优化掉。		
2022年9月13日	https://codeforces.com/problemset/problem/1494/C

输入 t (≤1000) 表示 t 组数据，每组数据输入 n (≤2e5) m (≤2e5)，长为 n 的严格递增数组 a (-1e9≤a[i]≤1e9) 和长为 m 的严格递增数组 b (-1e9≤b[i]≤1e9)。a 和 b 中均不包含 0。所有数据的 n 之和、m 之和均不超过 2e5。

你在玩一个一维推箱子的游戏，你的初始位置为 0，箱子的位置由数组 a 表示，特殊位置由数组 b 表示。
你可以同时推动多个相邻的箱子。
你不能穿过箱子。
你不能拉箱子。
对于每组数据，输出最多可以让多少个箱子在特殊位置上。
注意可能有的箱子一开始就在特殊位置上。

你能做到线性时间复杂度，且除去输入的空间为常数吗？	输入
5
5 6
-1 1 5 11 15
-4 -3 -2 6 7 15
2 2
-1 1
-1000000000 1000000000
2 2
-1000000000 1000000000
-1 1
3 5
-1 1 2
-2 -1 1 2 5
2 1
1 2
10
输出
4
2
0
3
1	1900	三指针做法：https://codeforces.com/contest/1494/submission/171998732
二分做法：https://codeforces.com/contest/1494/submission/109374034

提示 1：正负分开考虑。

提示 2：以正数为例，枚举每个特殊位置，把连续箱子中最右的那个箱子推到这个位置上，能有多少个箱子在特殊位置上？		
2022年9月12日	https://codeforces.com/problemset/problem/1197/D

输入 n (1≤n≤3e5) m (1≤m≤10) k (1≤k≤1e9) 和一个长为 n 的数组 a (-1e9≤a[i]≤1e9)。
定义数组 b 的价值为 sum(b) - k * ceil(len(b) / m)。
空数组的价值为 0。
输出 a 的所有子数组的最大价值。	输入
7 3 10
2 -4 15 -3 4 8 3
输出 7

输入
5 2 1000
-13 -4 -9 -20 -11
输出 0	1900	https://codeforces.com/contest/1197/submission/126967539

提示 1-1：m=1 要怎么做？
式子变形。

提示 1-2：当 m=1 时，记 a'[i]=a[i]-k，则原问题可转换成最大子段和问题。

提示 2-1：用前缀和，枚举数组右端点。

提示 2-2：需要知道左侧前缀和的最小值。

提示 3-1：把式子乘上 m，最后算出的答案再除以 m。
思考 m=2 要怎么做。

提示 3-2：当 m=2 时，设区间为 [l,r)，如果 r-l 是偶数，那么 ceil 无影响，像提示 2 那样式子变形一下。
如果 r-l 是奇数，在 ceil 的影响下，r-l 等价于 r-l+1，由于 ceil 前面是减号，相当于需要额外减去 k。

提示 4：推广，把前缀和按照 下标%m 分组。

提示 5：记录每个组的最小值。

注意用 64 位整型。		
2022年9月9日	https://codeforces.com/problemset/problem/1400/D

输入 t (≤100) 表示 t 组数据，每组数据输入 n (4≤n≤3000) 和一个长为 n 的数组 a (1≤a[i]≤n)，下标从 1 开始。所有数据的 n 之和 ≤3000。
对每组数据，输出满足 1≤i<j<k<l≤n 且 a[i]=a[k] 且 a[j]=a[l] 的四元组 (i,j,k,l) 的数量。

相似题目 https://codeforces.com/contest/1677/problem/A	输入
2
5
2 2 2 2 2
6
1 3 3 1 2 3
输出
5
2
解释
第一组数据，任意一个四元组都是符合要求的。
第二组数据，(1,2,4,6) 和 (1,3,4,6) 是符合要求的。	1900	https://codeforces.com/contest/1400/submission/171470018

提示 1：枚举 j 和 l。

提示 2：枚举 j 的同时，统计下标小于 j 的每个元素的出现次数 cnt[x]。

提示 3：遍历 l，累加 j 和 l 之间的 cnt[x]，记作 c，当 a[j] = a[l] 时，累加 c 到答案上。

注意用 64 位整数。		
2022年9月8日	https://codeforces.com/problemset/problem/896/A

用编程语言声明字符串序列 f（\" 表示字符串中的引号）：
f[0] = "What are you doing at the end of the world? Are you busy? Will you save us?"
f[i] = "What are you doing while sending \"" + f[i-1] + "\"? Are you busy? Will you send \"" + f[i-1] + "\"?"

输入 t (≤10) 表示 t 组数据，每组数据输入 n (0≤n≤1e5) 和 k (1≤k≤1e18)。
对每组数据，输出 f[n][k-1]，如果 f[n] 的长度不足 k，则输出一个英文句点 '.'。

题目背景：《末日三问》	输入
3
1 1
1 2
1 111111111111
输出 Wh.

输入
5
0 69
1 194
1 139
0 47
1 66
输出 abdef

输入
10
4 1825
3 75
3 530
4 1829
4 1651
3 187
4 584
4 255
4 774
2 474
输出 Areyoubusy	1700	https://codeforces.com/contest/896/submission/171298801

提示 1：写一个递归 or 迭代。  F(n,k)

提示 2：预处理 f[i] 的长度。
不需要太多（指 1e18）。

我用的迭代写法，递归写法见右 @L.K		
2022年9月7日	https://codeforces.com/problemset/problem/371/D

输入 n (≤2e5) 和一个长为 n 的数组 a (1≤a[i]≤1e9)，表示有 n 个盛水的容器，从上到下串起来（如下图），从上到下第 i 个容器的容量为 a[i]。初始时，所有容器都是空的。

然后输入 m (≤2e5) 个询问，每个询问的格式如下（i 从 1 开始）：
1 i x，表示往第 i 个容器倒 x (≤1e9) 单位的水。溢出的水会流到下一个容器，下一个容器溢出的水会流到下下一个容器，……，最后一个容器溢出的水会流到地板上。
2 i，输出第 i 个容器有多少单位的水。













	输入
2
5 10
6
1 1 4
2 1
1 2 5
1 1 4
2 1
2 2
输出
4
5
8

输入
3
5 10 8
6
1 1 12
2 2
1 1 6
1 3 2
2 2
2 3
输出
7
10
5	1800	https://codeforces.com/contest/371/submission/125191890

提示 1：并查集

提示 2：并查集应当实现：每个容器指向当前或下一个没有装满的容器		
2022年9月6日	https://codeforces.com/contest/729/problem/D

输入 n (≤2e5) a b (1≤a,b≤n) k (0≤k≤n-1) 和一个长为 n 的字符串 s，只包含 0 和 1，且恰好有 k 个 1。

有 n 个格子排成一行，里面有 a 艘船，每艘船占据连续 b 个格子。两艘船不会占据同一个格子。
现在已经为你揭露了 k 个没有船的格子，用字符串 s 中的 1 表示（0 表示尚未揭露的格子）。
你可以发射炮弹，一次可以揭露一个格子。
输出保证射中一艘船，至少需要发射的次数和具体射击的格子编号（从 1 开始）。如果发射方案有多种，输出任意一种。
保证答案存在。	输入
5 1 2 1
00100
输出
2
4 2

输入
13 3 2 3
1000000010001
输出
2
7 11	1700	https://codeforces.com/contest/729/submission/171022830

提示 1：【跳跃性思维】射中所有船，需要发射多少次？

提示 2：对于一串连续的 0，我们可以从第 b 个格子开始，每 b 个格子发射一次。

提示 3：由于只需要射中一艘船，可以少发射 a-1 次。		
2022年9月5日	https://codeforces.com/problemset/problem/484/A

输入 t (t≤1e4) 表示 t 组数据，每组数据输入两个数 L 和 R (0≤L≤R≤1e18)。

对每组数据，输出在区间 [L,R] 内的二进制中的 1 的个数最多的那个数字，如果有多个这样的数字，输出最小的。

思考：如果让你找的是 0 的个数最多的那个数字呢？（前导零不计）	输入
3
1 2
2 4
1 10
输出
1
3
7	1700	https://codeforces.com/problemset/submission/484/170918872

提示 1：由于要 ≥L，可以尝试从 L 出发，把 L 的二进制中的 0 改成 1，使得修改之后 L≤R。

提示 2：贪心：从最低位的 0 开始修改，这样才能修改尽可能多的 0 为 1。

相比枚举 0 的位置，有一种更巧妙的位运算技巧，见代码。


思考题解答：方法类似，从 R 出发把 1 改成 0。		
2022年9月2日	https://codeforces.com/problemset/problem/1168/A

输入 n (1≤n≤3e5)、m (1≤m≤3e5) 和一个长为 n 的数组 a，元素值在 [0,m-1] 内。

每次操作，你可以选择 a 中的某些数，把每个数 x 改成 (x+1)%m。

输出使 a 变成单调非降的最少操作次数。

反向思考：给定 n 和 m，如何构造出一个让最少操作次数最大的数组 a？	输入
5 3
0 0 0 1 2
输出 0
解释 a 已经是单调非降的。

输入
5 7
0 6 1 3 2
输出 1
解释 选择 6 和 2，操作后 a=[0,0,1,3,3]	1700	https://codeforces.com/problemset/submission/1168/170572944

提示 1：至多需要操作多少次？

m 次。所有数可以变成 0。

提示 2：二分答案。

提示 3：遍历 a，设 pre 为 a[i-1] 修改后的值（初始 pre=0），如果 a[i] 可以修改成 pre，那这样是最优的；如果 a[i] 无法修改成 pre，且 a[i] < pre，则无法满足单调非降，二分判定 false；否则保持 a[i] 不变是最优的。若中途没有 false 则二分判定 true。
具体实现和注释见代码。

思考：
你能找到一个比 m 更小的二分上界吗？
二分下界可以根据输入来优化吗？		
2022年9月1日	https://codeforces.com/problemset/problem/1207/D

输入 n (≤3e5) 和一个 pair 数组 p，即 p1=(a1,b1), p2=(a2,b2), ..., pn=(an,bn)，其中 ai 和 bi 均在 [1,n] 内。

定义一个 1~n 的下标排列是好的，当且仅当 p 按照该下标排列重排后，{ai} 序列和 {bi} 序列均不是单调非降的。

输出好的下标排列的个数。	输入
3
1 1
2 2
3 1
输出 3
解释
下标排列 [2,1,3] 是好的，按照 [2,1,3] 的顺序重排 p 得到 [(2,2),(1,1),(3,1)]，{ai}=[2,1,3] 和 {bi}=[2,1,1] 都不是单调非降的。
下标排列 [1,2,3] 是不好的，此时没有重排，那么按照输入的顺序，{ai}=[1,2,3] 是单调非降的，不符合定义。
另两个好的下标排列是 [2,3,1] 和 [3,2,1]。

输入
4
2 3
2 2
2 1
2 4
输出 0
解释 无论怎么重排，{ai} 序列都是单调非降的。

输入
3
1 1
1 1
2 3
输出 4	1800	https://codeforces.com/problemset/submission/1207/170446877

提示 1：正难则反。

提示 2：容斥原理。

提示 3：设：
sa 等于让 {ai} 为单调非降序列的下标排列个数，
sb 等于让 {bi} 为单调非降序列的下标排列个数，
sp 等于让 {ai} 和 {bi} 均为单调非降序列的下标排列个数，
根据容斥原理，答案为 n! - sa - sb + sp。

提示 4：如何计算呢？如果有相同元素，那么把它们交换位置就生成了另一种下标排列。由于不同元素值之间是独立的，根据乘法原理，将每个元素出现次数的阶乘乘起来就好了。
如果按照 (ai,bi) 排序后，{bi} 不是单调非降的，则 sp 为 0。


注意：由于有取模，作减法可能会产生负数。		
2022年8月31日	https://codeforces.com/problemset/problem/933/A

输入 n (≤2000) 和一个长为 n 的数组 a，元素值只有 1 和 2。
你可以翻转 a 的一个区间（该操作执行至多一次）。
输出你能得到的最长非降子序列的长度。
子序列不要求连续。

进阶：你能做到 O(n) 吗？
扩展：元素范围在 [0,9] 的情况 http://acm.hdu.edu.cn/showproblem.php?pid=6357	输入
4
1 2 1 2
输出 4
解释 翻转 [2,1]，得到 [1,1,2,2]。

输入
10
1 1 2 2 2 1 1 2 2 1
输出 9
解释 翻转 [2,2,2,1,1]，得到 [1,1,1,1,2,2,2,2,2,1]。	1800	https://codeforces.com/contest/933/submission/117023821

题目本质是将数组划分成 4 部分：11...22...11...22...，那么定义 dp[i][j] 表示前 i 个元素组成前 j 个部分的最长子序列的长度。
遍历一遍即可求出 dp[n][4]（递推式见代码），复杂度为 O(n)。
代码实现时可以用滚动数组优化。		
2022年8月30日	https://codeforces.com/problemset/problem/1537/E1
https://codeforces.com/problemset/problem/1537/E2

本题分为简单版本和困难版本，在困难版本中，n 和 k 不超过 5e5。

输入 n (≤5000) 和 k (≤5000)，以及一个长为 n 的字符串 s，由小写字母组成。

有如下两种操作，每种操作你都可以执行任意多次：
1. 删除 s 的最后一个字符；
2. 将 s 复制一份拼在后面，即 s = s + s。

输出你能得到的所有长为 k 的字符串中，字典序最小的字符串。	输入
8 16
dbcadabc
输出
dbcadabcdbcadabc
解释 复制一次

输入
4 5
abcd
输出
aaaaa	1600（简单版本）

2200（困难版本）	https://codeforces.com/problemset/submission/1537/170118286

提示 1：操作的本质是，答案一定由 s 的某些前缀组成。

提示 2：进一步地，应当选择（在重复自身后）字典序最小的前缀，在此基础上组成答案。
例如 "dbca" > "dbcada"，因为重复后 "dbcadb..." > "dbcada..."
暴力比较所有前缀，可以解决简单版本。

困难版本见群友@meyi 的题解，非常标准的证明：
https://www.luogu.com.cn/blog/zankizero/ti-xie-cf1537e2-erase-and-extend-hard-version		
2022年8月29日	https://codeforces.com/problemset/problem/1551/D1
https://codeforces.com/problemset/problem/1551/D2

本题分为简单版本和困难版本，在困难版本中，你需要额外输出具体的方案。

输入 t (≤10) 表示有 t 组数据。
每组数据输入 n (≤100)、m (m≤100) 和 k (0≤k≤n*m/2)，保证 n*m 是偶数。

请你在一个 n 行 m 列的网格中，放置 n*m/2 个 1*2 大小的骨牌，要求恰好有 k 个是横着放的，其余是竖着放的，且恰好铺满这一 n*m 的网格。

如果存在满足要求的铺设方案，输出 YES，否则输出 NO。
对于困难版本，如果答案存在，你需要额外输出 n 个长为 m 的由小写字母组成的字符串，表示你铺设的骨牌（多种方案输出任意一种）。要求：两个相邻的单元格拥有相同的字母，表明这两个单元格由同一个骨牌覆盖。具体输出样例见困难版本题目。	输入
8
4 4 2
2 3 0
3 2 3
1 2 0
2 4 2
5 2 2
2 17 16
2 1 1
输出
YES
YES
YES
NO
YES
NO
YES
NO	1700（简单版本）

2100（困难版本）	https://codeforces.com/problemset/submission/1551/170038881

提示 1：讨论 n 或 m 的奇偶性。什么情况下输出 NO？

提示 2：标准化，如果 n 和 m 都是偶数，构造起来就会方便不少。

如果 n 是奇数，我们可以先横着摆满最后一排（用字母 fg 交错），如果 k 不足 m/2 输出 NO，否则可以先 k-=m/2；
如果 m 是奇数，我们可以先竖着摆满最后一列（用字母 fg 交错），如果 k 超过 m/2*n 输出 NO。
这样剩余行列数均为偶数，如果 k 是奇数则输出 NO。

然后就可以愉快地构造了。用字母 bc 交错表示横着的，用字母 de 交错表示竖着的。
具体实现技巧见代码。		
2022年8月26日	https://codeforces.com/problemset/problem/1611/F

输入 t (≤1e4) 表示有 t 组数据。
每组数据输入 n (≤2e5)、s (0≤s≤1e9) 和一个长为 n 的数组 a (-1e9≤a[i]≤1e9)。
所有数据的 n 之和不超过 2e5。

请你在 a 中找到一个最长的连续子数组 b，满足 b 的每个前缀和都 ≥ -s（注意是 -s）。
如果存在这样的 b，输出 b 的左右边界在 a 中的下标 l 和 r（下标从 1 开始，如果有多个答案，输出任意一种）。
如果不存在这样的 b，输出 -1。

思考：如果 s<0 要怎么做？@Zakl	输入
3
4 10
-16 2 -6 8
3 1000
-100000 -100000 -100000
6 0
2 6 -164 1 -1 -6543
输出
2 4
-1
1 2
解释
第一组数据，子数组 [2,-6,8] 的前缀和为 2 -4 4，均 ≥ -10。	1800	https://codeforces.com/contest/1611/submission/169674825

O(n) 做法：前缀和 + 双指针。

固定左指针 l，去看右指针 r 最远能到哪。
当左指针右移时，如果右指针不能移动甚至要往左移，那就无法得到更优解，不用管它，右指针不移动；
否则右指针右移，移动到 r+1 无法满足要求时停止。
答案为移动过程中的最大的 r-l。

思考：为什么这样做是正确的？在可以移动右指针时，为什么不会出现中间某个前缀和 < -s 的情况？	对于这题，我的做法是固定左指针，去看右指针 r 能在哪些范围，或者说 r 最远能到哪。
要做到比 O(n^2) 的暴力低，关键在于 r 是不会往左移动的，因为你只会得到更短的答案。

另外，中间的前缀和是不会比 -s 还要小的。反证：如果出现这种情况，那么根据我们的算法，r 是不会跳到更后面的位置的。

画一个前缀和的折线图就明白了。	评注：这题加深了我对双指针的理解。
2022年8月25日	https://codeforces.com/problemset/problem/691/C

上场周赛出了一道【易错题】（周赛第二题），所以今天我也找了一道【易错题】，带大家针对训练一下。

输入一个长度不超过 1e6 的字符串 x，表示一个大于 0 的小数（可能有前导零）。
输出 x 的科学计数法表示（格式为 aEb），要求：
① 1≤a<10，如果 a 是整数，不要输出小数点。
② b 必须是整数，如果 b=0，那么你只需要输出 a。	输入 16
输出 1.6E1

输入 01.23400
输出 1.234

输入 .100
输出 1E-1

输入 100.
输出 1E2	1800	https://codeforces.com/contest/691/submission/169524952

实现技巧：标准化，去掉前缀和后缀的 0，如果没有小数点在末尾加上小数点。

见代码注释。没有感情，全是技巧。		
2022年8月24日	https://codeforces.com/problemset/problem/482/B

输入 n (n≤1e5) 和 m (m≤1e5)，以及 m 个约束，每个约束包含三个数 l r q (1≤l≤r≤n, 0≤q<2^30)。

请你构造一个长为 n 的数组 a，对于每个约束，都满足 a[l] AND a[l+1] AND ... AND a[r] = q。
这里 AND 表示按位与，数组的下标从 1 开始。
如果无法构造，输出 NO；否则输出 YES 和任意一个符合要求的数组 a。
	输入
3 1
1 3 3
输出
YES
3 3 3

输入
3 2
1 3 3
1 3 2
输出
NO	1800	提示 1：分别考虑每个比特位。

提示 2：区间 AND = 1 表示这个区间的比特全是 1；区间 AND = 0 表示这个区间的比特存在 0。

提示 3：用差分数组来记录区间 AND = 1 的情况（可以简单地把区间元素都加上 1）。怎么快速判断区间存在 0 呢？

回答提示 3 的问题。
方法一：求差分数组的前缀和，把所有等于 0 的值视作 1，大于 0 的值视作 0，然后再求前缀和，这样区间内存在 0 就等价于两个前缀和的差大于 0。
https://codeforces.com/problemset/submission/482/169488471

方法二：求差分数组的前缀和，对每个位置，记录左侧最近的 0 的位置。这样对每个区间 [l,r]，判断 r 左侧最近 0 的位置是否不小于 l 即可。
https://codeforces.com/problemset/submission/482/169490547

复杂度都是 O(30(n+m))。

线段树的做法见 https://wangguankan.blog.luogu.org/solution-cf482b		
2022年8月23日	https://codeforces.com/problemset/problem/1108/E1
https://codeforces.com/problemset/problem/1108/E2

本题分为简单版本和困难版本，唯一的区别是，在困难版本中 n≤1e5。

输入 n (n≤300) 和 m (m≤300)，以及长度为 n 的数组 a，元素值范围在 [-1e6,1e6]，数组的下标从 1 开始。
然后输入 m 个闭区间 [l[i],r[i]]。

你可以选择若干个区间（可以一个都不选），对每个区间，将区间内的数字减一（如果一个数字被 k 个区间覆盖，则需要减少 k）。
最大化 max(a) - min(a)。

第一行，输出这个最大值。
第二行，输出你选择了多少个区间。
第三行，按任意顺序输出你选择的区间的编号（从 1 到 m）。
输出任意一种满足要求的方案。

思考：如果 n 和 m 均为 1e5 呢？	输入
5 4
2 -2 3 1 2
1 3
4 5
2 5
1 3
输出
6
2
1 4 

输入
5 4
2 -2 3 1 4
3 5
3 4
2 4
2 5
输出
7
2
3 2 

输入
1 0
1000000
输出
0
0	1800（简单版本）

2100（困难版本）	https://codeforces.com/problemset/submission/1108/169394119

提示 1：枚举 a[i] 作为最大值，它需要减小吗？

提示 2：凡是不包含 i 的区间都可以选。

提示 3：到这一步，就可以用暴力枚举解决简单版本了。

对于 n,m 都等于 1e5 的情况呢？

形象地理解下面的内容：把枚举中的 i 当成一个在区间流中前进的人。

用线段树维护全局最小值。一开始把所有区间都减掉（选择），更新线段树，同时加到一个二维数组 ls 中，ls[i] 表示左端点为 i 的右端点列表。遍历 i，把 ls[i] 对应的区间加回去（不选择），然后放到一个二维数组 rs 中，rs[i] 表示右端点为 i 的左端点列表；同时，把 rs[i-1] 对应的区间再减掉（选择）。

在这个过程中记录 a[i]-min 的最大值，以及对应的 a[i] 的下标 i，最后选择所有不包含 i 的区间。		
2022年8月22日	https://codeforces.com/problemset/problem/1016/D

输入 n (2≤n≤100) 和 m (2≤m≤100)，以及两个长度分别为 n 和 m 的数组 a 和 b，元素范围均在 [0,1e9]。

请你构造一个 n 行 m 列的矩阵，使得矩阵第 i 行所有数的异或和等于 a[i]，第 j 列所有数的异或和等于 b[j]。
如果不存在这样的矩阵，输出 NO；否则输出 YES 和这个矩阵。

思考：把 XOR 换成 AND / OR 呢？
思考：如果既有 AND 又有 OR 呢？https://atcoder.jp/contests/abc164/tasks/abc164_f	输入
2 3
2 9
5 3 13
输出
YES
3 4 5
6 7 8

输入
3 3
1 7 6
2 15 12
输出
NO	1800	https://codeforces.com/problemset/submission/1016/169303183

思考方向：尝试一下 n=m=2 的情况。

提示 1：什么时候一定输出 NO？

提示 2：试一试，能否把关键信息只填到第一行和第一列，其余位置均填 0 呢？

提示 3：直截了当的做法是，除了左上角，第一行填 b[j]，第一列填 a[i]。左上角应该填什么数？		
2022年8月19日	https://codeforces.com/problemset/problem/1066/E

输入 n (≤2e5) 和 m (≤2e5)，以及两个长度分别为 n 和 m 的二进制数 a 和 b。

然后执行如下计算：
ans = 0
while b > 0:
    ans += a & b
    b >>= 1

输出 ans % 998244353 的结果。	输入
4 4
1010
1101
输出 12

输入
4 5
1001
10101
输出 11	1700	https://codeforces.com/contest/1066/submission/168906109

考虑 a 的每个 1，对答案的贡献是多少？		
2022年8月18日	https://codeforces.com/problemset/problem/1032/C

输入 n (≤1e5) 和一个长为 n 的数组 a (1≤a[i]≤2e5)。

构造一个长为 n 的数组 b，满足：
1. 1≤b[i]≤5；
2. 如果 a[i]<a[i+1]，则 b[i]<b[i+1]；
3. 如果 a[i]>a[i+1]，则 b[i]>b[i+1]；
4. 如果 a[i]=a[i+1]，则 b[i]≠b[i+1]；
如果不存在这样的 b 则输出 -1，否则输出任意一个满足要求的 b。	输入
5
1 1 4 2 2
输出
1 4 5 4 5 

输入
7
1 5 7 8 10 3 1
输出
1 2 3 4 5 4 3 

输入
19
3 3 7 9 8 8 8 8 7 7 7 7 5 3 3 3 3 8 8
输出
1 3 4 5 4 5 4 5 4 5 4 5 4 3 5 4 3 5 4 	1700	纯构造做法
https://www.luogu.com.cn/blog/endlesscheng/solution-cf1032c

每一个上升段和下降段都可以一段段地处理。
对于上升段，让起始值尽量小，每次增长 1。
对于下降段，让起始值尽量大，每次减少 1。
相等的段，元素可以取 2 或 3，这样不会妨碍上升段和下降段的起始值。

具体实现技巧见代码。	https://codeforces.com/problemset/submission/1032/168783486	
2022年8月17日	https://codeforces.com/problemset/problem/652/C

输入 n 和 m (≤3e5)，一个 1~n 的全排列 p，以及 m 个 pair，元素值均在 [1,n] 中。
称 p 的子数组 b 是合法的，当且仅当对于所有 pair (x,y)，x 和 y 至多有一个在 b 中。
输出有多少个 p 的合法子数组。

进阶：如果 p 有重复元素要怎么做？	输入
4 2
1 3 2 4
3 2
2 4
输出 5
解释 子数组 [1] [1,3] [3] [2] [4] 是合法的。

输入
9 5
9 7 2 3 1 4 6 5 8
1 6
4 5
2 7
7 2
2 7
输出 20	1800	https://codeforces.com/contest/652/submission/168633147
62ms 快读 https://codeforces.com/problemset/submission/652/168657078

提示 1：对 p 的每个位置 i，假设它是子数组的右端点，我们需要知道有多少个合法的左端点。

提示 2：为了做到这一点，我们需要知道 i 左侧最近的元素对的位置，怎么定义最近呢？
具体来说，设元素对为 (x,y)，其在 p 上的下标分别为 pos[x] 和 pos[y]，假设 pos[x]<pos[y]<=i，我们需要知道 pos[x] 的最大值 maxL，这样位置 i 对答案的贡献就是 i-maxL。

提示 3：如何求 maxL？
遍历 p 可以得到 pos 数组，遍历所有元素对，可以得到每个 pos[y] 位置上所对应的 pos[x] 的最大值，记作 l 数组。
从小到大遍历 l，维护 l 前缀的最大值，即为 maxL。

具体实现逻辑见代码。

由于输入量巨大，代码的耗时主要在读入上。		
2022年8月16日	https://codeforces.com/problemset/problem/1249/E

输入正整数 n(2≤n≤2e5) 和 c(≤1000)，以及长度均为 n-1 的整数数组 a 和 b，数组元素范围均为 [1,1000]。

走楼梯从 i 层到 i+1 层需要 a[i] 秒。
坐电梯从 i 层到 i+1 层需要 b[i] 秒。
如果你要从某一层开始坐电梯，你需要额外等待 c 秒。

输出从第 1 层走楼梯或者坐电梯到每一层，分别最少需要多少秒。

进阶：做到 O(1) 空间复杂度（不计输入输出）。	输入
10 2
7 6 18 6 16 18 1 17 17
6 9 3 10 9 1 10 1 5
输出
0 7 13 18 24 35 36 37 40 45 

输入
10 1
3 2 3 1 3 3 1 4 1
1 2 3 4 4 1 2 1 3
输出
0 2 4 7 8 11 13 14 16 17 	1700	https://codeforces.com/contest/1249/submission/164834657

定义 f[i][0/1] 表示到达第 i 层，且是用楼梯/电梯到达时的最短时间。
枚举上一层和当前层走楼梯还是坐电梯，转移到对应的状态上。
具体转移方程见代码。
答案就是每一层的 min(f[i][0], f[i][1])。

利用滚动数组可以做到 O(1) 空间复杂度。		
2022年8月15日	https://codeforces.com/problemset/problem/954/C

有一个 x 行 y 列的矩阵，你不知道 x 和 y 的大小，你只知道矩阵中的数字是从 1 开始连续递增的，即：
第一行是 1,2,3,...,y
第二行是 y+1,y+2,y+3,...,2y
……

定义矩阵上的一条路径为：从某一点出发，每一步往四个相邻格子走（不能出界），所走过的数字组成的序列。注意不能停在原地。

现在输入 n(≤2e5) 和一个长为 n 的路径 a (1≤a[i]≤1e9)。
如果存在某个矩阵能走出路径 a，且 x 和 y 均不超过 1e9，则输出 YES 和 x y，否则输出 NO。
如果有多个答案，输出任意一种。

进阶：如果 a[i] ≤ 1e18，其它约束不变，要怎么做？ @七水	输入
8
1 2 3 6 9 8 5 2
输出
YES
3 3
解释 见图

输入
6
1 2 1 2 5 3
输出 NO

输入
2
1 10
输出
YES
4 9	1700	https://codeforces.com/contest/954/submission/143601524

提示 1：在知道 y 的前提下，a[i]-a[i+1] 只能是哪些值？（代码的第一个 for，变量名用的 m 表示 y）

提示 2：在 y>1 的情况下，你不能从数字 y 一步走到数字 y+1。（代码的第二个 for）

具体实现逻辑见代码。		
2022年8月12日	http://codeforces.com/problemset/problem/1368/D

输入 n(≤2e5) 和一个长为 n 的整数数组 a (0≤a[i]<2^20)。

每次操作，你可以选择两个数 a[i] 和 a[j]，分别记作 x 和 y，然后更新 a[i] = x AND y, a[j] = x OR y。AND 表示按位与，OR 表示按位或。
你可以执行该操作任意次。
输出 sum(a[i]*a[i]) 的最大值，即 a[0]*a[0] + a[1]*a[1] + ... + a[n-1]*a[n-1] 的最大值。

2023.10.8 押题成功！https://leetcode.cn/contest/weekly-contest-366/problems/apply-operations-on-array-to-maximize-sum-of-squares/	输入
1
123
输出 15129
解释 123*123=15129。

输入
3
1 3 5
输出 51
解释 把 3 和 5 修改成 1 和 7，得到 [1,1,7]，答案为 1*1+1*1+7*7 = 51。

输入
2
349525 699050
输出 1099509530625	1700	https://codeforces.com/contest/1368/submission/167929428

提示 1：操作不会改变 a[i]+a[j] 的值。

提示 2：思考一下题目的样例二，是操作前答案大，还是操作后答案大？你能提出一个更一般的猜想并证明吗？

提示 3：我们应该执行尽量多的操作，把 bit 1 都合并到一起。

具体实现逻辑见代码。	@hqzture 说可以 O(n)，原理见 
https://leetcode.cn/problems/total-hamming-distance/solution/onwei-yun-suan-by-hqztrue-z5oo/
https://zhuanlan.zhihu.com/p/72730434	
2022年8月11日	https://codeforces.com/contest/1217/problem/C

输入 t(t≤1000) 表示 t 组数据。
每组数据输入一个 01 串 s，长度不超过 2e5。所有数据的字符串长度和不超过 2e5。

定义 f(t) 表示子串 t 转换成十进制的值，如 f("011")=3。
求 s 的所有满足 f(t)=len(t) 的非空子串 t 的个数。

注：子串是连续的。

进阶：你能做到 O(1) 额外空间吗？（不含输入）	输入
4
0110
0101
00001000
0001000
输出
4
3
4
3
解释 第一个数据有 "1" "1" "10" "011" 这 4 个。	1700	https://codeforces.com/contest/1217/submission/167830191

做法不止一种，这里说一个效率更好的解法。

提示 1：枚举所有 '1' 开头的子串，即从 s[i]='1' 的位置开始向右扩展子串。

提示 2：向右扩展时，二进制的值是指数增长的，因此至多向右扩展 O(log n) 次。

提示 3：如何考虑前导零？

具体实现逻辑见代码（含注释）。

这个代码的时间复杂度是 O(n) 的，因为每个 0 算一次，在扩展 1 的时候至多算一次（把 log x 放缩到 x），所以所有扩展次数的和是 O(n) 的。

更紧的界：https://www.yuque.com/docs/share/9a07a90f-c56d-410b-97e8-b68bb97f7638  @啇水苍秀		
2022年8月10日	http://codeforces.com/problemset/problem/1582/E

如果你没有做昨天的题，推荐先做昨天的，再做这道，会简单一些。

输入 t(t≤100) 表示 t 组数据。
每组数据输入 n(1≤n≤1e5) 和长为 n 的整数数组 a (1≤a[i]≤1e9)，所有数据的 n 之和不超过 1e5。

从 a 中选尽可能多的互不相交的子数组，设有 k 个子数组，需满足：
1. 从左到右第一个子数组的长度恰好是 k，第二个的长度恰好是 k-1，……，最后一个的长度恰好是 1；
2. 从左到右第 i 个子数组的元素和严格小于第 i+1 个子数组的元素和。
输出 k 的最大值。

注：子数组是连续的。	输入
5
1
1
3
1 2 3
5
1 1 2 2 3
7
1 2 1 1 3 2 6
5
9 6 7 9 7
输出
1
1
2
3
1	2000	https://codeforces.com/contest/1582/submission/165737186

提示 1：k 至多是多少？

提示 2：从右往左思考。

提示 3-1：思考如何从 k-1 递推到 k，我们需要计算什么？

提示 3-2：贪心地想，后面的子数组的元素和越大，我们越能在剩余数字中选出更多的子数组。因此我们需要计算最左边的子数组的最大值。
具体来说，定义 suf[k][i] 表示从 a[i:] 中选择 k 个子数组，其中最左边的子数组的元素和的最大值（不存在时 suf[k][i] = 0）。
考虑 a[i] 选 or 不选，取 max：
不选就是 suf[k][i] = suf[k][i+1]。
选就要满足题目的约束，即 suf[k][i] = a[i]+...+a[i+k-1] (用后缀和优化，记作 s)，需满足 s < suf[k-1][i+k]。
不断增大 k，当剩余长度不足 k 或者 suf[k][0] = 0 时退出循环。

代码实现中可以用两个数组滚动优化掉第一个维度。		
2022年8月9日	https://codeforces.com/problemset/problem/467/C

输入三个正整数 n m k (1≤m*k≤n≤5000)，和一个长为 n 的整数数组 a(0≤a[i]≤1e9)。
从 a 中选择 k 个长度均为 m 且互不相交的子数组，使得这些子数组的元素之和最大，输出这个最大值。
注：子数组是连续的。

进阶：如果 a 是环形数组要怎么做？	输入
5 2 1
1 2 3 4 5
输出 9

输入
7 1 3
2 10 7 18 5 33 0
输出 61	1700	https://codeforces.com/contest/467/submission/167580710

定义 f[i][j] 表示前 j 个元素选 i 个子数组，能得到的最大的元素和。

计算 f[i][j]，讨论 a[j] 选 or 不选，不选就是 f[i][j-1]，选就意味着把 a[j] 当作第 i 个子数组的最后一个元素（因为我们只考虑前 j 个元素），因此为 f[i-1][j-m] + a[j-m+1]+...+a[j]，这可以用前缀和优化。

因此 f[i][j] = max(f[i][j-1], f[i-1][j-m]+s[j]-s[j-m])。

答案为 f[k][n]。
时间复杂度 O(nk)。

代码实现中可以用滚动数组优化掉第一个维度。

环形的话，枚举前 m 个位置当作数组的起点，O(nmk) 可以通过。	“最后一个元素” 让我想到了 2209. 用地毯覆盖后的最少白色砖块 https://leetcode.cn/problems/minimum-white-tiles-after-covering-with-carpets/
这两题还是挺像的。	
2022年8月8日	https://codeforces.com/problemset/problem/1469/C

输入 t(≤1e4) 表示 t 组数据。
每组数据输入 n(2≤n≤2e5) 和 k(2≤k≤1e8) 和长为 n 的数组 h(0≤h[i]≤1e8)。
所有数据的 n 之和不超过 2e5。

你需要在地面上修一个长为 n 的栅栏，地面的海拔高度用 h 数组表示。
你有 n 块高度均为 k 的木板，你需要用这些木板组成栅栏，要求如下：
1. 相邻两块木板的接触长度至少为 1；
2. 第一块和最后一块木板必须正好与地面接触；
3. 其余木板可以与地面接触，或者位于地面之上，每块木板与地面的距离不能超过 k-1。

如果可以修栅栏，输出 YES，否则输出 NO。	输入
3
6 3
0 0 2 5 1 1
2 3
0 2
3 2
3 0 2
输出
YES
YES
NO
解释 第一组数据见右图	1600	https://codeforces.com/contest/1469/submission/167464872

上下界分析。

维护 l 表示当前木板下边缘的最小海拔，r 表示当前木板下边缘的最大海拔。
对于每个 h[i] 去更新 l 最小能是多少（不能低于 h[i]），更新 r 最大能是多少（不能高于 h[i]+k-1）。
如果更新过程中 l > r 则输出 NO。
如果最后一块木板无法放在地上则输出 NO。
具体实现见代码。		
2022年8月5日	https://codeforces.com/problemset/problem/280/B

输入 n(2≤n≤1e5) 和长为 n 的数组 a(1≤a[i]≤1e9)，a 不含重复元素。
求 a 的所有长度至少为 2 的子数组 b 中，“b 的最大值异或 b 的次大值”的最大值。

如果改成“b 的最大值异或 b 的最小值”的最大值要怎么做？ @Hush	输入
5
5 2 1 4 3
输出 7
解释 4^3 = 7

输入
5
9 8 3 5 7
输出 15
解释 对于子数组 [8,3,5,7]，最大值^次大值 = 8^7 = 15	1800	https://codeforces.com/contest/280/submission/167043237

枚举每个 a[i] 作为次大值，找 a[i] 左边和右边最近的比 a[i] 大的数，作为最大值。

用单调栈来做。

实现的时候只需要一个栈+一次遍历，见代码。		
2022年8月4日	https://codeforces.com/problemset/problem/808/D

输入 n(≤1e5) 和长为 n 的数组 a(1≤a[i]≤1e9)。
你可以选择一个 a[i]，将其移除并插入到 a 的任意位置。
你能否在执行至多一次上述操作的限制下，将 a 划分成左右两部分，且这两部分的元素和相等？
能则输出 YES，不能则输出 NO。	输入
3
1 3 2
输出 YES
解释 把 3 移到末尾，得到 [1,2,3]，sum([1,2]) = sum([3]) = 3

输入
5
1 2 3 4 5
输出 NO

输入
5
2 2 3 4 5
输出 YES
解释 把 4 往左移一位，得到 [2,2,4,3,5]，sum([2,2,4]) = sum([3,5]) = 8	1900（个人感觉是 1700）	https://codeforces.com/contest/808/submission/166868234
Python 写法见右 @七水

首先，如果 tot = sum(a) 是奇数则输出 NO，如果 a 存在一个前缀和等于 tot/2 则输出 YES。

然后用前缀和 + 哈希表来解决。
同时遍历 a[i] 和 a 的前缀和 s[i]，把 a[i] 放到哈希表中，如果 s[i]-tot/2 在哈希表中，说明可以把哈希表中这个元素移到右半部分，使得左右两部分的元素和均为 tot/2，输出 YES。
然后用同样的方法倒着遍历一次，看能否把一个元素从右半部分移到左半部分，使得左右两部分的元素和均为 tot/2。

如果都不行则输出 NO。		
2022年8月3日	https://codeforces.com/problemset/problem/1060/C

输入 n(≤2000) 和 m(≤2000)，然后输入长为 n 的数组 a 和长为 m 的数组 b，数组元素均为 [1,2000] 内的整数，最后输入一个整数 x(1≤x≤2e9)。
定义矩阵 c[i][j] = a[i]*b[j]。
找到面积最大的子矩阵，其元素和不超过 x，输出这个最大面积（子矩阵的面积=行数*列数）。
如果不存在这样的子矩阵，输出 0。

进阶：有 2000 个询问，每个询问是一个 x（作为原问题的 x），要怎么做？

open question：时间复杂度能否低于平方？

把 * 改成 & 呢？* 和 + 都改成 & 呢？@小羊肖恩	输入
3 3
1 2 3
1 2 3
9
输出 4

输入
5 1
5 4 2 4 5
2
5
输出 1	1600	https://codeforces.com/contest/1060/submission/166757182

子矩阵的元素和等于 a 和 b 的子数组的元素和的积。

对 a 和 b，枚举子数组的长度，求固定长度下的元素和的最小值。

遍历所有 a 与 b 的最小值对，求出在最小值的积不超过 x 的情况下的最大长度积。
（最后这部分的遍历可以用双指针优化到 O(n+m)）		
2022年8月2日	https://codeforces.com/problemset/problem/1043/D

输入 n(≤1e5) 和 m(≤10)，然后输入 m 个长为 n 的排列，元素范围均在 [1,n]。
输出有多少个不同的非空子数组，是每个排列都有的。

注：子数组是连续的。	输入
3 2
1 2 3
2 3 1
输出 4
解释 [1] [2] [3] [2,3] 这 4 个子数组每个排列都有。

输入
5 6
1 2 3 4 5
2 3 1 4 5
3 4 5 1 2
3 5 4 2 1
2 3 5 4 1
1 2 3 4 5
输出 5
解释 [1] [2] [3] [4] [5]

输入
2 2
1 2
2 1
输出 2
解释 [1] [2]	1700	https://codeforces.com/contest/1043/submission/166640293
62ms 快读 https://codeforces.com/contest/1043/submission/166640185

对第 i 个排列，记录第 j 个元素 v 的下标 pos[i][v] = j。
然后遍历第一个排列，看它的子数组是否出现在所有排列中。
具体做法是，每次向右扩展一个元素 a[0][j]，看 pos[i][a[0][j]] 是否等于 pos[i][a[0][j-1]]+1
这样可以得到右端点为 j 的子数组的最长长度，从而得到子数组的个数。		
2022年8月1日	https://codeforces.com/contest/1519/problem/D

输入 n(≤5000) 和两个长为 n 的整数数组 a 和 b，元素值均在 [1,1e7] 中。
你可以至多反转一次 a 的某个子数组，求 sum(a[i]*b[i]) 的最大值（即最大化 a[0]*b[0]+a[1]*b[1]+...+a[n-1]*b[n-1]）。	输入
5
2 3 2 1 3
1 3 2 4 2
输出 29
解释 反转 a 的后两个元素，得到 [2,3,2,3,1]，sum(a[i]*b[i])=29。

输入
2
13 37
2 4
输出 174
解释 无需反转。

输入
6
1 8 7 6 3 6
5 9 6 8 8 6
输出 235
解释 反转 a 中的 [7,6,3]，得到 [1,8,3,6,7,6]，sum(a[i]*b[i])=235。	1600	https://codeforces.com/contest/1519/submission/166430407

暴力枚举是 O(n^3) 的，如何优化？

我们可以枚举反转的中心，然后向两侧扩展，每次扩展可以在上一次扩展的基础上计算，这样就能做到 O(n^2)。
注意反转的中心有两种，分别对应奇数长度和偶数长度的。

你也可以从区间 DP 的角度思考，见 https://www.luogu.com.cn/blog/292315/solution-cf1519d		
2022年7月29日	https://codeforces.com/contest/175/problem/C

输入 n(≤100) 表示 n 种怪物，然后输入 n 行，每行两个数字表示怪物的数量 (≤1e9)，和怪物的分数(≤1000)。
然后输入 t(≤100) 和一个长为 t 的数组 p，下标从 1 开始，1≤p[1]<p[2]<...<p[t]≤1e12，表示在你累计击败 p[i] 个怪物之后，得分系数将变为 i+1（初始得分系数为 1）。
击败一只怪物的得分 = 怪物的分数 * 当前得分系数。
你可以按照任意顺序打怪，输出击败所有怪物后的最大得分。	输入
1
5 10
2
3 6
输出 70
解释 前三只怪物得分系数为 1，后两只怪物得分系数为 2，总分=3*10*1+2*10*2=70

输入
2
3 8
5 10
1
20
输出 74
解释 所有怪物的得分系数均为 1，总分=3*8*1+5*10*1=74	1600	https://codeforces.com/contest/175/submission/166070298

贪心：按照得分从小到大打怪（排序不等式），这可以用双指针模拟。

为了方便计算，可以将 p 数组转换成每一段的长度（注意 p 数组实际上是一个前缀和），并在末尾加上一个 1e18 的哨兵。		
2022年7月28日	https://codeforces.com/problemset/problem/494/A

输入一个长度不超过 1e5 的括号字符串 s，s 中除了 '('，')' 外，还包含至少一个 '#'。
每个 '#' 都可以替换为一个或多个 ')'。问能否将所有的 '#' 都替换掉，得到一个有效括号字符串。
若不能，输出 -1；否则输出 s.count('#') 行，每行一个正整数，表示第 i 个 '#' 被替换成了多少个 ')'。若替换方案不止一种，输出任意一种即可。

注：一个字符串是有效括号字符串当且仅当它的左右括号个数相等，且任意前缀的左括号个数不超过右括号个数。

进阶：你能做到一次遍历吗？

进阶 2：如果要计算所有合法方案数要怎么做？(提问@七水)
如果 ## 替换成 )+)) 和 ))+) 算不同方案呢？算同一种方案呢？	输入 (((#)((#)
输出
1
2
解释 第一个 # 替换成 )，第二个 # 替换成 ))，得到 ((())(()))。

输入 ()((#((#(#()
输出
2
2
1

输入 #
输出 -1

输入 (#)
输出 -1	1500	https://codeforces.com/contest/494/submission/165854447

先把 '#' 改成 ')'，问题转换成可以在 '#' 的位置插入任意个 ')'。

用一个变量 d 表示 s 的平衡度：遇到 '(' 就 +1，遇到 ')' 或 '#' 就 -1。

数形结合一下，把 d 的变化折线图画出来，由于我们只能添加右括号，那么中途 d<0 则直接输出 -1。

如果最后 d>0，我们可以在最后一个 '#' 处添加右括号，这相当于把从这个 '#' 处开始的折线图往下移，使末尾的 d=0。
因此只要从 '#' 到末尾中间的 d 值不低于末尾的 d 值，就可以调整成一个有效括号字符串。

想一想，为什么要处理的是最后一个 '#'？

如果处理的是一个前面的 '#'，那要是遇到中间的 d 值小于末尾的 d 值，就会失败。那不如直接处理最后一个更优。 	说一点和这题有关的故事，这题是我在 19 年刚回坑时做的，当时写了个比较麻烦的 replace 的做法，而且还 WA 了一发。
https://codeforces.com/contest/494/submission/61223061
你能看出错在哪里吗？
这周我重新做了一遍这题，一眼就想出了我题解中的一次遍历做法。我相信这离不开持续的训练和总结。
你们在看我题解的时候，会发现我经常写出更加简洁的做法，CF 或者 LC 上。其实我也是从算法萌新一步步走过来的，不过我有一个习惯，就是喜欢到处看别人写的代码，比如运行最快、代码最短、通过最早等等，分析不同写法的优劣之处；有时还会看别人写错的代码，分析别人为什么会写错。很多很细节的东西，书上是不会讲的，就是零散地分布在互联网的小角落里了，等着你去发现，化为己用。	
2022年7月27日	https://codeforces.com/contest/1281/problem/B

输入 t(≤1500) 表示 t 组数据，每组数据输入两个字符串 s 和 c，长度不超过 5000，由大写字母组成。
你可以交换 s 中的至多一对字符，得到 s'，问能否使 s' < c（即 s' 的字典序严格小于 c）。
若能则输出任意一个符合要求的 s'，否则输出 "---"。
所有数据的 s 和 c 的长度之和各不超过 5000。

进阶：你能实现一个线性时间复杂度的做法吗？	输入
3
AZAMON APPLE
AZAMON AAAAAAAAAAALIBABA
APPLE BANANA
输出
AMAZON
---
APPLE	1600	https://codeforces.com/contest/1281/submission/165847470

不妨求 s 交换一次后的最小字典序 s'，然后看 s' < c 是否成立。

从左往右遍历 s，如果在 s[i] 右侧存在比它更小的字符，那么选择一个最小且最靠右的字符和 s[i] 交换，即得到 s'。

预处理每个字符在 s 中最后一次出现的下标即可。

你可以写一个 O(26n) 的代码，但是注意到如果 s[i] 右侧没有字符 k，那么继续遍历 s 也不会找到 k，根据这一点我们可以做到 O(n+26)，代码见上面链接。

群友写的 O(n) 时间 + O(1) 额外空间的写法 ->		
2022年7月26日	https://codeforces.com/contest/1467/problem/C

输入三个不超过 3e5 的正整数 n1 n2 n3，且 n1+n2+n3≤3e5。
然后输入三个长度分别为 n1 n2 n3 的整数数组，数组元素均在 [1,1e9] 内。

每次操作你可以选择两个非空数组 a 和 b，把 a 中的一个数字 x 移除掉，然后把 b 中的一个数字 y 修改为 y-x。
这样操作 n1+n2+n3-1 次后，就只剩下一个数字了，输出这个数字的最大值。	输入
2 4 1
1 2
6 3 4 5
5
输出 20
解释 [6,3,4,5] 的每个数字都移除并减到 1 上，剩下数组 [-17,2] 和 [5]；然后把 -17 和 2 移除并减到 5 上，得 20。

输入
3 2 2
7 5 4
2 9
7 1
输出 29	1900
（也有 1500 分的做法）	https://codeforces.com/contest/1467/submission/165643711

提示：负负得正。

提示：试试 n=1 和 n=2 这种数据很小的情况，从小数据入手去研究规律。

任意最优操作方案都可以分为如下两类：

第一类：
1. b 全部减到 a；
2. c 留一个数字，其余全部减到 a；
3. a 减到 c 剩下的那个数字上。
这样结果是 sum(b)+sum(c)-sum(a)，我们选择 sum() 最小的那个数组当作 a。

第二类：
1. b c 各留一个最小的数字，其余全部减到 a；
2. a 留一个最小的数字，其余全部减到 b 剩下的那个数字上；
3. a b 减到 c 剩下的那个数字上。
这样结果是 sum(a)+sum(b)+sum(c)-2*min(a)-2*min(b)，我们选择 min() 最小和次小的数组作为 a 和 b。

这两类方案的最大值为答案。

如果你没有想到上面的，或者想漏了一种，这里还有一种无脑爆搜的做法：

把每个数组分为最小值和其余值的和，这样至多有 6 个元素，然后搜索模拟所有可能的操作，取最大值。代码如下：

https://codeforces.com/contest/1467/submission/165648547		
2022年7月25日	https://codeforces.com/problemset/problem/297/B

输入三个正整数 n(≤1e5) m(≤1e5) 和 k(≤1e9)。
在海洋中有 k 种鱼类，编号从 1 到 k。设编号为 i 的鱼的重量为 wi，你不知道 wi 的具体数值，但是你知道 0<w1≤w2≤...≤wk，注意 wi 可以为小数。

接下来输入一个长为 n 的数组 a 和一个长为 m 的数组 b，表示 A 抓到了 n 条鱼，第 i 条鱼的种类为 a[i]，B 抓到了 m 条鱼，第 i 条鱼的种类为 b[i]。
如果存在某个序列 w，使得 A 抓到的鱼的重量之和严格大于 B 抓到的鱼的重量之和，输出 YES，否则输出 NO。	输入
3 3 3
2 2 2
1 1 3
输出 YES
解释 w=[1,2,2.5] 可以满足要求

输入
4 7 9
5 2 7 3
3 5 2 7 3 8 7
输出 NO	1600	https://codeforces.com/contest/297/submission/165616796

首先如果 n > m，我们只需要将所有的鱼的重量设为一样，A 的重量之和就比 B 多了，输出 YES。

否则如果存在 x，使得 A 抓到的重量 ≥ x 的鱼的数量比 B 多，那么将重量 < x 的鱼的重量设为一个无穷接近于 0 的值，就可以转换成上面的情况了，输出 YES。

否则输出 NO。

代码实现时可以将数组从大到小排序，然后看是否有 a[i] > b[i] 成立即可，具体见代码。		
2022年7月22日	https://codeforces.com/problemset/problem/1203/D2

输入两个字符串 s 和 t，长度均不超过 2e5，且由小写字母组成。保证 t 是 s 的子序列。
请你从 s 中删除一个最长的子串，使得 t 仍然是剩下的 s' 的子序列。
输出这个最长子串的长度。	原题的样例不是很好，我这里造一个：

输入
axxxbxc
abc
输出
3
解释：删除子串 xxx 后，s'=abxc，abc 是 s' 的子序列。	1700	https://codeforces.com/contest/1203/submission/165288618

前后缀分解。

把 t 分解成左右两部分，枚举所有分割位置 j。
对于左部分，匹配 s 的最短前缀；右部分，匹配 s 的最短后缀。
换句话说，记 pre[j] 为 t[j] 可以匹配到 s 的最小下标，suf[j] 为 t[j] 可以匹配到 s 的最大下标。
那么答案为最大的 suf[j+1]-pre[j]-1。
注意边界上的答案，即 suf[0] 和 len(s)-1-pre[-1]。

代码实现时可以先算 suf，在计算 pre 的同时计算答案，这样可以节省一个数组。		
2022年7月21日	https://codeforces.com/problemset/problem/1196/D2

输入 t(<=2e5)，表示有 t 组数据。
每组数据输入 n 和 k（1<=k<=n<=2e5)，和一个长为 n 的字符串 s，包含 RGB 三种字符。
输出至少修改 s 的多少个字符，可以使 s 中存在一个长度至少为 k 的 RGB 子串。
RGB 子串指无限长字符串 RGBRGBRGB... 的子串。
输入保证这 t 组数据的 n 的和不超过 2e5。	输入
3
5 2
BGGGG
5 3
RBRGR
5 5
BBBRR
输出
1
0
3
解释
第一组数据：一种方案是修改第一个字符为 R，这样 RG 是 RGB 子串。
第二组数据：不用修改，BRG 就是 RGB 子串。	1600	https://codeforces.com/contest/1196/submission/118029732

枚举把 s 修改成 RGBRGB.../GBRGBR.../BRGBRG...，然后做一个大小为 k 的滑窗即可。		
2022年7月20日	https://codeforces.com/contest/44/problem/H

输入一个旧号码 s，长度不超过 50，只包含 0~9。

你可以按照如下规则生成一个长度和 s 相同的新号码 t：
1. t[0] = 任意一个 0~9 的数字；
2. t[i] = (t[i-1]+s[i])/2   注意：如果除 2 余 1，t[i] 必须上取整或下取整，否则不变。

输出你可以生成多少个和旧号码不同的新号码。	输入 12345
输出 48

输入 09
输出 15	1700	https://codeforces.com/contest/44/submission/164897245

定义 f[i][j] 表示 t 的前 i 个数字，末尾为 j 的方案数。

我们采用刷表法来计算：用 f[i-1][j] 去计算其他状态，即 f[i][(j+s[i])/2] += f[i-1][j]。
如果 j+s[i] 是奇数就额外计算 f[i][(j+s[i])/2+1] += f[i-1][j]。

初始 f[0][j] = 1。
答案为 sum(f[n]) 或 sum(f[n])-1，取决于能否构造出和旧号码相同的新号码。

如果 abs(s[i-1]-s[i]) > 1，那么一定不会构造出和旧号码相同的新号码。

另外可以滚动数组优化 f 的计算。

注意开 64 位。😭 的一声哭出来（

思考题：答案的上界是多少？如何构造一个让答案最大的输入？	目前算出来的上界是 138015464838
对应的输入为 "201001" + "01"*22	
2022年7月19日	https://codeforces.com/problemset/problem/1051/D

输入整数 n(1<=n<=1000) 和 k(1<=k<=2n)。

你需要对一个 2 行 n 列的网格染色，每个格子需要染成白色或黑色中的一种。
输出网格中有 k 个同色连通块的染色方案数，模 998244353 的结果。

同色连通块指四方向相邻且同色的格子组成的(极大)区域，结合图片理解。	输入 3 4
输出 12（其中一种染色方案如图）

输入 4 1
输出 2

输入 1 2
输出 2	1700	定义 f[i][j][0/1/2/3] 表示前 i 列组成 j 个连通块，且第 i 列的颜色组合是 白白/白黑/黑白/黑黑 的方案数。

根据上一列的颜色组合来转移，具体见 https://codeforces.com/contest/1051/submission/164836262

优化 1：白黑/黑白是对称的，可以合并成一个状态 https://codeforces.com/contest/1051/submission/164837223
优化 2：滚动数组，注意 [0/1/2] 这三个状态的计算顺序 https://codeforces.com/contest/1051/submission/164838044
优化 3：注意到前 i 列最多可以组成 2*i 个连通块，因此可以优化一下循环的上界 https://codeforces.com/contest/1051/submission/164838234
优化 4：从转移方程可以看出，白白/黑黑也是对称的，也可以合并成一个状态 https://codeforces.com/contest/1051/submission/164839057

最终，我们优化到了 15ms。	相似题目：https://atcoder.jp/contests/abc248/tasks/abc248_f	
2022年7月18日	https://codeforces.com/problemset/problem/573/B

输入 n(1<=n<=1e5) 和一个长为 n 的数组 h(1<=h[i]<=1e9)。
给你 n 个积木塔，这些积木塔竖着并列摆放在地板上，均由相同的积木组成，第 i 个积木塔包含 h[i] 个积木。
如果一个积木，其上下左右都是积木或地板，那么它叫做内部积木，否则叫做外部积木。
每一时刻，你可以消除所有的外部积木。
输出消除所有积木所需的时间。	输入
6
2 1 4 6 2 2
输出 3（右图）

输入
7
3 3 3 1 3 3 3
输出 2	1600	https://codeforces.com/problemset/submission/573/164666280

提示 1-1：把关注点放在每列积木被清除的时刻上。答案为所有积木列被清除时刻的最大值。

提示 1-2：递推。

提示 2-1：如果在某个时刻第 i-1 列或第 i+1 列积木被清除了，那么下一时刻第 i 列积木就被清除了。另外，一列积木被清除的时间不会超过这列积木的高度。

提示 2-2：从左到右更新一遍，从右到左更新一遍。		
2022年7月15日	https://codeforces.com/problemset/problem/1081/B

输入 n(1<=n<=1e5) 和一个长为 n 的数组 a(0<=a[i]<=n-1)。
请你构造一个长度为 n 的数组 b，对于每个 b[i]，需要满足 b 中恰好有 a[i] 个元素和 b[i] 不同。
要求 1<=b[i]<=n。
如果不能构造，输出 "Impossible"；否则输出 "Possible" 和任意一个满足要求的数组 b。	输入
3
0 0 0
输出
Possible
1 1 1

输入
5
3 3 2 2 2
输出
Possible
1 1 2 2 2

输入
4
0 1 2 3
输出
Impossible	1500	https://codeforces.com/problemset/submission/1081/164214080

提示 1：转换一下，有 n-a[i] 个数和 b[i] 相同。

提示 2：把相同的 a[i] 分为一组。

提示 3：如果同一组内的元素个数比 n-a[i] 还多，那么在构造 b 时，需要每隔 n-a[i] 个数就换一个值。这同时说明，如果组的大小不是 n-a[i] 的倍数，那么就无法构造。		
2022年7月14日	http://codeforces.com/problemset/problem/468/A

输入整数 n(1<=n<=1e5)。
一开始黑板上写了 n 个数：1,2,3,4,...,n。
每次操作，你可以擦掉黑板上的两个数字 a 和 b，然后选择将 a+b，a-b 或 a*b 的其中一个写在黑板上。
这样操作恰好 n-1 次后，最终黑板上就只剩下一个数字了。
你能最终得到 24 吗？
若不能，输出 "NO"；否则输出 "YES" 和具体操作方案，输出的格式形如
"a + b = c"（注意空格）。若有多种操作方案，输出任意一种即可。	输入 1
输出 NO

输入 8
输出
YES
8 * 7 = 56
6 * 5 = 30
3 - 4 = -1
1 - 2 = -1
30 - -1 = 31
56 - 31 = 25
25 + -1 = 24	1500	https://codeforces.com/contest/468/submission/164086516

提示 1
n=4 要怎么操作，n=5 要怎么操作？

提示 2
对于 n>5 的情况，尝试找 1，然后转换成 n=4 或 n=5 的情况。

具体操作方式见代码，可以结合实际的输出来理解。
		
2022年7月13日	https://codeforces.com/problemset/problem/639/B

【易错题】
输入三个正整数 n(2<=n<=1e5), d 和 h(1<=h<=d<=n-1)。

请你构造一棵有 n 个节点，直径为 d，高度为 h 的无向树。
若无法构造，输出 -1；否则输出这棵树，用 n-1 条边表示（任意一种合法构造方案均可，节点的编号从 1 开始）。

直径：树上任意两节点的最远距离。
高度：节点 1 和任意节点的最远距离。	输入 5 3 2
输出（图左）
1 2
1 3
3 4
3 5

输入 8 5 2
输出 -1

输入 8 4 2
输出（图右）
4 8
5 7
2 3
8 1
2 1
5 6
1 5	1600	https://codeforces.com/problemset/submission/639/163977647

先说一般的构造逻辑：
1. 构造一条从 1 出发，长为 h 的链。
2. 如果 h<d，则构造另一条从 1 出发，长为 d-h 的链，这样直径就构造好了。
3. 其余点连到 2 上。

为了满足这个构造的条件，需要特判的东西还是挺多的：
1. 用两条长为 h 的链可以拼成长为 2h 的直径。如果 d>2h，返回 -1。
2. 特判 d=1，那么 n 只能是 2，否则返回 -1。
3. 特判 n=2，输出 1-2。
4. 特判 h=1，这个时候所有点只能连到 1 上，输出 1-2, 1-3, ..., 1-n。
5. 然后就是一般的构造了。		
2022年7月12日	https://codeforces.com/contest/1015/problem/D

输入正整数 n(2<=n<=2e9), k(1<=k<=2e5) 和 s(1<=s<=1e18)。
在数轴上有 1,2,3,...,n 共 n 个整点（位置），你一开始在 1 上。
每一步你可以移动到任意位置上（但不能原地不动），移动的距离就是两个位置的距离。
问能不能恰好走 k 步，使得移动的距离之和恰好为 s？
若不能，输出 "NO"；否则输出 "YES" 和 k 个数，表示每一步移动之后的位置。	输入 10 2 15
输出
YES
10 4 
解释 1->10->4，移动距离之和=abs(1-10)+abs(10-4)=9+6=15

输入 10 9 45
输出
YES
10 1 10 1 2 1 2 1 6 

输入 10 9 81
输出
YES
10 1 10 1 10 1 10 1 10 

输入 10 9 82
输出 NO	1600	https://codeforces.com/contest/1015/submission/163682002

构造方法有多种，分享下我的做法（Z 字抖动）。

大跨步：距离 = n-1
中跨步：距离 = 2~n-2
小碎步：距离 = 1

s 需要在 [k,(n-1)k] 中。

不断大跨步，每步会导致 s-=n-1，k--。
如果下一个大跨步之后不能让 s 在 [k,(n-1)k] 中，
则先走一个长为 s-k+1 的中跨步，然后剩下的都是小碎步。

实现见上面的代码。		
2022年7月11日	https://codeforces.com/problemset/problem/1372/C

输入 t 表示 t 组数据，每组数据输入一个正整数 n(<=2e5) 和一个长为 n 的 1~n 的排列 a。
每次操作，你可以选择 a 的一个子数组，将其错排（错排前后，子数组同一位置上的元素不能相同）。
输出将 a 变为升序，至少需要几次操作。
	输入
2
5
1 2 3 4 5
7
3 2 4 5 1 6 7
输出
0
2
解释
第一组数据，已经是排好序的。
第二组数据，选前五个数重排得到 4123567，然后选前四个数重排得到 1234567。
	1500	O(1) 空间复杂度做法：
https://codeforces.com/contest/1372/submission/163625532

答案至多为 2。

证明比较长，见官方题解 https://codeforces.com/blog/entry/79974	输出方案：https://www.codechef.com/submit/DEARRANGE	
2022年7月8日	https://codeforces.com/problemset/problem/1084/C

输入一个字符串 s，长度不超过 1e5，只由小写字母组成。
请你求出满足如下条件的 s 的下标序列 p 的个数：

1. p[i] < p[i+1]；
2. s[p[i]] 均为 'a'；
3. s[p[i]] 和 s[p[i+1]] 之间至少有一个 'b'。

输出答案模 1e9+7 的结果。	输入 abbaa
输出 5
解释 [0] [3] [4] [0,3] [0,4] 共 5 个

输入 agaa
输出 3	1500	https://codeforces.com/contest/1084/submission/136214166

f[i] 表示 s 的前 i 个字母（的下标）组成的合法序列个数。

当 s[i]≠'a' 时，f[i] = f[i-1]
当 s[i]='a' 时，f[i] = f[i-1] + f[last['b']] + 1   // 不选 or 选
其中 last['b'] 表示 'b' 上一次出现的下标。

答案为 f[-1]

实现时，f[] 可以压缩成一个变量。		
2022年7月7日	https://codeforces.com/problemset/problem/788/A

输入 n(<=1e5) 和长为 n 的整数数组 a(-1e9<=a[i]<=1e9)。
在满足 1<=l<r<=n 的前提下，输出 f(l,r) 的最大值（下列式子中的数组下标从 1 开始）。	输入
5
1 4 2 3 1
输出 3
解释 f(2,5)=abs(4-2)-abs(2-3)+abs(3-1)=2-1+2=3，f(1,2) 也等于 3

输入
4
1 5 4 7
输出 6
解释 f(1,4)=abs(1-5)-abs(5-4)+abs(4-7)=4-1+3=6	1600	https://codeforces.com/contest/788/submission/118121760

提示 1：奇偶性相同的 l，(-1)^(i-l) 的变化规律是一样的。

提示 2：求的是 abs(a[i]-a[i+1])*(-1)^(i-l) 的最大子段和。

提示 3：对 a 和 a[1:] 分别求一下，取最大值。		
2022年7月6日	https://codeforces.com/problemset/problem/1105/C

输入正整数 n(<=2e5)，l 和 r(1<=l<=r<=1e9)。
求有多少个不同的长为 n 的数组，数组元素值的范围为 [l,r]，且数组元素之和为 3 的倍数。
答案对 1e9+7 取模。	输入 2 1 3
输出 3
解释 [1,2], [2,1], [3,3] 共三种

输入 3 2 2
输出 1
解释 [2,2,2] 一种

输入 9 9 99
输出 711426616	1500	https://codeforces.com/problemset/submission/1105/162950964

定义 f[i][0/1/2] 表示长为 i，元素和为 0/1/2 的数组个数。

枚举第 i 个数所填的数字模 3 的结果，那么 f[i][0] = f[i-1][0]*c[0] + f[i-1][1]*c[2] + f[i-1][2]*c[1]，其余同理。
其中 c[0/1/2] 为 [l,r] 内模 3 余 0/1/2 的数字个数，计算这个可以考虑用 [0,r] 范围内的减去 [0,l-1] 范围内的。



进阶：实现 O(log n) 的做法。		
2022年7月5日	https://codeforces.com/problemset/problem/166/E

输入正整数 n(n<=1e7)。
一只蚂蚁站在一个四面体的某个顶点 D 上，沿着四面体的棱行走。
输出它走了恰好 n 条棱后，又重新回到顶点 D 的路径数，模 1e9+7 的结果。
路径中间可以经过 D。	输入 2
输出 3
解释 有 3 条路径：DAD, DBD, DCD

输入 4
输出 21	1500	https://codeforces.com/contest/166/submission/132173160

相对于起点 D，A/B/C 三点都是对称的。
设 f[i][0] 表示走了 i 条棱到达 D 的方案数，f[i][1] 表示走了 i 条棱到达 A/B/C 的方案数。
则 D 可以从 A/B/C 转移过来，A 可以从 B/C/D 转移过来，等等。
据此得：

f[i][0] = f[i-1][1] * 3
f[i][1] = f[i-1][0] + f[i-1][1] * 2

初始值 f[0][0] = 1, f[0][1] = 0。
答案为 f[n][0]。

注意用 64 位整数。		
2022年7月4日	https://codeforces.com/problemset/problem/1025/C

给你一个字符串 s，仅包含 'b' 和 'w'，长度不超过 1e5。

每次操作你可以任意选择一个位置 k，把字符串分为长为 k 的前缀和长为 len(s)-k 的后缀，反转前缀和后缀，再重新拼起来，得到一个新字符串代替原来的 s。（用 Python 来说就是 s = s[:k][::-1] + s[k:][::-1]）
k 可以为 0，即翻转整个 s。

你可以操作任意多次。请输出你能得到的最长 bw 交替子串（形如 bwbwbw... 或 wbwbwb...）的长度。	输入 bwwwbwwbw
输出 5
解释 bwwwbww|bw -> w|wbwwwbwb -> wbwbwwwbw   wbwbw 为答案对应的子串。

输入 bwwbwwb
输出 3
解释 无需操作，wbw 为答案对应的子串。	1600	https://codeforces.com/problemset/submission/1025/162703560

提示 1：把字符串首尾拼起来，形成一个环状的字符串。每次操作之后，字符串变成什么样了？（你可以在草稿纸上画出一个环形的 012345 下标序列，来模拟操作）




问题实际上求的是 s+s 的最长 bw 交替子串（但不超过 len(s)）。		
2022年7月1日	https://codeforces.com/contest/1009/problem/D

定义互质图：图中每条边所连接的两个点必须是互质的（但互质的两个点之间不一定要有边）。
图中点的编号从 1 到 n。

输入两个整数 n 和 m（范围都在 [1,1e5]）。
请你构造一个有 n 个点 m 条边的无向连通互质图，图中不能有自环（自己连向自己）或重边（多条一样的边）。
如果无法构造，输出 "Impossible"；否则输出 "Possible" 和 m 条边（输出任意一种合法的构造方案）。	输入
5 6
输出
Possible
2 5
3 2
5 1
3 4
4 1
5 4

输入
6 12
输出
Impossible	1700	https://codeforces.com/contest/1009/submission/86186458

选择 m 个值不超过 n 的互质对，二重循环枚举即可，收集到 m 个时退出循环。

如果收集不到 m 个，输出 Impossible。否则输出答案。

注意判断 m<n-1 的情况，此时图不是连通的，应输出 Impossible。		
2022年6月30日	https://codeforces.com/contest/518/problem/A

给你两个长度相同（不超过 100），均由小写字母组成的字符串 s 和 t，且 s 的字典序小于 t。

请你输出字典序在 s 和 t 之间的，长度相同且由小写字母组成的任意一个字符串。

若不存在这样的字符串，输出 "No such string"。	输入
aaaa
zzzz
输出
oxef

输入
abcdefg
abcdefh
输出
No such string	1600	https://codeforces.com/contest/518/submission/96459205

把 s 看成一个数字，将其 +1。

做法：倒着遍历 s，把末尾的 z 都改成 a，遍历到的第一个非 z 字母加一。

输出修改后的 s。如果这样做和 t 相同，就输出 No such string。		
2022年6月29日	https://codeforces.com/problemset/problem/1042/C

【易错题】
输入 n(2<=n<=2e5) 和一个长为 n 的数组 a(-1e9<=a[i]<=1e9)。

你有两个操作：
1. 选择两个未被删除的数字 a[i] 和 a[j]，把 a[i] 删掉，把 a[j] 变为 a[i]*a[j]。
2. 删除一个未被删除的数字 a[i]，该操作至多只能执行一次。

你需要操作 n-1 次，使得最后剩下的那个数字最大。
你不需要输出这个最大数，而是输出你的操作方案（多种方案输出任意一种）。

输出的格式：
操作 1 应输出 "1 i j"
操作 2 应输出 "2 i"

下标从 1 开始。	输入
5
5 -2 0 1 -3
输出
2 3
1 1 2
1 2 4
1 4 5
解释 如此操作后，我们可以得到 5*(-2)*1*(-3)=30

其余样例见原题。	1700	https://codeforces.com/contest/1042/submission/162207883

把 0 看成是垃圾桶，所有 0 扔到同一个 0 里面，然后把 0 删除，这样可以去掉所有的 0。

如果负数有奇数个，我们需要选一个绝对值最小的负数，把它也扔到 0 里面。

然后把剩下的负数和正数乘起来就好了。

具体实现见上面代码。		
2022年6月28日	https://codeforces.com/problemset/problem/439/C

【易错题】
输入整数 n, k(1<=k<=n<=1e5) 和 p(0<=p<=k)，以及 n 个不同的整数表示数组 a（1<=a[i]<=1e9)。

请你将 a 分割为 k 个子序列（子序列不要求连续），使得恰好有 p 个子序列的和均为偶数，k-p 个子序列的和均为奇数。

若不能分割，输出 "NO"；否则输出 "YES" 和 k 行，每行第一个数表示子序列的大小，然后是子序列的数。
输出任意一种合法方案，输出的顺序与输入的顺序无关。	输入
5 3 1
1 2 3 7 5
输出
YES
1 2
3 5 1 3
1 7
解释 分割为 1 个和为偶数的子序列和 2 个和为奇数的子序列。

输入
5 5 3
7 14 2 9 5
输出 NO	1700	https://codeforces.com/problemset/submission/439/162015618

把所有数字按照奇偶性分成两组，叫做 e 组和 o 组（表示 even 和 odd）。

构造方案：

e 组每个元素当作一个和为偶数的子序列。
o 组每个元素当作一个和为奇数的子序列。
o 组剩余元素，两两一组，当作一个和为偶数的子序列。

如此构造出 k-1 个子序列，剩余数字再组成一个子序列。

输出 NO 的情况：
1. o 组大小不足 k-p
2. o 组大小的奇偶性和 k-p 的奇偶性不同
3. 无法构造出足够多的和为偶数的子序列

推荐看看我上面贴的实现。有一些简化代码的小技巧。		
2022年6月27日	https://codeforces.com/problemset/problem/739/A

定义 mex(S) 表示不在数组 S 中的最小的非负整数。

输入 n(<=1e5) 和 m(<=1e5)，以及 m 个区间左右端点 l[i] 和 r[i]（下标从 1 开始）。
请你构造一个长为 n 的数组 a，使得 min(mex(a[l[i]..r[i]])) 最大，即最大化这 m 个子数组的 mex 的最小值。
输出最大化的值，以及数组 a。

数组 a 的元素值需要在 [0,1e9] 内。	输入
5 3
1 3
2 5
4 5
输出
2
1 0 2 1 0
解释 
三个子数组分别为 [1,0,2] [0,2,1,0] [1,0]
mex 分别为 3 3 2，最小值为 2

输入
4 2
1 4
2 4
输出
3
5 2 0 1	1700	https://codeforces.com/contest/739/submission/108662174

提示 1：答案至多是多少？

至多是最短的那个子数组的长度。

设这个长度为 L。

提示 2：能不能让所有长度为 L 的子数组，其 mex 都为 L？

可以，构造一个 0, 1, 2, ... L-1, 0, 1, 2, ..., L-1, 0, 1, 2, ... 的周期序列即可。		
2022年6月24日	https://codeforces.com/problemset/problem/1283/E

输入 n(<=2e5) 和长为 n 的数组 a(1<=a[i]<=n)。

对于每个 a[i]，你可以将其 +1 或 -1，每个 a[i] 至多修改一次。

输出修改后的 a 的不同元素个数的最小值和最大值。

不同元素个数即 len(set(a))。	输入
4
1 2 4 4
输出 2 4
解释 
修改为 [1,1,4,4]，不同元素个数有 2 个。
修改为 [1,2,3,4]，不同元素个数有 4 个。

输入
9
1 1 8 8 8 4 4 4 4
输出 3 8

输入
7
4 3 7 1 4 3 3
输出 3 6	1800	https://codeforces.com/contest/1283/submission/161609016

贪心。先求出 cnt[x] 表示 x 出现的次数。

最小值的操作方案：
从小往大遍历 cnt[x]，用一个变量 prev 记录上一组被修改的数的结果。
如果 prev 是 x-1 或 x，则将 x 并入上一组，否则将 x 都 +1。

最大值的操作方案：
从小往大遍历 cnt[x]，用一个变量 prev 记录上一个被修改的数的结果。
如果 prev < x-1，则将一个 x 减一；
如果还有不止一个 x，则将一个 x 加一。

具体实现见代码。	扩展 1：如果改成每个数都有一个变动区间 [left[i], right[i]] 呢？

扩展 2：如果改成可以动态添加删除 a 中的数字，每次添加删除后输出答案呢？	
2022年6月23日	https://codeforces.com/problemset/problem/1096/D

给你一个 n(<=1e5)，一个长为 n 的字符串 s 和一个长为 n 的数组 a(1<=a[i]<=998244353)。
表示每个 s[i] 都有一个对应的删除代价 a[i]。

请你删除 s 中的某些字符，使得 s 不包含 "hard" 子序列。
输出被删除字母的代价之和的最小值。

子序列不要求连续。s 仅包含小写字母。	输入
6
hhardh
3 2 9 11 7 1
输出 5
解释 删除前两个字符。

输入
8
hhzarwde
3 2 6 9 4 8 7 1
输出 4
解释 删除 'r'。

输入
6
hhaarr
1 2 3 4 5 6
输出 0	1800	写法一：https://codeforces.com/contest/1096/submission/161528827
写法二：https://codeforces.com/contest/1096/submission/161524065

看到子序列就要往 DP 上想。

先来讨论不包含 hard 子序列需要怎么删。
对于第 i 个字符：
不删：那么前 i-1 个字符不能包含 har 子序列（否则就构成 hard 子序列了）。
删：那么前 i-1 个字符可以包含 har 子序列，但不能包含 hard 子序列。

这样思考一番后，定义 dp[i][j=1/2/3/4] 表示删除 s 的前 i 个字符中的某些字符，使得结果不包含 "hard"[:j] 子序列的最小代价（"hard"[:j] 表示 "hard" 的长为 j 的前缀）。

如果 s[i] 是 "hard" 的第 j 个字符，那么有
dp[i][j] = min(dp[i-1][j-1], dp[i-1][j]+a[i])
表示不删 or 删，取二者最小值。

注意对于 dp[i][1] 来说，在遇到 "h" 时必须删除，因此可以把 dp[i][0] 初始化成 inf 从而简化逻辑。

如果 s[i] 不在 "hard" 中，转移就是 dp[i] = dp[i-1]

答案为 dp[n][4]。

实现时可以用滚动数组优化掉第一维。	dp[i][1/2/3/4] 分别表示

不能有 h
不能有 ha（可以有 h）
不能有 har（可以有 ha）
不能有 hard（可以有 har）	
2023年1月16日	https://codeforces.com/problemset/problem/1691/D

输入 t(≤1e5) 表示 t 组数据，每组数据输入 n(≤2e5) 和长为 n 的数组 a (-1e9≤a[i]≤1e9)。所有数据的 n 之和不超过 2e5。

请你判断，对数组 a 的每个非空子数组 b，是否都有 max(b) >= sum(b)？
如果是，输出 YES，否则输出 NO。
注：子数组是连续的。

进阶：做到 O(n) 时间复杂度。	输入
3
4
-1 1 -1 2
5
-1 2 -3 2 -1
3
2 3 -1
输入
YES
YES
NO
解释 对于第三组数据，子数组 b=[2,3] 是不满足的。	1800	https://codeforces.com/problemset/submission/1691/189346222

提示 1：看到子数组+max/min，一般可以先往单调栈上想。
计算出以 a[i] 为最大值的左右端点 L 和 R 可以选择的范围。

提示 2：用前缀和思考，那么从 L 到 i 之间选一个最小的前缀和，i 到 R 之间选一个最大的前缀和。
check 这两个的前缀和的差是否超过 a[i]。
求区间最大最小可以用 ST 表或者线段树实现。

有没有 O(n) 的做法呢？

提示 3：如果从 i-1 向左扩展直到 L，发现一个子数组的和 > 0 的话，那么就输出 NO，因为这个子数组的和 + a[i] 是 > a[i] 的。
也因此，可以在出栈的时候判断下，出栈的位置到 i 之间的子数组的和是否存在上述情况。
为什么只需要考虑出栈的位置？因为其它遍历过的且不在单调栈中的位置，所对应的子数组和在之前都 check 过了，也就说明它们都是 <= 0 的，自然是满足要求的，无需 check。		
2022年6月22日	https://codeforces.com/contest/1038/problem/D

给你一个 n(1<=n<=5e5) 和一个长为 n 的数组 a（-1e9<=a[i]<=1e9)，表示有 n 个卡比排成一排，每个卡比有个分数 a[i]。

每次你可以选择一个卡比，让它吃掉它左边或者右边的一个相邻的卡比，吃完后它的分数要减掉所吃的卡比的分数。

如此操作 n-1 次后，最后剩下的那只卡比的分数的最大值是多少？	输入
4
2 1 2 1
输出 4
解释
首先 a[1] 吃 a[2]，得到 a=[2,-1,1]
然后 a[1] 吃 a[2]，得到 a=[2,-2]
最后 a[0] 吃 a[1]，得到 a=[4]

输入
5
0 -1 -1 -1 -1
输出 4
解释 第一个卡比吃掉右边的四个。	1800	https://codeforces.com/contest/1038/submission/61225429

从特例入手：
如果 a 全为正数要怎么做？
如果 a 全为负数要怎么做？

如果全为正数，我们可以找到最小的卡比 x，让它暴风吸入它左右两侧的所有卡比（保留一个最旁边的），然后用这个最旁边的卡比吸入 x，这样最小的卡比取负号，其余卡比均取正号。

如果全为负数，我们可以找到绝对值最小的卡比，让它暴风吸入它左右两侧的所有卡比即可。

如果有正有负（把 0 归到正数中），我们可以先让与正数相邻的那个负数把它旁边的正数都暴风吸入（保留一个正数），然后用这个正数暴风吸入其余卡比（这些卡比均为负）。这种情况答案为 sum(abs(a[i]))。

上述三种情况都可以总结成 max(a)-min(a)+sum(abs(a[i]) for other a[i])

注意特判 n=1 的情况。		
2022年6月21日	https://codeforces.com/problemset/problem/1446/B

背景：最长公共子序列（LCS） https://leetcode-cn.com/problems/longest-common-subsequence/

给你 n,m(<=5000)，长为 n 的字符串 s，长为 m 的字符串 t。定义 LCS(x,y) 表示字符串 x 和 y 的最长公共子序列。

请你选择 s 的子串 s'，t 的子串 t'，最大化 4*len(LCS(s',t'))-len(s')-len(t') 的值。
输出这个最大值。

输入的字符串只包含小写字母。

子串是连续的，子序列不要求连续。	输入
4 5
abba
babab
输出 5
解释 s'="abb", t'="abab", LCS(s',t')="abb", 答案=4*3-3-4=5

输入
8 10
bbbbabab
bbbabaaaaa
输出 12

输入
7 7
uiibwws
qhtkxcn
输出 0	1800	https://codeforces.com/contest/1446/submission/161363517

考虑（子串中的）每个字母的贡献。

如果它作为 LCS 的一部分，那么贡献是 2，否则贡献是 -1。
（对比一下 LCS 那道题，贡献分别是 1 或 0）

所以在 LCS DP 的基础上修改一下贡献即可。

答案为 dp 数组的最大值。		
2022年6月20日	https://codeforces.com/contest/1092/problem/C

给你一个整数 n(2<=n<=100) 和 2n-2 个字符串，这 2n-2 个字符串恰好是某个未知的字符串的所有真前缀和真后缀，即长度从 1 到 n-1 的字符串各有两个。

请按输入顺序回答每个字符串是前缀还是后缀，前缀输出 'P'，后缀输出 'S'，如果答案不止一种，回答任意一种即可。

字符串均由小写字母组成。	输入
5
ba
a
abab
a
aba
baba
ab
aba
输出 SPPSPSPS
解释 这些输入是 "ababa" 的所有真前缀和真后缀。	1700	https://codeforces.com/contest/1092/submission/161272956

设两个最长的字符串为 p 和 s，那么原串只可能是 p+s[-1] 或者 s+p[-1]。

枚举这两种可能的原串，然后枚举相同长度的输入字符串，判断是否满足一个是前缀另一个是后缀，如果都不满足，则枚举下一个可能的原串。

由于需要按照输入顺序回答，还需要额外记录每个输入对应的下标。		
2022年6月17日	https://codeforces.com/problemset/problem/1280/B

给你 T(<=2e4) 表示有 T 组数据。
每组数据给你 r(<=60) 和 c(<=60)，保证所有数据的 r*c 之和不超过 3e6。
然后给你 r 行字符串，每行长度为 c，组成了一个只有 'A' 和 'P' 的网格图。

每次操作，你可以选择某一行的某一段，假设这一段是一把颜料刷，将其向上或者向下移动任意长度，每次移动都会用颜料刷替换对应的段（具体见图）。
你也可以选择某一列的某一段，将其向左或者向右移动任意长度，每次移动都会用颜料刷替换对应的段。

输出最少需要操作几次可以让整个网格图全为 'A'，若无法做到则输出 "MORTAL"。	输入
4
7 8
AAPAAAAA
PPPPAAAA
PPPPAAAA
APAAPPPP
APAPPAPP
AAAAPPAP
AAAAPPAA
6 5
AAAAA
AAAAA
AAPAA
AAPAP
AAAPP
AAAPP
4 4
PPPP
PPPP
PPPP
PPPP
3 4
PPPP
PAAP
PPPP

输出
2
1
MORTAL
4

解释
第一组数据见图，需要操作两次。	1800	https://codeforces.com/problemset/submission/1280/160912594

分类讨论：

全为 P："MORTAL"
全为 A：0 次
四周某条边全为 A：1 次
四角有 A：2 次（花费一次操作可以变为四周某条边全为 A 的情况）
中间某一行或某一列全为 A：2 次
四周某条边有 A：3 次（花费两次操作可以变为四周某条边全为 A 的情况）
其余：4 次（花费两次操作变为中间某一行或某一列全为 A 的情况）		
2022年6月16日	https://codeforces.com/problemset/problem/847/E

给你一个整数 n(<=1e5) 和一个长为 n 的字符串 s（包含 P*. 三种字符，其中 'P' 表示动物，'*' 表示食物，'.' 表示空地）。
所有动物每单位时间均能移动一个单位，动物移动到食物上就会吃掉食物，吃掉食物的时间忽略不计。
所有动物可以一起移动。请问吃掉所有食物最少需要多少时间。	输入 n=7, s="*..P*P*"
输出 3
解释 第一只动物吃掉最左边的食物，第二只吃掉剩下的，耗时为 3。

输入 n=10, s=".**PP.*P.*"
输出 2	1800	https://codeforces.com/contest/847/submission/160783663

二分答案，设为 t，判断 t 时间内能否吃掉所有食物。

从左往右遍历动物位置 x 和未被吃的食物位置 y（用另一个指针维护）：

1. 如果动物左侧没有食物，那么它可以吃掉 [x,x+t] 范围内的食物；
2. 如果动物左侧还有食物，那么它可以先左后右移动，也可以先右后左移动，根据 y 可以计算出这两种哪个可以让它往右移动最远（具体公式见代码）。

注意二分上界至少是 3n/2。（我写的 2n）		
2022年6月15日	https://codeforces.com/problemset/problem/1136/D

给你整数 n(<=3e5) 和 m(<=5e5) 表示有 n 个编号从 1 到 n 的人，m 对交换信息。
然后给你一个 1 到 n 的排列 a，表示这 n 个人从左到右排成一队。
然后给你 m 个互不相同的对 (x,y)，表示若 x 和 y 相邻且 x 在 y 左侧，则 x 可以和 y 交换位置。
输出队尾那个人最多可以向左移动多远（他到队尾的距离）。	输入 n=3, m=2, a=[3,2,1], pairs=[(3,1),(3,2)]
输出 1
解释 先交换 3 和 2，然后交换 3 和 1，那么 1 可以向左移动 1。	1800	https://codeforces.com/problemset/submission/1136/160698756

用一个数组 mustInSwap 记录左边的人需要和哪些人交换，才可以让队尾那个人向左移动。

初始 mustInSwap 只包含队尾那个人。

然后从倒数第二个人开始模拟，如果他可以和 mustInSwap 中的所有人发生交换，那么队尾的人可以向左移动；否则把他加入 mustInSwap，重复。

答案为 n-len(mustInSwap)。		
2022年6月14日	https://codeforces.com/problemset/problem/922/D

给你整数 n(<=1e5)，以及 n 个仅由字符 s 和 h 组成的字符串，且这 n 个字符串的长度之和不超过 1e5。
请你重新排列这 n 个字符串，然后拼成一个长字符串，使得 "sh" 子序列的出现次数最多。输出这个最大值。
注：子序列不要求连续。	输入 n=4, a=["ssh","hs","s","hhhs"]
输出 18
解释 重排拼接成 "ssshhshhhs"，这里面有 18 个 "sh" 子序列。	1800	https://codeforces.com/contest/922/submission/160482721

参考我在 https://www.bilibili.com/video/BV18t4y1p736 中提到的邻项交换法，对于两个字符串 x 和 y，如果 

x.count('s') * y.count('h') > y.count('s') * x.count('h')

那么 x 就应该排在 y 的前面。

因此自定义排序后即可得到最优解，然后扫描一遍统计 sh 子序列的个数。

相似题目：https://leetcode.cn/problems/largest-number/	疑问：为什么直接在自定义排序里面求 count('s') 也能很快通过？是数据太弱还是快排保证了不会对一个很长的字符串做很多次 count('s')？	
2022年6月13日	https://codeforces.com/problemset/problem/1082/B

【易错题】
给你整数 n(<=1e5) 和一个长度为 n 的字符串 s，只包含 G 和 S。
你可以至多交换一次 s 中的任意两个字符，求最长连续 G 的长度。

输入 n=10, s="GGGSGGGSGG"
输出 7
解释 把第一个 S 和最后一个 G 交换，得到 "GGGGGGGSGS"	输入 n=10, s="GGGSGGGSGG"
输出 7
解释 把第一个 S 和最后一个 G 交换，得到 "GGGGGGGSGS"	1600	https://codeforces.com/contest/1082/submission/160202876

按照 G 和 S 分组，每组是一个由连续相同字符组成的子串。

如果两个 G 组之间只有一个字符 S，并且 G 组的数目大于 2，那么就可以从别的 G 组中拿个 G 把 S 换掉（两个 G 串的长度和+1），否则只能从自己组里面拿个 G 出来换掉 S（两个 G 串的长度和）。

其余情况，可以从别的 G 组里面拿个 G 拼在 G 组的旁边（G 串的长度+1）。

注意有 0 个或 1 个 G 组的特殊情况。

另一种做法：https://codeforces.com/contest/1082/submission/160410421	相似题目 https://leetcode.cn/problems/grumpy-bookstore-owner/

扩展：如果交换的是任意不相交的等长两段呢？
idea@可信编程小能手	
2022年6月10日	https://atcoder.jp/contests/agc007/tasks/agc007_b

输入 n(<=20000) 和一个 1~n 的排列 p。

请你构造两个长度为 n 的数组 a 和 b，满足：
1. 元素值在 [1,1e9]
2. a 严格单调递增
3. b 严格单调递减
4. a[p[i]]+b[p[i]] 严格单调递增，即 a[p[0]]+b[p[0]] < a[p[1]]+b[p[1]] < ...

输出任意符合上述要求的 a 和 b。	输入 n=3, p=[2,3,1]
输出
a=[5,10,100]
b=[100,10,1]
解释 10+10 < 100+1 < 5+100	~1700	https://atcoder.jp/contests/agc007/submissions/32349215

我的思考过程：

假设 a[p[i]]+b[p[i]] 是 1 2 3 ...
再假设 b 是 -1 -2 -3 ... (最后再加个偏移量调整到 [1,1e9])
但是这样算的话，左边的样例算出来 a=[4,3,5] 了，而且也不太好调整。
不妨将 b 扩大 10 倍，即 -10 -20 -30，这样 a=[13,21,32]，看上去不错哦。

一般地，将 b 扩大 n 倍就能适用于一般情况了。

因此可以得到如下构造方案：
a[p[i]] = n*p[i] + i
b[i] = n*(n-i)	最坏情况下，max(a[n-1], b[0]) 的最小值可以是多少？	
2022年6月9日	https://codeforces.com/problemset/problem/939/E

一开始你有一个空数组 a。
接下来有 Q(<=5e5) 次操作或询问。
操作（用 1 和 x 表示）是往 a 的末尾添加一个在 [1,1e9] 的数字 x，保证添加后 a 仍然是非降的。
询问（用 2 表示）是请你选择 a 中的一个子序列（不要求连续）b，最大化 max(b)-avg(b)，这里 avg(b) 为 b 的平均值。
对于每个询问，输出 max(b)-avg(b) 的最大值。（保留 8 位小数即可）	输入
Q=4
1 1
1 4
1 5
2
输出 2.00000000
解释 b=[1,5], max(b)-avg(b) = 5-3 = 2	1800	https://codeforces.com/problemset/submission/939/159989325

显然最后一个元素必须选（可以列个不等式证明），当作 max(b)；其余的元素需要选 a 的前缀，这样 avg(b) 才能尽量小。

那么应该选哪个前缀呢？

我们可以从头开始，不断扩充前缀，如果待扩充的元素比当前的 avg(b) 要小，则可以继续扩充前缀，从而使 avg(b) 变得更小。

假设上一次操作我们选择了某个前缀，那么当下一次操作发生后，我们需要替换 max(b)，这会使 avg(b) 变大，因此我们可以直接在上一次操作的基础上继续扩充前缀。

因此双指针即可求出要选择哪个前缀。		
2022年6月8日	https://codeforces.com/problemset/problem/732/D

接下来的 n(<=1e5) 天你需要参加 m(<=1e5) 门课程的考试。
给你一个长度为 n 的数组 d，d[i]=0 表示第 i 天没有考试，否则表示第 i 天有第 d[i](1<=d[i]<=m) 门课程的考试。
还有一个长度为 m 的数组 a，表示第 i 门考试需要花费 a[i](1<=a[i]<=1e5) 天的时间备考，才能通过。
如果你在某一天参加了考试，那么你当天不能备考。
备考同一门课程的时间不需要连续。
请输出参加并通过这 m 门考试的最小天数（天数从 1 开始）。若无法做到，输出 -1。	输入 d=[0,1,0,2,1,0,2], a=[2,1]
输出 5（天数从 1 开始）
解释 d[0] 和 d[1] 备考课程 1，d[2] 备考课程 2，d[3] 通过课程 2，d[4] 通过课程 1

输入 d=[1,1,1] a=[3]
输出 -1	1700	https://codeforces.com/contest/732/submission/159901481

二分答案。
对于二分的 check 函数，从前往后遍历 d（i 不超过二分值），同时维护可以备考的天数 cnt，如果 d[i] 是当前课程的最后一次考试机会，那么 a[i] > cnt 则无法通过第 i 门课程，返回 false，否则 cnt -= a[i] 继续遍历。如果可以通过所有课程则返回 true。		
2022年6月7日	https://codeforces.com/problemset/problem/1118/E

给你两个数 m 和 n（均在 [2,2e5] 范围内）
请你构造 m 个互不相同的 pair，需满足：
1. 每个 pair 包含两个在 [1,n] 内的不同整数。
2. 两个相邻的 pair，第一个数不能相同，第二个数也不能相同。
如果不能构造，输出 NO，否则输出 YES 和这 m 个 pair	输入 m=4, n=3
输出 YES [(3,1),(1,3),(3,2),(2,3)]

输入 m=13, n=4
输出 NO	1700	https://codeforces.com/problemset/submission/1118/159687007

至多可以构造 n*(n-1) 个：

1 2
2 1
1 3
3 1
...
1 n
n 1
2 3
3 2
...
n-1 n
n n-1		
2022年6月6日	https://codeforces.com/problemset/problem/723/C

给你一个数组 a，长度不超过 2000，元素值在 [1,1e9]。另外还给你一个数 m (1<=m<=n)。
每次修改操作你可以将某个 a[i] 修改为任意数字。
定义 count(v) 表示 v 在 a 中的出现次数。
请你修改 a，最大化 min(count(v)), v in [1,m]，即最大化 count(1), count(2), ..., count(m) 的最小值。
按顺序输出：最大化的结果、最小修改次数、修改之后的 a。	输入 a=[1,2,3,2,2], m=2
输出 2 1 [1,2,1,2,2]
解释 修改一次后，[1,2] 内的每个数均出现至少两次

输入 a=[10,100,1000], m=3
输出 1 3 [1,2,3]	1600	https://codeforces.com/problemset/submission/723/159598106

最小次数的最大值为 n/m。
需要修改某些数字，使得 [1,m] 中每个数字均出现至少 n/m 次。
我们可以找出大于 m 的和出现次数超过 n/m 的数字，将其修改为出现次数小于 n/m 的那些数字。		
2022年6月3日	https://codeforces.com/problemset/problem/209/A

求一个长为 n(<=1e6) 的 01 交替串中有多少个 01 交替子序列。对结果模 1e9+7。

注意子序列不要求连续。	输入 n=3
输出 6
解释 交替串 101 有如下 01 交替子序列（x 表示不选）
1xx
x0x
xx1
10x
x01
101
你也可以用 010 当作交替串，算出来的结果仍然是 6。

输入 n=4
输出 11	1600	@小羊肖恩		
2022年6月2日	https://codeforces.com/problemset/problem/305/C

给你一个有序数组 a，长度不超过 1e5，0<=a[i]<=2e9。
请你求出 2^a[0]+2^a[1]+...+2^a[n-1] 的二进制中的 0 的个数。（^ 表示幂）	输入 a=[0,1,1,1]
输出 0
解释 和为 1+2+2+2=7 (111)

输入 a=[3]
输出 3
解释 和为 8 (1000)	1600	https://codeforces.com/problemset/submission/305/159205281

用 set 模拟二进制加法，set 中存储比特位为 1 的位置。

添加 2^a[i] 时，如果第 a[i] 个比特位为 1，则不断进位直到找到 0。进位的意思是将这一位从 set 中去掉。

最后答案为 max(set)-len(set)+1。

时间复杂度：每个比特位至多被添加和删除各一次，所以是 O(n) 的（如果你用的是哈希表的话）。		
2022年6月1日	https://codeforces.com/problemset/problem/156/B

有 n(<=1e5) 个人，编号从 1 到 n。其中恰好有一个人是罪犯。
同时还有 n 条陈述，每条陈述要么是 +x，表示 x 是罪犯；要么是 -x，表示 x 不是罪犯。(1<=x<=n)
已知这 n 条陈述中恰好有 m(<=n) 条是实话，有 n-m 条是假话。
对于每条陈述，如果这条陈述一定是实话，输出 "Truth"；如果一定是假话，输出 "Lie"；如果不确定是真是假，输出 "Not defined"。	输入 [+1], m=1
输出 ["Truth"]

输入 [-1,-2,-3], m=2
输出 ["Not defined","Not defined","Not defined"]

输入 [+2,-3,+4,-1], m=1
输出 ["Lie","Not defined","Lie","Not defined"]	1600	https://codeforces.com/problemset/submission/156/159122474

枚举。
假设 i 是罪犯，如果 “i 是罪犯” 的陈述数和 “j 不是罪犯”(j≠i) 的陈述数之和等于 m，则 i 可能是罪犯，否则 i 一定不是罪犯。
然后遍历所有陈述，按照上面统计的结果来输出对应的字符串。		
2022年5月31日	https://codeforces.com/problemset/problem/689/D

给你两个数组 a b，长度均为 n(n<=2e5)，元素范围 [-1e9,1e9]。
求所有满足 max(a[l..r]) = min(b[l..r]) 的区间 [l,r] 的个数。	输入 
a=[1,2,3,2,1,4]
b=[6,7,1,2,3,2]
输出 2
解释 （下标从 0 开始的区间）[3,3] 和 [3,4]，对于 [3,3] 有 max(2)=min(2)，对于 [3,4] 有 max(2,1)=min(2,3)	2100	https://codeforces.com/contest/689/submission/158934891

枚举左端点，区间 max 单调递增，区间 min 单调递减，因此可以二分或者双(三)指针找 max>=min 和 max>min 的最小(左)位置，两者相减即为右端点的合法个数。

求区间 max min 可以用线段树或 ST 表。线段树教程可以看群主 B 站视频。（右边链接）






话说这题改成 max^2 = min^2 还能不能做🤔	https://www.bilibili.com/video/BV18t4y1p736
	
2022年5月30日	https://codeforces.com/problemset/problem/949/A

给你一个只包含 01 的字符串 s，长度不超过 2e5。

请你将 s 拆分成若干个子序列（子序列不要求连续），使得每个子序列都是长度为奇数的，从 0 开始的 01 交替串，例如 0 010 01010 等等

如果无法拆分，输出 -1；否则输出组成这些子序列的下标数组（从 1 开始）。可以输出任意一种符合要求的解。	输入 s="0010100"
输出 [[1,3,4],[2,5,6],[7]] （具体输出格式见原题）
解释 拆分成 010 010 0

输入 s="111"
输出 -1	1600	https://codeforces.com/contest/949/submission/158846414

模拟。有两类 01 交替串，一类长度为奇数，一类长度为偶数。

奇数加 1 变偶数，偶数加 0 变奇数。

遍历 s：

遇到 0，我们就选一个偶数长度的交替串，末尾补上 0；如果没有偶数长度的，就新增一个 "0"；
遇到 1，我们就选一个奇数长度的交替串，末尾补上 1。

上述过程中记录下标。

遍历结束后，如果没有长度为偶数的交替串，则找到了答案。		
2022年5月27日	https://codeforces.com/problemset/problem/712/C

给你两个整数 x 和 y，满足 3<=y<x<=1e5。

从边长为 x 的等边三角形出发，每次操作你可以将其中一条边的长度修改为某个整数，要求修改后的三条边仍能组成一个三角形。

将三角形修改成边长为 y 的等边三角形，最少需要操作多少次？	输入 x=6, y=3
输出 4
解释 (6,6,6) -> (6,6,3) -> (6,4,3) -> (3,4,3) -> (3,3,3)	1600	https://codeforces.com/contest/712/submission/158586227

正难则反。

从边长为 y 的等边三角形出发，每次将最短的边修改为另外两条边的和减一，直到最短的边不低于 x。	https://leetcode.cn/problems/reaching-points/	
2022年5月26日	https://codeforces.com/problemset/problem/1310/A

给你两个数组 a 和 t，长度相同且不超过 2e5，1<=a[i]<=1e9, 1<=t[i]<=1e5。

你可以执行任意多次操作。每次操作，你可以给某个 a[i]+=1，该次操作的花费为 t[i]。

请问要使 a 中所有数字均不相同，最小花费是多少？	输入
a=[3,7,9,7,8]
t=[5,2,5,7,5]
输出 6
解释 把第二个数字加三次，得到 [3,10,9,7,8]，花费为 2*3=6	1700	https://www.luogu.com.cn/blog/endlesscheng/solution-cf1310a

题解 by 灵茶山艾府		
2022年5月25日	https://codeforces.com/problemset/problem/960/C

给你两个数 x 和 d，范围在 [1,1e9] 内。

定义一个非空子序列 b 是好的，需满足 max(b)-min(b) < d

请你构造任意一个满足要求的整数数组 a，要求 a 的长度不超过 1e4，a[i] 均在 [1,1e18] 范围内，且满足：

a 恰好有 x 个非空好子序列。（子序列不要求是连续的）

如果无法构造，输出 -1；否则输出 a 的长度和 a 的元素。	输入 x=4, d=2
输出 n=4, a=[10,100,1000,10000]
解释 每个元素单独形成一个子序列

输入 x=10, d=5
输出 n=6, a=[5,50,7,15,6,100]	1700	https://codeforces.com/contest/960/submission/158360849

提示 1：对于一段长为 k 且元素均相同的段，这一段包含了 2^k-1 个好子序列。

提示 2：我们总是可以将 x 拆分成若干个 2^k-1（注意 2^k-1 最小是 1，所以一定可以拆分）。

提示 3：可以贪心地构造，每次选最大的不超过 x 的 2^k-1，组成连续 k 个 v，这算一组。

对于 v 的选择，需要满足任意两组之间的 v 不能小于 d，那么 v 可以从 1 开始每次增加 d。

		
2022年5月24日	https://codeforces.com/contest/358/problem/D

给你 3 个长度均为 n(<=3000) 的数组 a b c，元素范围 [0,1e5]，具体含义见下文。

有 n 个物品排成一排，你可以按照任意顺序拿物品，并获得相应的分数：

1. 如果拿走某个物品时，相邻两个物品都没有被拿过，那么得到的分数为 a[i]
2. 如果相邻的两个物品恰好有一个被拿过，那么得到的分数为 b[i]
3. 如果相邻的两个物品都被拿走了，那么得到的分数为 c[i]

问拿走所有物品后，能够获得的最高分数为多少？	输入 
a=[1 2 3 4]
b=[4 3 2 1]
c=[0 1 1 0]
输出 13
解释 顺序为 4 3 2 1，得分为 a[3]+b[2]+b[1]+b[0]=4+2+3+4=13	1800	https://www.luogu.com.cn/blog/littleseven/solution-cf358d		
2022年5月23日	https://codeforces.com/problemset/problem/33/C

给你一个长为 n(<=1e5) 的数组，元素范围 [-1e4,1e4]。

你可以选择一段前缀和一段后缀（可为空），将所有被选择的元素改为其相反数（a[i] 变成 -a[i]）

问修改后的数组的所有元素之和的最大值。	输入 [-1,10,-5,10,-2]
输出 18
解释 修改为 [1,10,-5,10,2]	1800	https://codeforces.com/contest/33/submission/158116180

设中间一段未被修改的元素和为 x，那么其余部分元素和为 sum(a)-x，取反后为 x-sum(a)，此时数组元素和为 2x-sum(a)。

所以求个最大子段和即可。		
2022年5月20日	https://codeforces.com/problemset/problem/747/D

给你 n(<=2e5) 个数表示每天的温度 t[i] (-20<=t[i]<=20)，到达目的地需要 n 天。

你有两个轮胎，雪地胎和普通胎。
雪地胎可以在任何温度行驶，但只能用 k(<=n) 天。（不一定要连续使用 k 天）
普通胎只能在温度不为负的时候行驶，使用天数无限制。

你一开始用的是普通胎。在每天开始可以选择更换为另一种轮胎。

问这 n 天需要最少换几次轮胎？若无法做到则输出 -1。	输入 t=[-1,0,-1,0], k=3
输出 2
解释 前三天用雪地胎，最后一天用普通胎，因此第一天和最后一天要换轮胎	1800	https://codeforces.com/contest/747/submission/157761183

贪心。

先把负数覆盖了，然后不断找中间最短非负数的连续段合并，每次合并可以减少两次更换次数。

注意末尾非负连续段，这里覆盖了可以再减少一次更换次数。		
2022年5月19日	https://codeforces.com/problemset/problem/797/C

给你一个字符队列 s，长度不超过 1e5，由小写字母组成。
你还有一个空栈。

每次你可以执行下列操作之一，直到队列和栈均为空：
- 弹出队首字符，将其入栈。
- 弹出栈顶字符。

输出字典序最小的出栈序列。	输入 cab
输出 abc
解释：c 入栈，a 入栈，a 出栈，b 入栈，b 出栈，c 出栈

输入 acdb
输出 abdc	1700	https://codeforces.com/problemset/submission/797/157636876

贪心。

遍历 s，设当前下标为 i，算出 i 和 i 后面的最小字符 c，然后不断把不超过 c 的出栈，然后把 s[i] 入栈。

遍历结束后把栈清空。		
2022年5月18日	https://codeforces.com/problemset/problem/815/A

输入一个 n 行 m 列的矩阵，n 和 m 不超过 100，元素值均在 [0,500] 内。
请你判断能否从一个 n 行 m 列的零矩阵开始，每次操作给某一行全部 +1 或某一列全部 +1，来生成输入的矩阵。
若不能，输出 -1。若能，输出最少操作多少次，以及具体操作方案（任意顺序）：若操作在第 i 行上，输出 "row i"，操作在第 j 列上，输出 "col j"。	输入
n=3, m=5
2 2 2 3 2
0 0 0 1 0
1 1 1 2 1
输出
4
row 1
row 1
col 4
row 3

输入
n=3, m=3
0 0 0
0 1 0
0 0 0
输出
-1	1700	https://codeforces.com/contest/815/submission/157523558

每行（或者每列）的差分数组必须都相同，如果有不同的就是 -1。

如果有解，可以倒着想，从输入出发，每行或每列全 -1，需要操作多少次，所以可以用模拟来做。需要判断是先行后列还是先列后行，取操作数的最小值。

也可以通过行或者列的最小值来直接求出每行每列操作多少次。	相似题目 https://leetcode.cn/problems/remove-all-ones-with-row-and-column-flips/	
2022年5月17日	https://codeforces.com/problemset/problem/197/A

有一张长为 a 宽为 b 的桌子，以及数量无限的半径为 r 的圆形盘子（a b r 均为 [1,100] 的整数）
Alice 和 Bob 先后往桌子上放盘子，盘子之间不能重叠，且不能超出桌子的边界（可以紧贴边界或其它盘子）。无法放盘子的人输，另一个人赢。
如果先手能赢则输出 First，否则输出 Second。
	输入 a=5, b=5, r=2
输出 First

输入 a=6, b=7, r=4
输出 Second	1600	https://codeforces.com/contest/197/submission/157437054

如果盘子可以放在桌子上，那么先手把盘子放在桌子正中央，那么无论后手怎么放，先手都可以放在关于桌子中心对称的位置上，这样最后一定是后手没法放盘子。

因此只要盘子可以放在桌子上就是先手必胜，否则先手无法放任何盘子，必败。		
2022年5月16日	https://codeforces.com/problemset/problem/1148/D

给你 n(<=3e5) 个 pair，每个 pair 有两个整数。这 2n 个数各不相同，且元素值在 [1,2n] 中。

现在让你选择 k 个 pair，将这 k 个 pair 重新排列后（pair 内的数字顺序不变），组成一个振荡序列（不能出现连续两个递增或连续两个递减）。

比如 [(1,7), (6,4), (2,10), (9,8), (3,5)]
选择 (1,7) (3,5) (2,10)
得到振荡序列 1,7,3,5,2,10

求 k 的最大值，和组成序列的 pair 的下标。
	输入 [(1,7), (6,4), (2,10), (9,8), (3,5)]
输出 k=3, id=[1,5,3]

输入 [(5,4), (3,2), (6,1)]
输出 k=3, id=[3,2,1]	1800	https://codeforces.com/contest/1148/submission/157360894

构造。

设 pair 为 (a,b)，将所有 a<b 的 pair 归为一组，a>b 的归为另一组。

以 a<b 为例，将这组的 pair 按照 a 从大到小排序后，组成的一定是振荡序列，并且无法在任何位置插入任何 a>b 的 pair。

选 pair 多的那一组作为答案。		
2022年5月13日	https://codeforces.com/problemset/problem/429/B

给你一个网格图，长宽均不超过 1000，每个格子有一个分数 0<=a[i][j]<=1e5。

有两个人 A 和 B：
A 从左上角出发到右下角，每次只能向下或向右；
B 从左下角出发到右上角，每次只能向上或向右。

两人所走的路径必须恰好只在一个格子相交。注意是路径相交，两人不一定要相遇。

求去掉这个相交的格子后，其余在路径上的格子的分数之和的最大值。	










输入
100 100 100
100 1 100
100 100 100
输出
800
解释如上图	1600	https://codeforces.com/contest/429/submission/120031024

计算 4 个 DP：
A 从起点到 (i,j) 的最大得分
A 从终点到 (i,j) 的最大得分
B 从起点到 (i,j) 的最大得分
B 从终点到 (i,j) 的最大得分

由于只有一个交点，那么在相交位置，要么是 A 从上往下，B 从左往右，要么是 A 从左往右，B 从下往上。
枚举所有交点和这两种相交方式，取最大值作为答案。

注意交点不可能是网格图的边界。		
2022年5月12日	https://codeforces.com/problemset/problem/778/A

给你两个字符串 s 和 t（保证 t 是 s 的子序列），s 由小写字母组成，长度不超过 2e5。

再给你一个由 s 的所有下标组成的排列 p，设 p 的长为 x 的前缀为 p[:x]，你需要从 s 中删掉所有下标在 p[:x] 中的字符，得到字符串 s'。

输出满足 t 为 s' 的子序列的最大的 x。

注意子序列不要求连续。	输入 s="ababcba", t="abb", p=[5,3,4,1,7,6,2]
输出 3
解释 删除 s[5] s[3] s[4]（下标从 1 开始）得到 s'="abba"，满足 t 是 s' 的子序列	1700	https://codeforces.com/contest/778/submission/88660596

二分答案		
2022年5月11日	https://codeforces.com/problemset/problem/878/A

给你两个长度不超过 5e5 的数组 op 和 val，其中 op[i] 为 & | ^ 三种位运算中的一种，0<=val[i]<=1023
这表示如下函数 f，它接收一个整数 x(0<=x<=1023)，经过若干位运算后，再返回这个数

def f(x: int) -> int:
    x = x op[1] val[1]
    x = x op[2] val[2]
    ...
    x = x op[n] val[n]
    return x

请你写一个结构与 f 类似的新函数 g，其至多包含 5 对 op' 和 val'，且对任意 0<=x<=1023 均满足 f(x) = g(x)
输出 g 中的 op' 和 val'（其中 op'[i] 为 & | ^ 三种位运算中的一种，0<=val'[i]<=1023）	输入
op = ['|', '^', '|']
val = [3, 2, 1]
输出
op' = ['|', '^']
val' = [3, 2]

输入
op = ['&', '&', '&']
val = [1, 3, 5]
输出
op' = ['&']
val' = [1]	1600	https://codeforces.com/contest/878/submission/156773072

位运算常用技巧：把每一位拆开单独算

这样就能找到简化方法：只要某一位上发生了 & 0 或者 | 1，那么这一位的最终结果就是确定的

最后发现不用拆开也能算出来：

只看每一位的话，如果遇到了 |1 或者 &0，那么后面这个位的值是可以确定的。那么分类讨论：
这一位没有遇到 |1 和 &0，那么就根据 ^ 来算
这一位遇到了 |1 或者 &0：
     最后结果为 0：需要用 &0 来 set bit
     最后结果为 1：需要用 |1 来 set bit

最后变成三个 op val
先 ^ 一下把没有遇到 |1 和 &0 的 bit 确定了
然后把结果为 0 的用 & 来 set，把结果为 1 的用 | 来 set		
2022年5月10日	http://codeforces.com/problemset/problem/282/C

给你两个 01 串 s 和 t，长度均不超过 1e6，你可以对 s 执行任意次如下操作：

选择两个相邻的数字 x 和 y，计算出 p=x^y (xor) 和 q=x|y (or)，
然后替换 x 为 p，y 为 q；或者替换 x 为 q，y 为 p。

判断能否将 s 变为 t。

2023.1.22 押题成功！  https://leetcode.cn/contest/weekly-contest-329/problems/apply-bitwise-operations-to-make-strings-equal/	输入 s="11", t="10"
输出 "YES"

输入 s="1", t="01"
输出 "NO"

输入 s="000", t="101"
输出 "NO"	1500	https://codeforces.com/contest/282/submission/156568861

首先长度不同肯定不行。

然后发现 00 是不变的，10 和 01 可以变 11，11可以变 10 或 01。

那么全 0 无法变出 1，包含 1 无法变为全 0。由此猜想只要 s 和 t 均包含 1 或均不包含 1，那么 s 就能变为 t。

简单证明一下：
由于操作是可逆的（10 和 11 可以互相转化），所以只要 s 和 t 都能变成全 1 的字符串那么 s 就能变全 1，然后变成 t。
能变成全 1 只需要包含至少一个 1 就行了（每次把 10 或 01 变 11，直到没有 0）。		
2022年5月9日	https://codeforces.com/problemset/problem/163/A

给你两个字符串 s 和 t，只包含小写字母，长度均不超过 5000，求所有 (x,y) pair 的个数，满足：
1. x 是 s 的子串
2. y 是 t 的子序列
3. x 等于 y

请注意，在计算 (x,y) pair 时，重复的子串或子序列应视作多个不同的 (x,y) pair。例如：
s = "aa", t = "a"，那么 (s[:1],t) 和 (s[1:], t) 都是合法答案，因此答案为 2。

由于答案可能很大，输出答案对 1e9+7 取模后的结果。
	输入 s="aa", t="aa"
输出 5

输入 s="codeforces", t="forceofcode"
输出 60	1700	https://codeforces.com/contest/163/submission/117005013

定义 dp[i][j] 表示考虑 s 的前 i 个字符，和 t 的前 j 的字符，并且子串 x 一定以 s[i-1] 结尾的答案。

那么分类讨论：

如果 s[i] != t[j]：t[j] 无法选取，则 dp[i+1][j+1] = dp[i+1][j]
如果 s[i] == t[j]：t[j] 可选可不选，则 dp[i+1][j+1] = dp[i+1][j] + dp[i][j] + 1
不选就是 dp[i+1][j]
选就是把 s[i] 和 t[j] 拼到 dp[i][j] 的那些 pair 的末尾
+1 是把 s[i] 和 t[j] 单独算作一个 (x,y) pair

最后答案为 sum(dp[i][len(t)])

记得取模。		
2022年5月6日	http://codeforces.com/problemset/problem/439/D

给两个数组 a 和 b，长度均不超过 1e5，元素范围为 [1,1e9]。
每次操作可以使 a 或 b 中的任意元素 +1 或 -1，求使 min(a) >= max(b) 的最小操作次数。	输入 a=[2,3], b=[3,5]
输出 3

输入 a=[1,2,3], b=[3,4]
输出 4

输入 a=[4,5,6], b=[1,2]
输出 0	1700	https://codeforces.com/contest/439/submission/124942692

三分 x，然后执行操作使得 min(a)>=x>=max(b) ，可以发现随着 x 的变大，操作次数从大到小再到大

三分的知识见 https://oi-wiki.org/basic/binary/#_10		
2022年5月5日	https://codeforces.com/problemset/problem/924/C

有一条河，河的水位会在接下来的 n(<=1e5) 天发生变化。（见右图）
记录员每天会在当天水位处画一条线（如果已经有线就不画），并记录在水位上方的线的数目 m[i] (0<=m[i]<i)。
河水不会把线冲刷掉。第 1 天之前没有画线。

令 d[i] 表示第 i 天在水位下方的线的数目。
求 sum(d) 的最小值。	输入 m=[0 1 0 3 0 2]
输出 6（见下图）	1700	https://codeforces.com/contest/924/submission/156051485

转换成计算 sum(每天至少有多少条线)

思路类似 5 月 4 号题目的方法一，先倒着遍历 m 计算这一天至少有多少条线，然后正着遍历 m，计算这一天至少有多少条线。

注意答案可能会爆 int。		
		图片				
2022年5月4日	https://codeforces.com/problemset/problem/913/C

有 n(<=30) 种不同的饮料，第 i（i 从 0 开始）种饮料的体积为 2^i 升，价格为 c[i](<=1e9)，每种饮料的数量无限。

求购买至少 L(<=1e9) 升的饮料至少需要多少钱？	输入 c=[20 30 70 90], L=12
输出 150

输入 c=[10000 1000 100 10], L=3
输出 10

输入 c=[10 100 1000 10000], L=3
输出 30	1600	https://codeforces.com/contest/913/submission/83199779

方法一：二分答案

买第 i 种饮料时，如果买两瓶 i-1 类型的饮料要更便宜的话，那就改为买两瓶 i-1。这可以递推算出来买第 i 种饮料的最低价格。

二分答案，然后按饮料体积从大到小贪心去买饮料（由于上面预处理过了，能买的话直接买是最优的）

方法二：直接计算 O(n)

沿用二分答案的想法，在从大到小考虑的时候，额外考虑多买一瓶，多买一瓶后总体积就至少是 L 升了。

代码见官方题解 https://codeforces.com/blog/entry/56992
	群友 @freya 的解释：

预处理完价格后，从右往左遍历价格数组，用 目前还差的体积/当前位置的体积，在此时有两种方案：
1，向上取整（获得足够体积），暂存结果
2，向下取整（获得部分体积，或者刚好够），去下一个更小的体积，继续重复操作。	
2022年5月3日	http://codeforces.com/problemset/problem/893/D

你有一张奇怪的信用卡，初始金额为 0。
每天早上你可以去银行给卡充任意金额的钱。（也可以不去）
给你一个长度为 n(<=1e5) 的数组，第 i 天晚上会发生如下情况：（-1e4<=a[i]<=1e4）
如果 a[i]>0，卡里的钱自动增加 a[i]
如果 a[i]<0，卡里的钱自动减少 |a[i]|（卡里的钱可以为负的）
如果 a[i]=0，银行会查询卡里的余额，如果此时卡里的钱为负则会冻结信用卡。
并且，在任意时刻，卡里的钱都不能超过 d(1<=d<=1e9)。
为了不让卡被冻结，请问你至少要去银行几次（给卡充钱）？
如果无论如何卡里的钱都会超过 d，则输出 -1。	输入 a=[-1 5 0 -5 3], d=10
输出 0

输入 a=[-5 0 10 -11 0], d=10
输出 2

输入 a=[-10 0 20], d=4
输出 -1	1900	两种做法：

方法一：如果 a[i]=0 的时候钱 <0，那么一定要去银行了，不妨贪心地充尽可能多的钱，同时保证后续的增减不会超过 d

这就需要计算出 a[i] 的后缀和的最大值，充钱是不能超过这个最大值的

群友代码 https://codeforces.com/contest/893/submission/155822611

方法二：上下界分析法。

提示 1：在尽量少地去银行充钱的前提下，考虑卡里的钱最少和最多是多少。

做法：

设下界为 low，上界为 up，初始均为 0（因为还没去过银行充钱）

当 a[i]≠0 时则 low+=a[i] up+=a[i]
加完了如果 low>d 则输出 -1，如果 up>d 则将 up 置为 d

当 a[i]=0 时，如果 up < 0 那肯定要充钱了，充钱后 low=0 up=d
如果 low<0 则将 low 置为 0

群主代码 https://codeforces.com/contest/893/submission/141785970		
2022年5月2日	https://codeforces.com/problemset/problem/827/A

有一个未知的字符串 s（长度也未知），输入 n(<=1e5) 个子串的信息，每条信息包含一个子串和该子串在 s 中的至少哪些位置出现过。（输入的子串的长度之和 <=1e6，位置的个数 <=1e6，位置的下标<=1e6）

请你根据上述信息还原出一个字典序最小的 s。（保证 s 存在）	输入
n=3
子串 a 出现在 [1 3 5 7] 上
子串 ab 出现在 [1 5] 上
子串 ca 出现在 [4] 上

输出
abacaba	1700	每个出现的位置等价于一个操作：将区间 [x,x+len(substr)-1] 上的字符置为 substr。
由于题目保证 s 是存在的，那么已经赋值字符的位置就不用重新赋值了，需要跳过，跳过操作可以用并查集来实现。
最后为了保证 s 的字典序最小，没有赋值的位置要置为 'a'。

https://codeforces.com/contest/827/submission/155731179		
2022年4月29日	给你一个数组 a，长度不超过 3e5，1<=a[i]<=1e9。
你可以执行任意次操作，每次操作可以让某个 a[i]+=1，花费为 b[i] (1<=b[i]<=1e9)。
求使 a 任意相邻数字均不同的最小花费。
可以对同一个 a[i] 多次 +1。

https://codeforces.com/problemset/problem/1221/D	输入
a=[2,2,3]
b=[4,1,5]
输出
2（把 a 变成 [2,4,3]）

输入
a=[2,2,2]
b=[3,10,6]
输出
9（把 a 变成 [3,2,3]）	1800	每个数字增加的次数不会超过 2，那么定义 dp[i][0/1/2] 表示考虑前 i 个数字，且第 i 个数字增加 0/1/2 次的最小花费。
转移时 dp[i][j] 从 dp[i-1][k] 且 a[i]+j != a[i-1]+k 的状态转移过来。(取 min)

https://codeforces.com/contest/1221/submission/155262364
		
2022年4月28日	给你一个无向连通图，点 <=2e5，边 <= 2e5（无重边无自环），每个点有一个高度 h[i] (0<=h[i]<=1e8)，对于每条边 v-w，从 v 到 w 对快乐度的影响如下：

h[v] > h[w]：增加 h[v]-h[w]
h[v] < h[w]：减少 2*(h[w]-h[v])
h[v] = h[w]：不变

求从点 1 出发，能获得的快乐度最大是多少。

https://atcoder.jp/contests/abc237/tasks/abc237_e	h = [10 8 12 5]

输出 3，路径为 1-3-4
	1208	如果把减少的倍率从 2 改成 1 的话，那么上上下下都可以合并，找个高度最低的点 x，答案就是 h[1]-h[x]。

由于减少的倍率是 2，可以转换成只要高度增加，会额外产生 h[w]-h[v] 的开销，那么我们就需要求从 1 到 v 的最短路 dis[v]，来计算到每个点的最小额外开销。

答案为 max(h[1]-h[i]-dis[i])

https://atcoder.jp/contests/abc237/submissions/28975067	比赛中 SPFA 可以水过，赛后加了数据，实际难度估计应该在 1400-1600	
2022年4月27日	背景：最长公共子序列（LCS） https://leetcode-cn.com/problems/longest-common-subsequence/

给你三个字符串 s1、s2 和 t，长度均不超过 100，且仅包含大写字母。你需要求出 s1 和 s2 的 LCS，并且 t 不能是 LCS 的子串（或者说 LCS 不能包含 t）。如果没有 LCS 则输出 0。

请注意，子串一定是连续的，子序列可以是不连续的。

https://codeforces.com/problemset/problem/346/B	输入
s1 = AJKEQSLOBSROFGZ
s2 = OVGURWZLWVLUXTH
t = OZ
输出
ORZ

输入
s1 = AA, s2 = A, t = A
输出
0	2000	感觉记忆化会比较好写，用 
f(i,j,k) 表示现在枚举到 s1[i] 和 s2[j]，且匹配了 t 中的 k 个字符的答案，若 s1[i] = s2[j] 则需要用 KMP 来更新 k，其余同经典 LCS 做法。

https://codeforces.com/contest/346/submission/122209017	群主写的 KMP 文章

https://www.zhihu.com/question/21923021/answer/37475572	
2022年4月26日	背景：最大子段和 https://leetcode-cn.com/problems/maximum-subarray/

有 n(<=50) 个小数组，每个小数组的长度不超过 5000，元素值在 [-1000,1000] 范围内。
现在有一个压缩数组，由 m(<=250000) 个范围在 [1,n] 的下标组成，每个下标对应一个小数组。
求压缩数组解压后（用小数组替换下标）组成的大数组的最大子段和。

https://codeforces.com/problemset/problem/75/D	输入
n=3, m=4
3 个小数组 = [[1 6 -2], [3 3], [-5 1]]
压缩数组 = [2 3 1 3]

解压后得到
[3 3 -5 1 1 6 -2 -5 1]

最大子段和为
sum([3 3 -5 1 1 6]) = 9	2000	不错的题目，考察了最大子段和的两种计算方法

1. 定义状态 dp[i] 表示以 a[i] 结尾的最大子段和，则有状态转移方程 dp[i]=max(dp[i−1],0)+a[i]
2. 遍历 a 的同时维护前缀和的最小值，则遍历到 a[i] 时，当前最大子段和为 sum[i]-min(sum[j]), j<i

小数组用第一种方法算，大数组用第二种方法算，由于大数组需要知道前面的 min，小数组里面还需要算出 min 出来

具体见
https://codeforces.com/contest/75/submission/122293599		
2022年4月25日	给你一个的正整数 s（以长度不超过 1e5 的字符串形式表示，无前导零）。
要求删掉尽可能少的数字，使得删数后的 s' 能被 3 整除且 s' 无前导零。

输出 s'。如果无法得到符合要求的 s'，输出 -1。

https://codeforces.com/contest/792/problem/C	s = 1033
s' = 33

s = 10
s' = 0

s = 11
print(-1)	2000	2000 分的题。难度分偏高，估计是很多人被 rejudge 了。

贪心：比如 digit_sum % 3 == 1，那么可以删除末尾一个 %3=1 的数，或者删除末尾两个 %3=2 的数。

难点在于如何优雅地实现，以及一些细节上的处理。

https://codeforces.com/contest/792/submission/121561575		
2022年4月22日	在一条直线上有 n(<=1000) 个员工和 k(n<=k<=2000) 把钥匙。
n 个人的坐标为 a[i](1~1e9), k 把钥匙的坐标为 b[j](1~1e9)。
办公室位于坐标 p(1~1e9)。

员工的速度为一个单位。所有员工都必须要取得一把钥匙才能进入办公室。
一个坐标上的钥匙被拿了就没有了。

输出所有人均到达办公室的最短时间。

https://codeforces.com/problemset/problem/830/A	输入
n=2, k=4, p=50
a=[20, 100]
b=[60, 10, 40, 80]

输出
50	1800	https://www.luogu.com.cn/blog/endlesscheng/solution-cf830a		
2022年4月21日	你的公司有 n(<2e5 且为奇数) 名员工，你需要给他们发共计不超过 s(<=1e14) 的工资，对于第 i 位员工，他的工资应该在区间 [l[i], r[i]] 范围内(1<=l[i]<=r[i]<=1e9)。

保证 s 不小于所有 l[i] 之和。

问如何分配 s 可以使这 n 个人的工资的中位数最大。输出这个最大中位数。

https://codeforces.com/problemset/problem/1251/D	输入
n=5, s=26
l[i] r[i] 如下
4 4
2 4
6 8
5 6
2 7

输出
6

解释
分配成 4,3,6,6,7	1900	https://www.luogu.com.cn/blog/endlesscheng/solution-cf1251d		
2022年4月20日	给你一个长度不超过 1e5 的数组（元素范围在 -1e9 ~ 1e9），你要执行恰好三次操作，使得操作结束后数组所有数均为 0。

每次操作你需要选择一个区间（设区间长度为 len），对于区间内的数，加上 len 的任意倍（倍数可正可负可为 0）。注意这对每个数是互相独立的，比如 len=3，那么你可以给区间内的第一个数加 6，第二个数减 9，第三个数加 0。

请你给出任意一个合法方案，可以证明这个问题一定有解。

每个操作输出两行，第一行为区间左右端点（下标从 1 开始），第二行为每个数在该次操作下的变化量（需要能被 len 整除）。

https://codeforces.com/problemset/problem/1396/A	输入
4
1 3 2 4

输出

1 1 
-1
3 4
4 2
2 4
-3 -6 -6	1600	https://www.luogu.com.cn/blog/endlesscheng/solution-cf1396a		
2022年4月19日	给定一个长度不超过 2e5 的含有 abc? 四种字符的字符串，每个 ? 必须替换成是 abc 中的一个。（不同位置的 ? 的替换是互相独立的）

设 ? 的个数有 k 个，那么替换后一共有 3^k 个不同的只包含 abc 的字符串。

求这 3^k 个字符串中，子序列 abc 的出现次数之和。（对 1e9+7 取模）

https://codeforces.com/problemset/problem/1426/F	输入
ac?b?c

输出
24	2000


	https://www.luogu.com.cn/blog/endlesscheng/solution-cf1426f	相似题目 

https://leetcode-cn.com/problems/number-of-ways-to-select-buildings/	
2022年4月18日	给你 n(<=1e5) 个浮点数 (绝对值不超过 1e5)，记作数组 a，保证这 n 个数的和为 0。
你需要构造任意一个数组 b，满足 b[i] = floor(a[i]) 或者 b[i] = ceil(a[i])，且 sum(b) = 0

https://codeforces.com/problemset/problem/1186/D	输入
4
4.58413
1.22491
-2.10517
-3.70387

输出 
4
2
-2
-4	1500	https://www.luogu.com.cn/blog/endlesscheng/solution-cf1186d		
2022年4月15日	给你一个长度不超过 2e5 的字符串 s，和一个长度不超过 2e5 的字符串 t，求 s 的不同排列个数，满足这个排列是 t 的子串。

字母均为小写字母。	举例：s=ab, t=abab
答案为 2，排列 ab 和 ba 均在 t 中		解法一：滑窗 + 字符串哈希 + 哈希表
解法二：后缀数组，每次标记 height >= len(s) 的一串后缀		
2022年4月14日	背景：LC54. 螺旋矩阵 https://leetcode-cn.com/problems/spiral-matrix/

问题：给你 n 和 m，表示 n x m 的螺旋矩阵（n,m 均不超过 1e9），有 q(<=1e5) 个查询，查询要么是 "1 k"，要么是 "2 x y"，解释如下：
1. 输出从左上角 (1,1) 出发，走 k (k<n*m) 步后的坐标；
2. 输出从左上角 (1,1) 出发，走到 (x,y) 需要的步数。	图片				
2022年4月13日	背景：对于「求一个数组有多少个没有重复元素的非空子区间」这样的问题，我们可以用双指针法求出答案。

问题：给出数组长度 n(<=1e5)、元素值上界 m(<=1e5) 和上述问题的答案 k(<=1e10)，请你构造出任意一个元素值在 [1,m] 范围内的整型数组，使得用该数组作为输入时，上述问题的输出恰好为 k。若无法构造，输出 -1。	举例：n=3，m=2，k=5
构造：[1, 2, 1]		首先每个长度为 1 的区间都是合法的，先把这部分减掉，剩下就需要 k-n 个区间了。
构造方法就是一个个填，如果 k 比较大可以 1 2 3 .. m 1 2 3 .. m 这样循环。
可以发现每填一个数至多增加 m-1 个答案，某个时刻 k < m-1 的话，可以改变要填的数字使得增加的答案恰好为 k，然后，后面都填一样的就好了。		
2022年4月12日	给你一个 3 x 3 的矩阵，矩阵中的某些位置上已经填入了整数，范围 [-1e9,1e9]。现在让你给其余位置都填入整数，使得矩阵每行每列的三个数均组成一个等差数列（公差可以为任意整数）。无解时输出 -1，否则输出任意一个符合要求的 3 x 3 矩阵。	例如
14 X X
X X 18
X 16 X
的一个答案为
14 14 14
12 15 18
10 16 22		不断检查是否有一行或一列有两个数，这样可以推导出第三个数，重复直到没法推导出新的数，此时可以随便找个空位，枚举是填 0 还是 1（可以用数学，设未知数，推导出这个结论），然后重复上述流程。

时间复杂度 O(C * 2^9)，C 为不断检查是否有一行或一列有两个数的复杂度。		
2022年4月11日	给你一个长为 n(<=1e5) 的上界数组 up（up[i]<=1e5），求其最长前缀（设长度为 x），使得存在一个 1~x 的排列 p，满足 p[i] <= up[i]	比如 up=[4,1,1] 时，答案为 2，对应的 p=[2,1]		解法一：二分答案 + 排序
解法二：树状数组，每次查询在 up[i] 前面的，小于等于 up[i] 的数的个数是否小于 up[i]		
2022年4月8日	背景：
01 字典树（又叫异或字典树）可以用于解决一类“数组中的两个数的最大异或和”等问题（如力扣 421 题）。
代码实现时，需要将每个数字视作一个长度固定的 01 字符串插入字典树。

问题：
给你 n(<=1e5) 和 m(<=1e9)，请你构造出一个长度为 n 的数组，且每个元素的范围为 [0,m]，使得用户在做 421 题时，以该数组作为输入时，所生成的字典树中的节点个数最大。
求任意一个符合上述要求的数组，以及对应的最大节点个数。			https://github.com/EndlessCheng/codeforces-go/blob/master/copypasta/trie01.go#L231		
	解答见右	解答见右		点击单元格可以打开链接，右键复制单元格内容		