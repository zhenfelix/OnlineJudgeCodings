
// 2023.04.01-第四题-倒水魔法
// 题目内容

// 塔子哥是一个年轻的魔法学徒，他一直在努力学习各种魔法技能。他听说倒水魔法是一种非常强大的魔法，但也是一种非常难掌握的魔法。他早早地来到了魔法训练室，希望能够掌握这种魔法。

// 魔法训练室里有 nn 个神奇的杯子，有着不同的大，假设第 ii 个杯子已满，向其倒水，多余的水会正正好好流向第 i+1i+1 个杯子(如果 i=ni=n 时没有下一个杯子，不会有杯子接住此时多余的水而溢出到魔法训练室的水池）。

// 这些杯子有着初始固定的水量，每次练习后杯子里的水都会还原到最初状态。每次练习时，魔法黑板会告诉塔子哥需要将哪一人杯子倒满水。因为每个杯子的材质和形状有所不同所以对其释放倒水魔法需要消耗的魔法值不同。塔子哥想尽可能多练习，所以需要最小化每次消耗的魔法值的总量。
// 输入描述

// 第一行一个整数 nn ，表示杯了数量。

// 第二行 nn 个整数 x1,x2,...,xnx1​,x2​,...,xn​ ，依次表示第 ii 个杯子能容纳水的量（单位为毫升）。

// 第三行 nn 个整数 y1,y2,...,yny1​,y2​,...,yn​ ，依次表示第 ii 个杯子初始有的水量（单位为毫升）。

// 第四行 nn 个整数 z1,z2,...,znz1​,z2​,...,zn​ ，依次表示对第 ii 个杯子每添加1毫升水需要消耗的法力值。

// 第五行一个整数 mm ，表示练习的数量。

// 第六行 mm 个整数 q1,q2,…,qnq1​,q2​,…,qn​ ，依次表示第 ii 次练习时需要将第 qiqi​ 个杯子倒满。(每次练习过后，杯子里的水量都会还原为初始状态，不会影响到下一次练习）

// 1≤n,m≤3000，1≤yi≤xx≤109，1≤zi≤300，1≤qi≤n1≤n,m≤3000，1≤yi​≤xx​≤109，1≤zi​≤300，1≤qi​≤n
// 输出描述

// 输出第一行 mm 个数，依次表示每次训练时需要消耗的最小法力值。

// 如果杯子初始本身就是满的，则需要消耗的法力值为 00 。
// 样例

// 输入

// 3
// 1 2 3
// 1 1 2
// 1 2 5
// 2
// 3 1

// 输出

// 2 0

// 样例解释 第一次训练，最优方案如下:

// 初始时杯子的水量和最大容量分别为

// 1/1 1/2 2/3

//     给1号杯子(本身已满)倒水1毫升，消耗1点法力，水溢出转移到2号杯子，当前状态为1/1 2/2 2/3
//     2.继续给1号杯子(本身已满)倒水1毫升，消耗1点法力，水溢出到2号杯子(也已满)，继续溢出到3号杯子，此时3号杯子也被成功注满水，状态为: 1/1 2/2 3/3

// 共消耗2点法力。可以证明没有更优方案。

// 第二次训练时，

// 初始时杯子的水量和最大容量分别为(注意不同训练互不影响，因为训练结束后魔法会让水杯还原为初始状态)

// 1/1 1/2 2/3

// 可以发现1号杯子已满，不用注水，消耗法力为0。


#include<bits/stdc++.h>
using namespace std;
using ll = long long;

int main(){
    ios_base::sync_with_stdio(0);
    cin.tie(0);
    // freopen("contests/input", "r", stdin);
    int n,m,tmp;
    cin >> n;
    vector<int> arr(n), magic(n);
    vector<ll> ans(n), res;
    for (int i = 0; i < n; i++)cin >> arr[i];
    for (int i = 0; i < n; i++){
        cin >> tmp;
        arr[i] -= tmp;
    }
    for (int i = 0; i < n; i++)cin >> magic[i];
    for (int i = 0; i < n; i++){
        ll cur = 1e18, s = 0;
        for (int j = i; j >= 0; j--){
            s += arr[j];
            cur = min(cur,s*magic[j]);
        }
        ans[i] = cur;
    }
    cin >> m;
    for (int i = 0; i < m; i++){
        cin >> tmp;
        cout << ans[tmp-1];
        if (i < m-1) cout << " ";
        else cout << "\n";
    }

    return 0;
}