# 题目内容

# 曾经有一个名叫塔子哥的年轻程序员，他梦想成为一名优秀的算法工程师。一天，他遇到了这样一个问题：给定一个由 nn 个非负整数组成的数组，他每次可以选择其中一个数的二进制表示中的某一位进行取反操作，问他最少需要多少次操作才能使得这个数组中的所有数相等。

# 塔子哥日思夜想也没有想出来怎么解决这个问题，于是，他决定请教你这个问题，希望你能够提供一个更加高效的算法，以便让他能够早日实现自己的梦想。
# 输入描述

# 第一行输入一个正整数 nn ，代表数组的大小。

# 第二行输入 nn 个非负整数 aiai​ ，代表数组的元素。

# 1≤n≤1051≤n≤105 ， 0≤ai≤231−10≤ai​≤231−1
# 输出描述

# 一个整数，代表最小的操作次数。
# 样例

# 输入

# 5
# 3 5 1 4 8

# 输出

# 6


n = int(input())
arr = list(map(int,input().split()))
ans = 0
for _ in range(32):
    cnt = [0]*2 
    for i in range(n):
        flag = arr[i]&1
        cnt[flag] += 1
        arr[i] //= 2
    ans += min(cnt)
print(ans)