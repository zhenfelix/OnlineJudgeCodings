// 题目内容

// 塔子哥是一个程序员，他最近在处理一些字符串相关的任务。他喜欢 R 字符，因为在某些任务中，这个字符通常表示“正确”的结果。另一方面，他不喜欢 B 字符，因为在某些任务中，这个字符通常表示“错误”的结果。

// 为了解决他的任务，塔子哥定义了字符串的权值为字符串中 R 字符的出现次数。例如，对于字符串 BBRBRB，它的权值为 22，因为其中有 22 个 R 字符。

// 现在，塔子哥面临一个问题，他有一个长度为 nn 的字符串 ss，它仅由 R 和 B 组成。他想知道，长度为 nn 的仅由 R 和 B 组成的字符串中，字典序不小于 ss 的字符串的权值之和是多少？因此，他需要编写一个程序来解决这个问题。

// 由于答案可能太大，需要对 109+7109+7 取模后再输出。
// 输入描述

// 输入第一行为一个整数 nn ，表示字符串的长度。

// 输入第二行为一个长度为 nn 的字符串 ss ，字符串中元素组成仅为 R 和 B 。

// 2≤n≤1052≤n≤105
// 输出描述

// 输出一个整数，代表长度为 nn 的、字典序不小于 ss 的字符串权值之和。
// 样例

// 输入

// 3
// RBR

// 输出

// 7

// 样例解释

// 共有 33 个字符串符合要求： RBR 的权值为 22 。

// RRB 的权值为 22 。

// RRR 的权值为 33 。

#include <bits/stdc++.h>
#include <vector>
using namespace std;
using ll = long long;

int main() {
    ll MOD = 1e9+7;
    int n;
    cin >> n;
    string s;
    cin >> s;
    vector<ll> fs(n+1,1);
    for (int i = 1; i <= n; i++) {
        fs[i] = (2*fs[i-1])%MOD;
    }
    ll ans = 0;
    int cnt = 0;
    for (int i = 0; i < n; i++) {
        if (s[i] == 'R') {
            ans = (ans+1)%MOD;
            ++cnt;
        }
        else {
            int m = n-i-1;
            ans = (ans+(m==0 ? cnt+1 : (m+2*(cnt+1))*fs[m-1]))%MOD;
        }
    }
    cout << ans << endl;
    return 0;
}