// 题目内容

// 塔子与兔子两个兄弟刚学完计算机网络原理课程。他们对通信这一概念有位好奇。现在老师给了他们一个D路通信。他们面对的通信链路有如下几个性质:

//     高斯噪声性: 如果发出一段字符串作为消息，消息的开始前和结束后可能会出现随机高斯噪声;
//     内容完整性: 该过程不会丢失任何字符，字符顺序也不会发生变化；
//     字符统一性: 所有的消息内容和噪声都是小写字符;

// 依据链路的特点，他们俩想到了一种消除高斯噪声的算法:

//     同时采用两条含有随机噪声的链路发出一段消息。
//     在接收侧，在接收到的两条消息当中寻找最长的那段连续公共子串，就是有效信息。

// 现在塔子哥想求有效消息的长度，注意有效消息不一定是唯一的，也有可能为空， 只要求返回消息的长度，
// 输入描述

// 两行分别代表两个字符串，分别为两条链路收到的信息，仅包含小写字母。

// 0<len≤10000<len≤1000
// 输出描述

// 一行。

// 一个数字，以回车结束，表示有效信息的长度。
// 样例
// 样例一：

// 输入

// vsavvzxaaxvzvz
// zzczcaaa

// 输出

// 2

// 样例解释：

// 两条信息中，最长的公共字符串是 aaaa ,长度为 22 。
// 样例二：

// 输入

// tttazitazittz
// tazittttt

// 输出

// 6

// 样例解释：

// 两条信息中，最长的公共字符串是 tazitttazitt ,长度为 66 。

#include<bits/stdc++.h>
#include <vector>

using namespace std;

int main() {
    string a, b;
    cin >> a >> b;
    int n = a.length(), m = b.length();
    int ans = 0;
    vector<int> dp(m+1,0);
    for (int i = 0; i < n; i++) {
        vector<int> ndp(m+1,0);
        for (int j = 0; j < m; j++) {
            if (a[i] == b[j]) {
                ndp[j+1] = dp[j]+1;
                ans = max(ans, ndp[j+1]);
            }
        }
        swap(dp,ndp);
    }
    cout << ans << endl;
    return 0;
}